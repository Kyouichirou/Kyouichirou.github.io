<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Lian个人博客-数据与思考">
<meta name="description" content="Make Thing Better and Simpler">
<meta name="theme-color" content="#000">
<title>MySQL使用指南 | Lian</title>
<link rel="shortcut icon" href="/favicon.ico?v=1758516680740">
<link rel="stylesheet" href="/media/css/mist.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/tomorrow-night.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.18.0/languages/vbnet.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.18.0/languages/vbscript-html.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.18.0/languages/vbscript.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.18.0/languages/sql.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/velocity/1.5.1/velocity.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/velocity/1.5.1/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.11.1/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ["\\(", "\\)"]],
      displayMath: [['$$', '$$'], ["\\[", "\\]"]]
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a', 'annotation', 'annotation-xml'],
      ignoreHtmlClass: 'tex2jax_ignore|crayon-.*', // 'crayon-' 开头的类，属于Wordpress代码高亮库，这部分不需要处理，否则会导致显示不正确,这部分是正则式，多条之间用'|'分割
      processHtmlClass: 'tex2jax_process'
    },
    //禁用右键菜单	
    renderActions: {
      addMenu: [0, '', '']
    }
  };
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?19bd452dc174a21cc99fb66ddfcef0cc";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>



  <meta name="description" content="MySQL使用指南" />
  <meta name="keywords" content="priority,mysql" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="mist">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="">
              <span class="logo-line-before">
                <i class=""></i>
              </span>
              <span class="main-title">Lian</span>
              <span class="logo-line-after">
                <i class=""></i>
              </span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> Home
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> Archives
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> Tags
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://Kyouichirou.github.io/post/about-me" target="_self">
                  <i class="fa fa-globe"></i> About
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </li>
            
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout mist bg-color">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper  right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body mist" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper ">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Lian</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>make thing better and simpler.</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">103</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">64</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%89%8D%E8%A8%80">一. 前言</a>
<ul>
<li><a href="#11-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83">1.1 使用环境</a></li>
<li><a href="#12-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">1.2 图形管理工具</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81">二. 基本概要</a>
<ul>
<li><a href="#21-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.1 数据类型</a>
<ul>
<li><a href="#211-%E6%95%B0%E5%80%BC%E5%9E%8B">2.1.1 数值型</a></li>
<li><a href="#212-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">2.1.2 日期/时间</a></li>
<li><a href="#213-%E5%AD%97%E7%AC%A6%E4%B8%B2">2.1.3 字符串</a></li>
</ul>
</li>
<li><a href="#22-%E5%86%85%E7%BD%AE%E7%9A%84%E5%BA%93">2.2 内置的库</a></li>
<li><a href="#23-json">2.3 JSON</a></li>
<li><a href="#24-%E5%A4%A7%E5%B0%8F%E5%86%99">2.4 大小写</a></li>
<li><a href="#25-sql_mode">2.5 sql_mode</a></li>
<li><a href="#26-%E5%88%86%E5%8C%BA">2.6 分区</a></li>
<li><a href="#27-%E4%B8%B4%E6%97%B6%E8%A1%A8%E8%A1%8D%E7%94%9F%E8%A1%A8">2.7 临时表/衍生表</a></li>
<li><a href="#28-%E8%A1%8D%E7%94%9F%E5%88%97">2.8 衍生列</a></li>
<li><a href="#29-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86">2.9 用户管理</a>
<ul>
<li><a href="#291-291%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81%E6%96%B9%E5%BC%8F">2.9.1 2.9.1安全验证方式</a></li>
<li><a href="#292-292%E6%9D%83%E9%99%90">2.9.2 2.9.2权限</a></li>
<li><a href="#293-293%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86">2.9.3 2.9.3用户管理</a></li>
</ul>
</li>
<li><a href="#210-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">2.10 查询缓存</a></li>
<li><a href="#211-%E8%A7%86%E5%9B%BE">2.11 视图</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">三. 基本命令</a></li>
<li><a href="#%E5%9B%9B-%E5%9B%9B-%E6%97%A5%E5%BF%97">四. 四. 日志</a>
<ul>
<li><a href="#41-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97redo-log">4.1 重做日志(redo log)</a></li>
<li><a href="#42-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97undo-log">4.2 回滚日志(undo log)</a></li>
<li><a href="#43-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97binlog">4.3 二进制日志(binlog)</a></li>
<li><a href="#44-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97errorlog">4.4 错误日志(errorlog)</a></li>
<li><a href="#45-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97slow-query-log">4.5 慢查询日志(slow query log)</a></li>
<li><a href="#46-%E4%B8%80%E8%88%AC%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97general-log">4.6 一般查询日志(general log)</a></li>
<li><a href="#47-%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97relay-log">4.7 中继日志(relay log)</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%BC%95%E6%93%8E">五. 引擎</a></li>
<li><a href="#%E5%85%AD-%E4%BA%8B%E5%8A%A1">六. 事务</a>
<ul>
<li><a href="#61-%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7">6.1 隔离等级</a>
<ul>
<li><a href="#611-read-uncommitted">6.1.1 Read uncommitted</a></li>
<li><a href="#612-read-committed">6.1.2 Read committed</a></li>
<li><a href="#613-repeatable-read">6.1.3 Repeatable Read</a></li>
</ul>
</li>
<li><a href="#62-autocommit">6.2 autocommit</a></li>
<li><a href="#63-mvcc">6.3 MVCC</a>
<ul>
<li><a href="#631-mvcc%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">6.3.1 MVCC解决的问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E9%94%81">七. 锁</a>
<ul>
<li><a href="#71-%E8%A1%8C%E9%94%81record-lock">7.1 行锁(record lock)</a></li>
<li><a href="#72-%E9%97%B4%E9%9A%99%E9%94%81gap-lock">7.2 间隙锁(gap lock)</a></li>
<li><a href="#73-%E4%B8%B4%E9%94%AE%E9%94%81next-key-lock">7.3 临键锁(next-key lock)</a></li>
<li><a href="#74-%E8%87%AA%E5%A2%9E%E9%94%81auto-inc-lock">7.4 自增锁(auto-inc lock)</a></li>
<li><a href="#75-%E6%8E%92%E4%BB%96%E9%94%81exclusive-lock%E5%85%B1%E4%BA%AB%E9%94%81shared-lock">7.5 排他锁(exclusive lock)/共享锁(shared lock)</a></li>
<li><a href="#76-%E6%84%8F%E5%90%91%E9%94%81">7.6 意向锁</a></li>
<li><a href="#77-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81">7.7 插入意向锁</a></li>
<li><a href="#78-%E8%A1%A8%E9%94%81">7.8 表锁</a></li>
<li><a href="#79-%E4%B9%90%E8%A7%82%E9%94%81">7.9 乐观锁</a></li>
<li><a href="#710-%E6%82%B2%E8%A7%82%E9%94%81">7.10 悲观锁</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E7%B4%A2%E5%BC%95">八. 索引</a>
<ul>
<li><a href="#81-index%E5%92%8Ckey">8.1 index和key</a></li>
<li><a href="#82-%E7%BA%A6%E6%9D%9F">8.2 约束</a></li>
<li><a href="#83-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1">8.3 索引的设计</a></li>
<li><a href="#84-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95">8.4 联合索引</a></li>
<li><a href="#85-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE">8.5 自增主键</a></li>
<li><a href="#86-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95">8.6 前缀索引</a></li>
<li><a href="#87-%E4%B8%BB%E9%94%AE%E7%9A%84%E9%80%89%E6%8B%A9">8.7 主键的选择</a></li>
<li><a href="#88-btree">8.8 BTREE</a></li>
<li><a href="#89-null%E5%80%BC%E7%9A%84%E5%BD%B1%E5%93%8D">8.9 Null值的影响</a></li>
<li><a href="#810-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF">8.10 索引失效的场景</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D-explain%E8%A7%A3%E6%9E%90">九. explain解析</a>
<ul>
<li><a href="#91-id">9.1 id</a></li>
<li><a href="#92-select_type">9.2 select_type</a></li>
<li><a href="#93-table">9.3 table</a></li>
<li><a href="#94-type">9.4 type</a></li>
<li><a href="#95-possible_keys">9.5 possible_keys</a></li>
<li><a href="#96-key">9.6 key</a></li>
<li><a href="#97-key_len">9.7 key_len</a></li>
<li><a href="#98-ref">9.8 ref</a></li>
<li><a href="#99-rows">9.9 rows</a></li>
<li><a href="#910-extra">9.10 Extra</a></li>
<li><a href="#911-1-%E6%9F%A5%E7%9C%8B%E6%80%A7%E8%83%BD">9.11 1 查看性能</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">十. 基本使用</a>
<ul>
<li><a href="#101-%E5%A2%9E">10.1 增</a></li>
<li><a href="#102-%E5%88%A0">10.2 删</a></li>
<li><a href="#103-%E6%94%B9">10.3 改</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%85%B3%E9%94%AE%E5%AD%97">十一. 关键字</a>
<ul>
<li><a href="#111-changemodify">11.1 change/modify</a></li>
<li><a href="#112-between">11.2 between</a></li>
<li><a href="#113-inexists">11.3 in/exists</a></li>
<li><a href="#114-andor">11.4 and/or</a></li>
<li><a href="#115-havingwhere">11.5 having/where</a></li>
<li><a href="#116-group-byrollup">11.6 group by/rollup</a></li>
<li><a href="#117-deletetruncate">11.7 delete/truncate</a></li>
<li><a href="#118-collate">11.8 collate</a></li>
<li><a href="#119-prepareexecutedeallocate">11.9 prepare/execute/deallocate</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%8C-%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">十二. 函数/存储过程</a>
<ul>
<li><a href="#121-%E5%92%8C">12.1 @和@@</a></li>
<li><a href="#122-delimiter">12.2 delimiter</a></li>
<li><a href="#123-declare">12.3 declare</a></li>
<li><a href="#124-function">12.4 function</a></li>
<li><a href="#125-procedure">12.5 procedure</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89-%E8%AF%AD%E5%8F%A5">十三. 语句</a>
<ul>
<li><a href="#131-%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5">13.1 判断语句</a>
<ul>
<li><a href="#1311-case">13.1.1 <code>case</code></a></li>
<li><a href="#1312-if">13.1.2 <code>if</code></a></li>
</ul>
</li>
<li><a href="#132-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">13.2 循环语句</a>
<ul>
<li><a href="#1321-while">13.2.1 <code>while</code></a></li>
<li><a href="#1322-loop">13.2.2 <code>loop</code></a></li>
<li><a href="#1323-repeat">13.2.3 <code>repeat</code></a></li>
</ul>
</li>
<li><a href="#133-%E5%85%AC%E5%85%B1%E8%A1%A8%E8%BE%BE%E5%BC%8Fcet">13.3 公共表达式(CET)</a>
<ul>
<li><a href="#1331-%E9%80%92%E5%BD%92cet">13.3.1 递归CET</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%9B%9B-%E5%8D%81%E5%9B%9B-%E6%9F%A5%E8%AF%A2">十四. 十四. 查询</a>
<ul>
<li><a href="#141-%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2">14.1 联表查询</a></li>
<li><a href="#142-%E5%B9%B6%E9%9B%86union">14.2 并集(union)</a></li>
<li><a href="#143-%E4%BA%A4%E9%9B%86intersect">14.3 交集(intersect)</a></li>
<li><a href="#144-%E7%AC%9B%E5%8D%A1%E5%B0%94%E4%B9%98%E7%A7%AFcross-join">14.4 笛卡尔乘积(cross join)</a></li>
<li><a href="#145-%E8%87%AA%E8%BF%9E%E6%8E%A5self-join">14.5 自连接(self join)</a></li>
<li><a href="#146-%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2">14.6 聚合查询</a></li>
<li><a href="#147-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">14.7 窗口函数</a>
<ul>
<li><a href="#1471-%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0">14.7.1 分组函数</a></li>
<li><a href="#1472-%E6%8E%92%E5%90%8D%E5%87%BD%E6%95%B0">14.7.2 排名函数</a></li>
<li><a href="#1473-%E5%88%86%E6%A1%B6%E5%87%BD%E6%95%B0">14.7.3 分桶函数</a></li>
<li><a href="#1474-%E6%BB%91%E5%8A%A8%E5%87%BD%E6%95%B0">14.7.4 滑动函数</a></li>
</ul>
</li>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a>
<ul>
<li><a href="#1475-%E7%B4%AF%E7%A7%AF%E5%88%86%E5%B8%83">14.7.5 累积分布</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%94-%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F">十五. 备份和还原</a>
<ul>
<li><a href="#151-%E5%A4%87%E4%BB%BD">15.1 备份</a></li>
<li><a href="#152-%E8%BF%98%E5%8E%9F">15.2 还原</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%85%AD-%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86">十六. 日期处理</a>
<ul>
<li><a href="#161-%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4">16.1 获取时间</a></li>
<li><a href="#162-%E6%97%A5%E6%9C%9F%E5%A2%9E%E5%8A%A0-%E5%87%8F%E5%B0%91">16.2 日期增加 减少</a></li>
<li><a href="#163-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%97%A5%E6%9C%9F">16.3 日期格式化 字符串转日期</a></li>
<li><a href="#164-%E5%85%B6%E4%BB%96%E5%8F%82%E8%80%83%E5%87%BD%E6%95%B0">16.4 其他参考函数</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%83-%E5%A4%96%E9%83%A8%E4%BA%A4%E4%BA%92">十七. 外部交互</a>
<ul>
<li><a href="#171-python">17.1 Python</a></li>
<li><a href="#172-powerbi">17.2 PowerBI</a></li>
<li><a href="#173-vba">17.3 VBA</a>
<ul>
<li><a href="#1731-%E7%8E%AF%E5%A2%83">17.3.1 环境</a></li>
<li><a href="#1732-vba%E5%92%8Cmysql%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%BB%E8%A6%81%E4%BE%9D%E8%B5%96%E7%BB%84%E4%BB%B6">17.3.2 VBA和MySQL的连接主要依赖组件</a></li>
<li><a href="#1733-%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5">17.3.3 配置连接</a></li>
<li><a href="#1734-%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E8%AE%BF%E9%97%AE">17.3.4 在局域网中访问</a></li>
</ul>
</li>
<li><a href="#174-%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">17.4 文本数据交互</a>
<ul>
<li><a href="#1741-%E5%AF%BC%E5%85%A5">17.4.1 导入</a></li>
<li><a href="#1742-%E5%AF%BC%E5%87%BA">17.4.2 导出</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%85%AB-%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5">十八. 使用与实践</a>
<ul>
<li><a href="#181-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F">18.1 数据库设计范式</a>
<ul>
<li><a href="#1811-1nf">18.1.1 1NF</a></li>
<li><a href="#1812-2nf">18.1.2 2NF</a></li>
<li><a href="#1813-3nf">18.1.3 3NF</a></li>
</ul>
</li>
<li><a href="#182-%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5">18.2 业务实践</a></li>
<li><a href="#183-%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8">18.3 小表驱动大表?</a></li>
<li><a href="#184-%E6%9C%AF%E8%AF%AD">18.4 术语</a>
<ul>
<li><a href="#1841-%E5%9B%9E%E8%A1%A8">18.4.1 回表</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Kyouichirou.github.io/post/mysql-shi-yong-zhi-nan/"> MySQL使用指南 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item">
      <i class="fa fa-thumb-tack"></i>
      <span class="language" data-lan="top">置顶</span>
      <span class="post-meta-divider">|</span>
    </span>
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2023-02-10 17:04:50">2023-02-10</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://Kyouichirou.github.io/tag/7svOER7Ka/"> <span>priority</span> </a>、   
      <a href="https://Kyouichirou.github.io/tag/53itHjBFa/">
        <span>mysql</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >209<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >44935<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <pre><code class="language-python">'''
    @author: HLA
    @github: https://github.com/Kyouichirou
    @version: 1.0
    @description: mysql基础与进阶; 基础, 查询, 配置, 管理.
    @license: MIT

    -- make thing better and simpler.
'''
</code></pre>
<h2 id="一-前言">一. 前言</h2>
<p>在<code>MySQL</code>更新到<code>8.0</code>之后, 很多内容发生较大的变化, 而搜索引擎/书籍查询到的大量信息还是基于<code>5.x</code>, 例如查询缓存这个机制在<code>8.0</code>就发生大的变化, 对于一些相对晦涩难懂的部分, 如<code>日志, 锁, 事务, mvcc</code>等更应注意, 这部分内容可查询到的信息相当混乱(陈旧, 错误), 大量混杂着各个时期<code>MySQL</code>的一些特性在其中, 遇到难以理解的部分应多查阅官方文档.</p>
<!--more-->
<p><em>由于Typora会出现较为严重的卡顿在字数超过2万后, 部分内容拆出到其他文章中讨论.</em></p>
<h3 id="11-使用环境">1.1 使用环境</h3>
<blockquote>
<p><code>os: win10, 64bit pro</code></p>
<p><code>WSL2/VMware: ubuntu 22</code></p>
<p><code>MySQL version: 8.0.30</code></p>
</blockquote>
<p><a href="https://imgse.com/i/pSwetT1"><img src="https://s1.ax1x.com/2023/01/30/pSwetT1.png" alt="pSwetT1.png" loading="lazy"></a><br>
<a href="https://imgse.com/i/pSweJm9"><img src="https://s1.ax1x.com/2023/01/30/pSweJm9.png" alt="pSweJm9.png" loading="lazy"></a></p>
<p><code>Windows</code>下不建议直接使用压缩包, 解压添加环境变量, 手动逐个管理<code>MySQL</code>的组件. <a href="https://dev.mysql.com/downloads/windows/installer/8.0.html"><code>MySQL installer</code></a>, 一站式的管理服务(组件选择, 安装, 升级, 卸载, 变更版本).</p>
<h3 id="12-图形管理工具">1.2 图形管理工具</h3>
<ul>
<li>
<p><code>MySQL Workbench</code></p>
<figure data-type="image" tabindex="1"><a href="https://imgse.com/i/pSw3Whd"><img src="https://s1.ax1x.com/2023/01/30/pSw3Whd.png" alt="pSw3Whd.png" loading="lazy"></a></figure>
<ul>
<li>使用相对较少, 整体的界面布局偏向于管理员的操作平台.</li>
<li>免费, <code>os</code>要求<code>win10 or later</code>.(<em>win8.1 虽然可以安装, 但是会出现大量的闪退</em>)</li>
</ul>
</li>
<li>
<p><code>Navicat Premium</code></p>
<blockquote>
<p><em>the best software for mysql, maybe more databases.</em></p>
</blockquote>
<figure data-type="image" tabindex="2"><a href="https://imgse.com/i/pSw3qAg"><img src="https://s1.ax1x.com/2023/01/30/pSw3qAg.png" alt="pSw3qAg.png" loading="lazy"></a></figure>
<ul>
<li>付费.</li>
<li>交互界面简单易上手.</li>
<li>数据展示友好, 那怕是对于<code>nosql</code>的<code>mongodb</code>的文档型数据的展示. 也相对好地解决了<code>多层嵌套</code>下的数据展示的问题.</li>
<li>覆盖绝大部分的数据库, 不管是<code>sql</code>型数据库还是<code>nosql</code>型, 不管是本地, 还是远程数据库.</li>
<li>完备的功能支持, 从基础的代码辅助, 到数据库的设计, 用户/权限管理, 备份, 定时任务等等. 可将之视作数据库的瑞士军刀.</li>
</ul>
<p><code>navicat</code> 也存在着一些问题:</p>
<p>还不支持窗口函数的关键词的提示: 如 <code>unbounded, following, preceding</code>等</p>
<pre><code class="language-mysql"># 假如存在一张`user`表
# 选择美化sql语句之后, 导致在linux上运行的MySQL出现问题
# linux下的MySQL默认对表是大小写敏感的
SELECT
	*
FROM
# 这里将小写改成大写, 假如和关键词相同
USER
WHERE
	id = 1
	LIMIT 10;
</code></pre>
</li>
</ul>
<h2 id="二-基本概要">二. 基本概要</h2>
<figure data-type="image" tabindex="3"><a href="https://imgse.com/i/pShF9tU"><img src="https://s1.ax1x.com/2023/02/10/pShF9tU.png" alt="pShF9tU.png" loading="lazy"></a></figure>
<p><em>注意优化器的解析处理, 这将改变一些理论上的行为. 例如优化器认为走全表扫描比对索引来的更快, 也许并不会使用索引.</em></p>
<h3 id="21-数据类型">2.1 数据类型</h3>
<h4 id="211-数值型">2.1.1 数值型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围( 有符号)</th>
<th style="text-align:left">范围( 无符号, unsigned)</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 Bytes</td>
<td style="text-align:left">(-128 127)</td>
<td style="text-align:left">(0 255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 Bytes</td>
<td style="text-align:left">(-32 768 32 767)</td>
<td style="text-align:left">(0 65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 Bytes</td>
<td style="text-align:left">(-8 388 608 8 388 607)</td>
<td style="text-align:left">(0 16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 Bytes</td>
<td style="text-align:left">(-2 147 483 648 2 147 483 647)</td>
<td style="text-align:left">(0 4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 Bytes</td>
<td style="text-align:left">(-9,223,372,036,854,775,808 9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0 18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 Bytes</td>
<td style="text-align:left">(-3.402 823 466 E+38 -1.175 494 351 E-38) 0 (1.175 494 351 E-38 3.402 823 466 351 E+38)</td>
<td style="text-align:left">0 (1.175 494 351 E-38 3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 Bytes</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308 -2.225 073 858 507 201 4 E-308) 0 (2.225 073 858 507 201 4 E-308 1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0 (2.225 073 858 507 201 4 E-308 1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D)  如果M&gt;D 为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<pre><code class="language-bash"># 指定数据的精度的设置, 在浮点数上也将被移除
# unsigned, 无符号, 针对浮点数, 也将移除
# int(11), float(10, 2), 这种写法
# 包括官方文档的示例种这种写法依然还还常见.
mysql&gt; show warnings;
+---------+------+--------------------------------------------------------------------------------------------------------------------------+
| Level   | Code | Message
 |
+---------+------+--------------------------------------------------------------------------------------------------------------------------+
| Warning | 1681 | Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
 |
| Warning | 1681 | UNSIGNED for decimal and floating point data types is deprecated and support for it will be removed in a future release. |
| Warning | 1681 | Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
 |
| Warning | 1681 | UNSIGNED for decimal and floating point data types is deprecated and support for it will be removed in a future release. |
+---------+------+--------------------------------------------------------------------------------------------------------------------------+
4 rows in set (0.00 sec)
</code></pre>
<p>浮点数的处理是计算机中时一个相对麻烦的问题, 对于精度要求特别高的, 需要格外注意精度导致的数据不一致的问题, 高要求应当使用<code>decimal</code>类型的数据.</p>
<figure data-type="image" tabindex="4"><img src="https://p0.meituan.net/dpplatform/1aa2e26f66890db397559c99b8af07b023192.png" alt="number" loading="lazy"></figure>
<p><code>JavaScript</code></p>
<figure data-type="image" tabindex="5"><img src="https://p0.meituan.net/dpplatform/0491c1eb5ab53c3234ea925cf400a2bc3742.png" alt="precision" loading="lazy"></figure>
<pre><code class="language-JavaScript">&gt; 1 === 1.000000000000001;
false
&gt; 1 === 1.0000000000000001
true
&gt; '1.0000000000000001'.length;
18
</code></pre>
<p><code>python</code></p>
<pre><code class="language-python"># 长度和js部分的代码一致
print(1 == 1.000000000000001)
// False
print(1 == 1.0000000000000001)
// True
</code></pre>
<p><code>python-pandas</code></p>
<figure data-type="image" tabindex="6"><img src="https://p0.meituan.net/dpplatform/6af823b4c730813de0413ad71ba6a7dc69293.png" alt="pandas" loading="lazy"></figure>
<p><code>pandas</code>只是展示数据修改精度, 底层还是完整保存读取数据的精度.</p>
<h4 id="212-日期时间">2.1.2 日期/时间</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 ( bytes)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">'-838:59:59'/'838:59:59'</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">'1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'</td>
<td style="text-align:left">YYYY-MM-DD hh:mm:ss</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">'1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC结束时间是第 <strong>2147483647</strong> 秒 北京时间 <strong>2038-1-19 11:14:07</strong> 格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td style="text-align:left">YYYY-MM-DD hh:mm:ss</td>
<td style="text-align:left">混合日期和时间值 时间戳</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql"># 时间戳的使用
# 对于核心表, 一般需要加上这两个字段, 以便于在出现问题时回溯
create table test_table(
    -- 默认使用当前的时间戳
    created_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 设置当数据发生变化时, 更新时间戳
    modified_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
);
</code></pre>
<h4 id="213-字符串">2.1.3 字符串</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0-65535 bytes</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<p>需要注意, <code>char</code>, <code>varchar</code>的存储情况.</p>
<pre><code class="language-bash">mysql&gt; create table ta (s char(3));
Query OK, 0 rows affected (0.07 sec)

mysql&gt; insert into ta values ('a'), ('a ');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

# 默认模式下, char类型对于结尾的空格数据会进行自动的移除操作
mysql&gt; select length(s) from ta;
+-----------+
| length(s) |
+-----------+
|         1 |
|         1 |
+-----------+
2 rows in set (0.00 sec)

mysql&gt; select concat(s, 'b') from ta;
+----------------+
| concat(s, 'b') |
+----------------+
| ab             |
| ab             |
+----------------+
2 rows in set (0.00 sec
</code></pre>
<pre><code class="language-bash">set session sql_mode = 'pad_char_to_full_length';

# 不管你插入的数据的长度如何, 都全部拉宽到3的长度(剩余位置用空格填充)
mysql&gt; set session sql_mode = 'pad_char_to_full_length';
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; select length(s) from ta;
+-----------+
| length(s) |
+-----------+
|         3 |
|         3 |
+-----------+
2 rows in set (0.00 sec)

mysql&gt; select concat(s, 'b') from ta;
+----------------+
| concat(s, 'b') |
+----------------+
| a  b           |
| a  b           |
+----------------+
2 rows in set (0.00 sec)
</code></pre>
<pre><code class="language-mysql"># 查看数据的存储
# 行格式有4种 分别是Dynamic  Compact  Redundant 和Compressed
SHOW VARIABLES LIKE &quot;innodb_default_row_format&quot;;
</code></pre>
<pre><code class="language-mysql">/*
我们常见的 GBK UTF8 UTF8-MB4 这些都是多字节字符集
GBK : 一个字符最多占 2 个字节
UTF8: 一个字符最多占 3 个字节
UTF8MB4: 一个字符最多占 4 个字节
字符集设置为latin1,1个字符=1个字节,字段允许为null
*/
mysql&gt; create table test ( address varchar(65536) default null ) charset=latin1;
ERROR 1074 (42000): Column length too big for column 'address' (max = 65535); use BLOB or TEXT instead

mysql&gt; create table test ( address varchar(65535) not null ) charset=latin1;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535.
This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs

mysql&gt; create table test2 ( address varchar(65533) not null ) charset=UTF8;
ERROR 1074 (42000): Column length too big for column 'address' (max = 21845); use BLOB or TEXT instead

mysql&gt; create table test4 (name char(255) not null, address varchar(21590) not null ) charset=utf8;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535.
This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
</code></pre>
<blockquote>
<p>那么 <code>varchar</code> 类型字段的最大字节数应该就是</p>
<p>(utf-8)</p>
<p>65535 (行最大字节数) - 255*3 (一个字符最多占 3 个字节) = 64770</p>
<p>然后再减去 2 个长度前缀字节</p>
<p>64770 - 2 = 64768</p>
<p>最后再算出 varchar 最大字符数为 64768 / 3 = 21589.33.</p>
</blockquote>
<p>简而言之, 就是<code>varchar</code>, 在存储数据时, 有部分空间用于存储标注字段长度, 以及考虑到<code>null</code>值得存在.</p>
<p>所以其最大的存储空间, 需要将这部分得内容纳入进去. 详细内容见下面两个参考链接.</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/101215458">参考链接, zhihu</a></li>
<li><a href="https://blog.csdn.net/qq_34115899/article/details/117524328">参考链接_csdn</a></li>
</ul>
<h3 id="22-内置的库">2.2 内置的库</h3>
<p><code>world</code>,<code>sakila </code> 这两个数据库, 是示例数据库, 在使用<code>MySQL installer</code>安装时, 可以取消安装. 其他的安装方式一般不带有这两个数据库.</p>
<pre><code class="language-mysql">show databases;
-- 初始状态的数据库列表(mysql installer)
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| world              |
+--------------------+

# wsl
mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
</code></pre>
<ul>
<li>
<p><code>information_schema</code>: 提供了访问数据库<a href="https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020">元数据</a>的方式. 其中保存着关于<code>MySQL</code>服务器所维护的所有其他数据库的信息 如数据库名 表名 列的数据类型 访问权限等.</p>
</li>
<li>
<p><code>mysql</code>: 这个是<code>MySQL</code>的核心数据库. 主要负责存储数据库的用户 权限设置 关键字以及<code>MySQL</code>自己需要使用的控制和管理信息等.</p>
</li>
<li>
<p><code>performance_schema</code>: 主要用于收集数据库服务器性能参数 如提供进程等待的详细信息 包括锁 互斥变量 文件信息; 保存历史的事件汇总信息 为提供MySQL服务器性能做出详细的判断; 对于新增和删除监控事件点都非常容易 并可以改变<code>MySQL</code>服务器的监控周期等.</p>
</li>
<li>
<p><code>sys</code>: 是<code>MySQL5.7</code>新增的系统数据库, 其在<code>MySQL5.7</code>中是默认存在的. 在<code>MySQL5.6</code>及以上版本可以手动导入.这个库通过视图的形式把<code>information_schema</code>和<code>performance_schema</code>结合起来, 查询出更加令人容易理解的数据.</p>
</li>
<li>
<p><code>sakila</code>样本数据库是<code>MySQL</code>官方提供的一个模拟<code>DVD</code>租赁信息管理的数据库 提供了一个标准模式 可作为书中例子,教程 文章 样品,等等 对学习测试来说是个不错的选择.</p>
</li>
<li>
<p><code>world</code>, 样本数据库, 世界城市信息, 如人口等.</p>
</li>
</ul>
<h3 id="23-json">2.3 JSON</h3>
<p><code>mysql</code>已经原生支持<code>sql</code>, <code>xml</code>等文档型的数据, 使用场景, 例如产品信息的录入, 假如其属性值不是相对固定的, 则单纯是<code>sql</code>结构存储, 在字段的创建上并不方便将其数据拆分出<code>基础属性</code>和<code>扩展属性</code>, 扩展属性以<code>json</code>的方式存储.(<em>不存在的键值在<code>mysql</code>中并不会像<code>python</code>直接报错</em>).</p>
<p>但是对于构造复杂, 且庞大的数据库, 是否值得引入<code>json</code>结构的字段还是需要谨慎考虑.(是否需要使用<code>mongodb</code>作为数据的补充部分)</p>
<figure data-type="image" tabindex="7"><img src="https://p0.meituan.net/csc/83acd9bd3ccaa992fa773a578dd3923412940.png" alt="json" loading="lazy"></figure>
<pre><code class="language-mysql">CREATE TABLE test_json(
  id int auto_increment primary key,
  event_name varchar(255),
  visitor varchar(255),
  properties json,
  browser json
);

INSERT INTO test_json(event_name, visitor,properties, browser)
VALUES (
  'pageview',
   '1',
   '{ &quot;page&quot;: &quot;/&quot; }',
   '{ &quot;name&quot;: &quot;Safari&quot;, &quot;os&quot;: &quot;Mac&quot;, &quot;resolution&quot;: { &quot;x&quot;: 1920, &quot;y&quot;: 1080 } }'
),
('pageview',
  '2',
  '{ &quot;page&quot;: &quot;/contact&quot; }',
  '{ &quot;name&quot;: &quot;Firefox&quot;, &quot;os&quot;: &quot;Windows&quot;, &quot;resolution&quot;: { &quot;x&quot;: 2560, &quot;y&quot;: 1600 } }'
),
(
  'pageview',
  '1',
  '{ &quot;page&quot;: &quot;/products&quot; }',
  '{ &quot;name&quot;: &quot;Safari&quot;, &quot;os&quot;: &quot;Mac&quot;, &quot;resolution&quot;: { &quot;x&quot;: 1920, &quot;y&quot;: 1080 } }'
),
(
  'purchase',
   '3',
  '{ &quot;amount&quot;: 200 }',
  '{ &quot;name&quot;: &quot;Firefox&quot;, &quot;os&quot;: &quot;Windows&quot;, &quot;resolution&quot;: { &quot;x&quot;: 1600, &quot;y&quot;: 900 } }'
),
(
  'purchase',
   '4',
  '{ &quot;amount&quot;: 150 }',
  '{ &quot;name&quot;: &quot;Firefox&quot;, &quot;os&quot;: &quot;Windows&quot;, &quot;resolution&quot;: { &quot;x&quot;: 1280, &quot;y&quot;: 800 } }'
),
(
  'purchase',
  '4',
  '{ &quot;amount&quot;: 500 }',
  '{ &quot;name&quot;: &quot;Chrome&quot;, &quot;os&quot;: &quot;Windows&quot;, &quot;resolution&quot;: { &quot;x&quot;: 1680, &quot;y&quot;: 1050 } }'
);
</code></pre>
<p>实际上存储的是<code>json</code>结构的字符串, 也可以通过字符串的方式来检索数据.</p>
<figure data-type="image" tabindex="8"><img src="https://p0.meituan.net/dpplatform/86f75925d79a9b8f9b2f05e8bd5da13e12715.png" alt="string" loading="lazy"></figure>
<pre><code class="language-mysql">insert into test_json (event_name, visitor,properties, browser) values (&quot;test&quot;, &quot;5&quot;, &quot;test_a&quot;, &quot;test_b&quot;);
-- error, 不满足json结构的字符串会直接报错
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://p1.meituan.net/csc/4cb92a3cb66298241afc862ff762bc4212752.png" alt="json_search" loading="lazy"></figure>
<p>精确查找<code>json</code>结构中的数据, 使用<code>$</code>符号作为标注.</p>
<p>在<code>python(mysql_connector)</code>中, 返回的数据类型也是字符串格式而不是<code>obj</code>, 有别于<code>mongodb</code>(<code>pymongo</code>)的区别.</p>
<h3 id="24-大小写">2.4 大小写</h3>
<p>注意表的名称的大小写和字段内容的大小写的敏感差异.</p>
<ul>
<li>
<p><code>Windows</code>下</p>
<pre><code class="language-mysql"># 查询的时候是不区分大小写的, 针对表名称
mysql&gt; select * from Abc;
Empty set (0.02 sec)

mysql&gt; show variables like 'lower_case_file_system';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| lower_case_file_system | ON    |
+------------------------+-------+
1 row in set (0.01 sec)
</code></pre>
</li>
<li>
<p><code>Linux</code></p>
<pre><code class="language-mysql"># `Linux`下, 对于检索的`表的名称`是区分大小写的.
mysql&gt; select * from Next;
ERROR 1146 (42S02): Table 'test_db.Next' doesn't exist

mysql&gt; show variables like 'lower_case_file_system';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| lower_case_file_system | OFF   |
+------------------------+-------+
</code></pre>
</li>
</ul>
<pre><code class="language-bash"># 默认状态下, 运算时, 不区分大小写, 不管是Windows还是Linux
mysql&gt;  select &quot;a&quot; = &quot;A&quot;;
+-----------+
| &quot;a&quot; = &quot;A&quot; |
+-----------+
|         1 |
+-----------+
1 row in set (0.00 sec)

mysql&gt; select ('a' = &quot;A&quot;);
+-------------+
| ('a' = &quot;A&quot;) |
+-------------+
|           1 |
+-------------+
1 row in set (0.02 sec)

mysql&gt; select binary &quot;a&quot; = &quot;A&quot;;
+------------------+
| binary &quot;a&quot; = &quot;A&quot; |
+------------------+
|                0 |
+------------------+
1 row in set, 1 warning (0.00 sec)

# utf8mb4_0900_ai_ci, ci (case insensitive)
mysql&gt; show table status from test_db like 'test';
+------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+--------------------+----------+----------------+---------+
| Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time | Check_time | Collation          | Checksum | Create_options | Comment |
+------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+--------------------+----------+----------------+---------+
| test | InnoDB |      10 | Dynamic    |    2 |          24576 |       49152 |               0 |            0 |
    0 |           NULL | 2023-01-17 12:20:43 | NULL        | NULL       | utf8mb4_0900_ai_ci |     NULL | partitioned    |         |
+------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+--------------------+----------+----------------+---------+
1 row in set (0.03 sec)
</code></pre>
<pre><code class="language-mysql"># 对字段的内容就进行控制, 强制对字段要求大小写敏感
mysql&gt; create table test_k (name char(4) binary);
Query OK, 0 rows affected, 1 warning (0.11 sec)

mysql&gt; insert into test_k values ('aA');
Query OK, 1 row affected (0.01 sec)

mysql&gt; select * from test_k where name = 'aa';
Empty set (0.00 sec)

mysql&gt; select * from test_k where name = 'aA';
+------+
| name |
+------+
| aA   |
+------+
1 row in set (0.00 sec)

# utf8mb4_bin
mysql&gt; show full columns from test_k;
+-------+---------+-------------+------+-----+---------+-------+---------------------------------+---------+
| Field | Type    | Collation   | Null | Key | Default | Extra | Privileges                      | Comment |
+-------+---------+-------------+------+-----+---------+-------+---------------------------------+---------+
| name  | char(4) | utf8mb4_bin | YES  |     | NULL    |       | select,insert,update,references |         |
+-------+---------+-------------+------+-----+---------+-------+---------------------------------+---------+
1 row in set (0.00 sec)

# 手动修改某个字段的大小写敏感
alter table test3 modify name varchar(20) collate utf8_bin;
</code></pre>
<h3 id="25-sql_mode">2.5 sql_mode</h3>
<pre><code class="language-bash">mysql&gt; show variables like 'sql_mode';
+---------------+-----------------------------------------------------------------------------------------------------------------------+
| Variable_name | Value                                                                                                                 |
+---------------+-----------------------------------------------------------------------------------------------------------------------+
| sql_mode      | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |
+---------------+-----------------------------------------------------------------------------------------------------------------------+
1 row in set (0.02 sec)
</code></pre>
<table>
<thead>
<tr>
<th>mode</th>
<th>含义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ONLY_FULL_GROUP_BY</strong></td>
<td>对于GROUP BY聚合操作 如果在SELECT中的列 没有在GROUP BY中出现 那么将认为这个SQL是不合法的 因为列不在GROUP BY从句中</td>
<td>聚合操作相关</td>
</tr>
<tr>
<td><code>STRICT_TRANS_TABLES</code></td>
<td>在该模式下 如果一个值不能插入到一个事务表中 则中断当前的操作 对非事务表不做任何限制.简而言之, 就是遇到错误回滚, 保持原数据的完整.</td>
<td>插入数据控制</td>
</tr>
<tr>
<td><code>NO_ZERO_IN_DATE</code></td>
<td>在严格模式 不接受月或日部分为0的日期. 如果使用IGNORE选项 我们为类似的日期插入'0000-00-00'. 在非严格模式 可以接受该日期 但会生成警告.</td>
<td>日期相关</td>
</tr>
<tr>
<td><code>NO_ZERO_DATE</code></td>
<td>在严格模式 不要将 '0000-00-00'做为合法日期. 你仍然可以用IGNORE选项插入零日期. 在非严格模式 可以接受该日期 但会生成警告</td>
<td>日期相关</td>
</tr>
<tr>
<td><code>ERROR_FOR_DIVISION_BY_ZERO</code></td>
<td>在严格模式 在INSERT或UPDATE过程中 如果被零除(或MOD(X 0)) 则产生错误(否则为警告). 如果未给出该模式 被零除时MySQL返回NULL. 如果用到INSERT IGNORE或UPDATE IGNORE中 MySQL生成被零除警告 但操作结果为NULL.</td>
<td>插入内容检查</td>
</tr>
<tr>
<td><code>NO_AUTO_CREATE_USER</code></td>
<td>防止GRANT自动创建新用户 除非还指定了密码.</td>
<td>创建用户</td>
</tr>
<tr>
<td><code>NO_ENGINE_SUBSTITUTION</code></td>
<td>如果需要的存储引擎被禁用或未编译 那么抛出错误. 不设置此值时 用默认的存储引擎替代 并抛出一个异常.</td>
<td></td>
</tr>
<tr>
<td><code>pad_char_to_full_length</code></td>
<td>控制<code>char</code>类型字段对于尾部空格的处理(As of MySQL 8.0.13, <a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_pad_char_to_full_length"><code>PAD_CHAR_TO_FULL_LENGTH</code></a> is deprecated. Expect it to be removed in a future version of MySQL.)</td>
<td>字段设置</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html">参考连接-sql_mode</a></li>
</ul>
<h3 id="26-分区">2.6 分区</h3>
<blockquote>
<ul>
<li>分区字段必须是整数类型或解析为整数的表达式.</li>
<li>分区字段建议设置为<code>NOT NULL</code>, 若某行数据分区字段为<code>null</code>, 在<code>RANGE</code>分区中, 该行数据会划分到最小的分区里.</li>
<li><code>MySQL</code>分区中如果存在主键或唯一键, 则分区列必须包含在其中.</li>
<li><code>Innodb</code>分区表不支持外键.</li>
<li>更改<code>sql_mode</code>模式可能影响分区表的表现.</li>
<li>分区表不影响自增列.</li>
</ul>
</blockquote>
<p>分区的使用场景:</p>
<blockquote>
<p>这类表的特点是数据量大, 并且有冷热数据区分, 可以按照时间维度来进行数据归档. 这类表是比较适合使用分区表的, 因为分区表可以对单独的分区进行维护, 对于数据归档更方便</p>
</blockquote>
<p><code>分区</code>和<code>外键约束</code>从使用的角度来看(除非有足够的时间去测试性能, 使用等各种细节), 否则使用起来平添麻烦.</p>
<ul>
<li>替代性强, 如可以直接建立新的表即可.</li>
<li>增加维护的成本, 和其他的表形成差异(还需要考虑进一步的延申, 如数据规模, 数据整体查询, 集群等的影响).</li>
<li>自身的优势并不明显.</li>
</ul>
<p>分区表的主要分类</p>
<p><code>RANGE</code>分区: 基于属于一个给定连续区间的列值 把多行分配给分区.</p>
<p><code>LIST</code>分区: 类似于按<code>RANGE</code>分区 区别在于<code>LIST</code>分区是基于列值匹配一个离散值集合中的某个值来进行选择.</p>
<p><code>HASH</code>分区: 基于用户定义的表达式的返回值来进行选择的分区 该表达式使用将要插入到表中的这些行的列值进行计算. 这个函数可以包含<code>MySQL </code>中有效的 产生非负整数值的任何表达式.</p>
<p><code>KEY</code>分区: 类似于按<code>HASH</code>分区 区别在于<code>KEY</code>分区只支持计算一列或多列 且<code>MySQL</code>服务器提供其自身的哈希函数. 必须有一列或多列包含整数值.</p>
<p>复合分区: 在<code>MySQL 5.6</code>版本中 只支持<code>RANGE</code>和<code>LIST</code>的子分区 且子分区的类型只能为<code>HASH</code>和<code>KEY</code>.</p>
<pre><code class="language-mysql">create table test (id int, col varchar(16), c_year date)
	PARTITION BY RANGE( YEAR(c_year) )(
	PARTITION previous values less than (2000),
	PARTITION middle values less than (2010)
);

mysql&gt; desc test;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int         | YES  |     | NULL    |       |
| col    | varchar(16) | YES  |     | NULL    |       |
| c_year | date        | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

# 插入数据直接报错, 假如没有对应的数据分区
mysql&gt; insert into test values (1, 'a', '2011-01-02'), (2, 'b', '2022-11-04'), (3, 'c', '1991-1-2'), (4, 'd', '2004-01-1');
ERROR 1526 (HY000): Table has no partition for value 2011

# 变更为
create table test (id int, col varchar(16), c_year date)
	PARTITION BY RANGE( YEAR(c_year) )(
	PARTITION previous values less than (2000),
	PARTITION middle values less than (2010),
	PARTITION others values less than (2038)
);

mysql&gt; select * from test;
+------+------+------------+
| id   | col  | c_year     |
+------+------+------------+
|    3 | c    | 1991-01-02 |
|    4 | d    | 2004-01-01 |
|    1 | a    | 2011-01-02 |
|    2 | b    | 2022-11-04 |
+------+------+------------+
4 rows in set (0.00 sec)

mysql&gt; select PARTITION_NAME as &quot;分区&quot;,TABLE_ROWS as &quot;行数&quot; from information_schema.partitions where table_schema=&quot;test_db&quot; and table_name=&quot;test&quot;;
+----------+--------+
| 分区     | 行数   |
+----------+--------+
| middle   |      1 |
| others   |      2 |
| previous |      1 |
+----------+--------+
3 rows in set (0.00 sec)

# 显然这里会问 为什么不直接select * from table_middle;
# 而需要间接访问
mysql&gt; select * from test partition(middle);
+------+------+------------+
| id   | col  | c_year     |
+------+------+------------+
|    4 | d    | 2004-01-01 |
+------+------+------------+
1 row in set (0.00 sec)

# 新增分区
alter table test add partition (
    pARTITION hot_data VALUES LESS THAN (2024)
);

# 拆分分区
alter table test reorganize partition other into(
    pARTITION main_data VALUES LESS THAN (2020),
    pARTITION hot_data VALUES LESS THAN (2024)
);

# 将分区合并到新的分区
alter table test reorganize partition previous, middle into
	partition old_data values less than (2010)
);

# 清空分区
alter table test truncate partition middle;

# 删除分区
alter table test drop partition middle;
</code></pre>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Qpedo-OSnPdg81ussyp-vg">MySql分区 分表和分库 知识扫盲 </a></li>
</ul>
<h3 id="27-临时表衍生表">2.7 临时表/衍生表</h3>
<pre><code class="language-bash"># 通常情况下
select * from (select * from table) as t1 where t1.id = 1;
# 为了区分开来, 称t1作衍生表/派生表
</code></pre>
<p><code> (select * from table) as t1</code> 习惯可能会将<code>t1</code>称作临时表.</p>
<p>但实际上<code>MySQL</code>有专门的临时表<code>TEMPORARY</code>.</p>
<p>用于作为诸如数据分析, 可能需要反复对特定的数据(在这期间不担心源数据发生改变)进行查询, 或者是其他的操作. 临时表相当于将数据缓存起来, 方便反复调用数据.</p>
<p><em>注意: 临时表的数据并不会随着源数据发生改变而改变.</em></p>
<pre><code class="language-bash">mysql&gt; CREATE TEMPORARY TABLE top10customers
    -&gt; SELECT p.customerNumber,
    -&gt;        c.customerName,
    -&gt;        ROUND(SUM(p.amount),2) sales
    -&gt; FROM payments p
R JOIN cust    -&gt; INNER JOIN customers c ON c.customerNumber = p.customerNumber
Y p.cus    -&gt; GROUP BY p.customerNumber
    -&gt; ORDER BY sales DESC
    -&gt; LIMIT 10;
Query OK, 10 rows affected (0.00 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql&gt; select * from top10customers;
+----------------+------------------------------+-----------+
| customerNumber | customerName                 | sales     |
+----------------+------------------------------+-----------+
|            141 | Euro+ Shopping Channel       | 715738.98 |
|            124 | Mini Gifts Distributors Ltd. | 584188.24 |
|            114 | Australian Collectors, Co.   | 180585.07 |
|            151 | Muscle Machine Inc           | 177913.95 |
|            148 | Dragon Souveniers, Ltd.      | 156251.03 |
|            323 | Down Under Souveniers, Inc   | 154622.08 |
|            187 | AV Stores, Co.               | 148410.09 |
|            276 | Anna's Decorations, Ltd      | 137034.22 |
|            321 | Corporate Gift Ideas Co.     | 132340.78 |
|            146 | Saveley &amp; Henriot, Co.       | 130305.35 |
+----------------+------------------------------+-----------+
10 rows in set (0.00 sec)

# 删除掉某个临时表
drop TEMPORARY TABLE temp_table_name;
</code></pre>
<h3 id="28-衍生列">2.8 衍生列</h3>
<p><code>generated column</code>, 衍生列, 可以根据条件(建立表时设置的条件)自动生成/更新数据.</p>
<pre><code class="language-mysql">mysql&gt; create table test1(
    -&gt; col1 int primary key,
    -&gt; col2 int generated always as (col1+7) stored
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; desc test1;
+-------+---------+------+-----+---------+------------------+
| Field | Type    | Null | Key | Default | Extra            |
+-------+---------+------+-----+---------+------------------+
| col1  | int(11) | NO   | PRI | NULL    |                  |
| col2  | int(11) | YES  |     | NULL    | STORED GENERATED |
+-------+---------+------+-----+---------+------------------+
2 rows in set (0.00 sec)

mysql&gt; insert into test1(col1) values (1);
Query OK, 1 row affected (0.01 sec)

mysql&gt; select * from test1;
+------+------+
| col1 | col2 |
+------+------+
|    1 |    8 |
+------+------+
1 row in set (0.00 sec)
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://p0.meituan.net/dpplatform/ddc7f037901b5585be9a5649bd4cedf457766.png" alt="generated column" loading="lazy"></figure>
<h3 id="29-用户管理">2.9 用户管理</h3>
<pre><code class="language-mysql"># 查看当前用户
mysql&gt; select user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+

# wsl, 中MySQL预置的用户
mysql&gt; select user from user;
+------------------+
| user             |
+------------------+
| debian-sys-maint |
| mysql.infoschema |
| mysql.session    |
| mysql.sys        |
| root             |
+------------------+
5 rows in set (0.00 sec)
</code></pre>
<h4 id="291-291安全验证方式">2.9.1 2.9.1安全验证方式</h4>
<figure data-type="image" tabindex="11"><img src="https://img2020.cnblogs.com/blog/754297/202006/754297-20200628100744915-1857947543.png" alt="754297-20200628100744915-1857947543.png" loading="lazy"></figure>
<pre><code class="language-bash">mysql&gt; select user,host,plugin from mysql.user;
+------------------+-----------+-----------------------+
| user             | host      | plugin                |
+------------------+-----------+-----------------------+
| debian-sys-maint | localhost | caching_sha2_password |
| mysql.infoschema | localhost | caching_sha2_password |
| mysql.session    | localhost | caching_sha2_password |
| mysql.sys        | localhost | caching_sha2_password |
| root             | localhost | mysql_native_password |
| test_user        | localhost | caching_sha2_password |
+------------------+-----------+-----------------------+
6 rows in set (0.00 sec)

# wsl中刚装好的mysql
mysql&gt; select user,host,plugin from mysql.user;
+------------------+-----------+-----------------------+
| user             | host      | plugin                |
+------------------+-----------+-----------------------+
| debian-sys-maint | localhost | caching_sha2_password |
| mysql.infoschema | localhost | caching_sha2_password |
| mysql.session    | localhost | caching_sha2_password |
| mysql.sys        | localhost | caching_sha2_password |
| root             | localhost | auth_socket           |
+------------------+-----------+-----------------------+
5 rows in set (0.00 sec)
</code></pre>
<ul>
<li><code>caching_sha2_password</code>, 是<code>MySQL8.x</code>默认的身份验证方式, 兼容5.x的验证方式.</li>
<li><code>mysql_native_password</code>, 是<code>MySQL5.x</code>默认的身份验证方式, 不支持8.x的验证方式.</li>
</ul>
<pre><code class="language-mysql">-- 默认
create user test_user@localhost identified by '789';

# 5.x, mysql_native_password
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';
</code></pre>
<pre><code class="language-bash"># 强制变更配置验证方式
[mysqld]
default-authentication-plugin=sha256_password
</code></pre>
<pre><code class="language-bash"># 临时选择方式
mysql&gt; CREATE USER 'sha256user'@'localhost' IDENTIFIED WITH sha256_password BY 'password';
Query OK, 0 rows affected (0.01 sec)

mysql&gt; select user,host,plugin from mysql.user;
+------------------+-----------+-----------------------+
| user             | host      | plugin                |
+------------------+-----------+-----------------------+
| debian-sys-maint | localhost | caching_sha2_password |
| mysql.infoschema | localhost | caching_sha2_password |
| mysql.session    | localhost | caching_sha2_password |
| mysql.sys        | localhost | caching_sha2_password |
| root             | localhost | mysql_native_password |
| sha256user       | localhost | sha256_password       |
| test_user        | localhost | caching_sha2_password |
+------------------+-----------+-----------------------+
7 rows in set (0.00 sec)

mysql&gt; CREATE USER 'cache_user'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'password';
Query OK, 0 rows affected (0.01 sec)

mysql&gt; select user,host,plugin from mysql.user;
+------------------+-----------+-----------------------+
| user             | host      | plugin                |
+------------------+-----------+-----------------------+
| cache_user       | localhost | caching_sha2_password |
| debian-sys-maint | localhost | caching_sha2_password |
| mysql.infoschema | localhost | caching_sha2_password |
| mysql.session    | localhost | caching_sha2_password |
| mysql.sys        | localhost | caching_sha2_password |
| root             | localhost | mysql_native_password |
| sha256user       | localhost | sha256_password       |
| test_user        | localhost | caching_sha2_password |
+------------------+-----------+-----------------------+
8 rows in set (0.00 sec)

# 变更安全的验证方式
ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY '123456';
# 必须加上 with caching_sha2_password具体的方式
</code></pre>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/authentication-plugins.html">MySQL :: MySQL 8.0 Reference Manual :: 6.4.1 Authentication Plugins</a></li>
<li><a href="https://www.cnblogs.com/olinux/p/13201497.html">MySQL新密码机制介绍caching_sha2_password - 懒睡的猫熊 - 博客园 (cnblogs.com)</a></li>
</ul>
<h4 id="292-292权限">2.9.2 2.9.2权限</h4>
<p>默认状态下的<code>root</code>权限:</p>
<table>
<thead>
<tr>
<th>Host</th>
<th>localhost</th>
</tr>
</thead>
<tbody>
<tr>
<td>User</td>
<td>root</td>
</tr>
<tr>
<td>Select_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Insert_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Update_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Delete_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Create_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Drop_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Reload_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Shutdown_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Process_priv</td>
<td>Y</td>
</tr>
<tr>
<td>File_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Grant_priv</td>
<td>Y</td>
</tr>
<tr>
<td>References_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Index_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Alter_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Show_db_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Super_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Create_tmp_table_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Lock_tables_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Execute_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Repl_slave_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Repl_client_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Create_view_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Show_view_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Create_routine_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Alter_routine_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Create_user_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Event_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Trigger_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Create_tablespace_priv</td>
<td>Y</td>
</tr>
<tr>
<td>ssl_type</td>
<td></td>
</tr>
<tr>
<td>ssl_cipher</td>
<td></td>
</tr>
<tr>
<td>x509_issuer</td>
<td></td>
</tr>
<tr>
<td>x509_subject</td>
<td></td>
</tr>
<tr>
<td>max_questions</td>
<td>0</td>
</tr>
<tr>
<td>max_updates</td>
<td>0</td>
</tr>
<tr>
<td>max_connections</td>
<td>0</td>
</tr>
<tr>
<td>max_user_connections</td>
<td>0</td>
</tr>
<tr>
<td>plugin</td>
<td>mysql_native_password</td>
</tr>
<tr>
<td>authentication_string</td>
<td>*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</td>
</tr>
<tr>
<td>password_expired</td>
<td>N</td>
</tr>
<tr>
<td>password_last_changed</td>
<td>########</td>
</tr>
<tr>
<td>password_lifetime</td>
<td></td>
</tr>
<tr>
<td>account_locked</td>
<td>N</td>
</tr>
<tr>
<td>Create_role_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Drop_role_priv</td>
<td>Y</td>
</tr>
<tr>
<td>Password_reuse_history</td>
<td></td>
</tr>
<tr>
<td>Password_reuse_time</td>
<td></td>
</tr>
<tr>
<td>Password_require_current</td>
<td></td>
</tr>
<tr>
<td>User_attributes</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-bash"># 获取当前的用户权限.
mysql&gt; show grants \G
*************************** 1. row ***************************
Grants for root@localhost: GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `root`@`localhost` WITH GRANT OPTION
*************************** 2. row ***************************
Grants for root@localhost: GRANT APPLICATION_PASSWORD_ADMIN,AUDIT_ABORT_EXEMPT,AUDIT_ADMIN,AUTHENTICATION_POLICY_ADMIN,BACKUP_ADMIN,BINLOG_ADMIN,BINLOG_ENCRYPTION_ADMIN,CLONE_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,FIREWALL_EXEMPT,FLUSH_OPTIMIZER_COSTS,FLUSH_STATUS,FLUSH_TABLES,FLUSH_USER_RESOURCES,GROUP_REPLICATION_ADMIN,GROUP_REPLICATION_STREAM,INNODB_REDO_LOG_ARCHIVE,INNODB_REDO_LOG_ENABLE,PASSWORDLESS_USER_ADMIN,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_APPLIER,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SENSITIVE_VARIABLES_OBSERVER,SERVICE_CONNECTION_ADMIN,SESSION_VARIABLES_ADMIN,SET_USER_ID,SHOW_ROUTINE,SYSTEM_USER,SYSTEM_VARIABLES_ADMIN,TABLE_ENCRYPTION_ADMIN,XA_RECOVER_ADMIN ON *.*
TO `root`@`localhost` WITH GRANT OPTION
*************************** 3. row ***************************
Grants for root@localhost: GRANT PROXY ON ``@`` TO `root`@`localhost` WITH GRANT OPTION
3 rows in set (0.00 sec)
</code></pre>
<pre><code class="language-bash"># 查看支持的权限
mysql&gt; show privileges;
+------------------------------+---------------------------------------+-------------------------------------------------------+
| Privilege                    | Context                               | Comment                                               |
+------------------------------+---------------------------------------+-------------------------------------------------------+
| Alter(修改表(结构))                        | Tables                                | To alter the table                                    |
| Alter routine(修改或者删除函数/存储过程)                | Functions,Procedures                  | To alter or drop stored functions/procedures          |
| Create(数据库, 表, 索引)                       | Databases,Tables,Indexes              | To create new databases and tables                    |
| Create routine(函数/存储过程)               | Databases                             | To use CREATE FUNCTION/PROCEDURE                      |
| Create role(创建角色)                  | Server Admin                          | To create new roles                                   |
| Create temporary tables(创建临时表)      | Databases                             | To use CREATE TEMPORARY TABLE                         |
| Create view(创建视图)                  | Tables                                | To create new views                                   |
| Create user(创建用户)                  | Server Admin                          | To create new users                                   |
| Delete(删除表行)                       | Tables                                | To delete existing rows                               |
| Drop(删除数据库, 表)                         | Databases,Tables                      | To drop databases, tables, and views                  |
| Drop role(删除角色)                    | Server Admin                          | To drop roles                                         |
| Event(删除或者创建时间)                        | Server Admin                          | To create, alter, drop and execute events             |
| Execute(执行函数或者存储过程)                      | Functions,Procedures                  | To execute stored routines                            |
| File(读取或者写入文件)                         | File access on server                 | To read and write files on the server                 |
| Grant option(批准权限给其他的用户)                 | Databases,Tables,Functions,Procedures | To give to other users those privileges you possess   |
| Index(创建或者删除索引)                        | Tables                                | To create or drop indexes                             |
| Insert(插入数据)                       | Tables                                | To insert data into tables                            |
| Lock tables(锁定表格)                  | Databases                             | To use LOCK TABLES (together with SELECT privilege)   |
| Process                      | Server Admin                          | To view the plain text of currently executing queries |
| Proxy(代理相关)                        | Server Admin                          | To make proxy user possible                           |
| References                   | Databases,Tables                      | To have references on tables                          |
| Reload(重载/刷新表, 日志/权限)                       | Server Admin                          | To reload or refresh tables, logs and privileges      |
| Replication client(主从相关)           | Server Admin                          | To ask where the slave or master servers are          |
| Replication slave            | Server Admin                          | To read binary log events from the master             |
| Select(查询)                       | Tables                                | To retrieve rows from table                           |
| Show databases(查看数据库)               | Server Admin                          | To see all databases with SHOW DATABASES              |
| Show view(查看视图)                    | Tables                                | To see views with SHOW CREATE VIEW                    |
| Shutdown(关闭服务器)                     | Server Admin                          | To shut down the server                               |
| Super(超级权限, 例如关闭线程)                        | Server Admin                          | To use KILL thread, SET GLOBAL, CHANGE MASTER, etc.   |
| Trigger(使用触发器)                      | Tables                                | To use triggers                                       |
| Create tablespace(创建/删除/修改表空间)            | Server Admin                          | To create/alter/drop tablespaces                      |
| Update(更新表行)                       | Tables                                | To update existing rows                               |
| Usage(基础权限, 仅限于连接)                       | Server Admin                          | No privileges - allow connect only                    |
| FIREWALL_EXEMPT              | Server Admin                          |                                                       |
| AUDIT_ABORT_EXEMPT           | Server Admin                          |                                                       |
| XA_RECOVER_ADMIN             | Server Admin                          |                                                       |
| TABLE_ENCRYPTION_ADMIN       | Server Admin                          |                                                       |
| SYSTEM_VARIABLES_ADMIN       | Server Admin                          |                                                       |
| FLUSH_STATUS                 | Server Admin                          |                                                       |
| CONNECTION_ADMIN             | Server Admin                          |                                                       |
| ENCRYPTION_KEY_ADMIN         | Server Admin                          |                                                       |
| INNODB_REDO_LOG_ARCHIVE      | Server Admin                          |                                                       |
| CLONE_ADMIN                  | Server Admin                          |                                                       |
| BINLOG_ENCRYPTION_ADMIN      | Server Admin                          |                                                       |
| FLUSH_TABLES                 | Server Admin                          |                                                       |
| BACKUP_ADMIN                 | Server Admin                          |                                                       |
| AUTHENTICATION_POLICY_ADMIN  | Server Admin                          |                                                       |
| REPLICATION_APPLIER          | Server Admin                          |                                                       |
| GROUP_REPLICATION_STREAM     | Server Admin                          |                                                       |
| REPLICATION_SLAVE_ADMIN      | Server Admin                          |                                                       |
| FLUSH_OPTIMIZER_COSTS        | Server Admin                          |                                                       |
| SESSION_VARIABLES_ADMIN      | Server Admin                          |                                                       |
| APPLICATION_PASSWORD_ADMIN   | Server Admin                          |                                                       |
| SYSTEM_USER                  | Server Admin                          |                                                       |
| RESOURCE_GROUP_ADMIN         | Server Admin                          |                                                       |
| AUDIT_ADMIN                  | Server Admin                          |                                                       |
| FLUSH_USER_RESOURCES         | Server Admin                          |                                                       |
| GROUP_REPLICATION_ADMIN      | Server Admin                          |                                                       |
| INNODB_REDO_LOG_ENABLE       | Server Admin                          |                                                       |
| PASSWORDLESS_USER_ADMIN      | Server Admin                          |                                                       |
| ROLE_ADMIN                   | Server Admin                          |                                                       |
| BINLOG_ADMIN                 | Server Admin                          |                                                       |
| PERSIST_RO_VARIABLES_ADMIN   | Server Admin                          |                                                       |
| RESOURCE_GROUP_USER          | Server Admin                          |                                                       |
| SENSITIVE_VARIABLES_OBSERVER | Server Admin                          |                                                       |
| SERVICE_CONNECTION_ADMIN     | Server Admin                          |                                                       |
| SHOW_ROUTINE                 | Server Admin                          |                                                       |
| SET_USER_ID                  | Server Admin                          |                                                       |
+------------------------------+---------------------------------------+-------------------------------------------------------+
68 rows in set (0.00 sec)
</code></pre>
<p>由于权限非常多, 主要看非<code>Server Admin</code> 级别的权限.</p>
<h4 id="293-293用户管理">2.9.3 2.9.3用户管理</h4>
<p>用户名的完整构成:</p>
<pre><code class="language-bash">'test_user'@'%'
# 用户名 @ ip地址(%, 表示全部)
</code></pre>
<pre><code class="language-bash">mysql&gt; create user test_user@localhost identified by '789';
Query OK, 0 rows affected (0.02 sec)

mysql&gt; select user from mysql.user;
+------------------+
| user             |
+------------------+
| debian-sys-maint |
| mysql.infoschema |
| mysql.session    |
| mysql.sys        |
| root             |
| test_user        |
+------------------+
6 rows in set (0.00 sec)

# 默认创建, 只有连接登录MySQL的权限
mysql&gt; SHOW GRANTS FOR 'test_user'@'localhost';
+-----------------------------------------------+
| Grants for test_user@localhost                |
+-----------------------------------------------+
| GRANT USAGE ON *.* TO `test_user`@`localhost` |
+-----------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
<pre><code class="language-mysql"># 查看具体的用户权限
select * from mysql.user where user='test_db_user';
or
mysql&gt; show grants for 'sha256user'@'localhost';
+---------------------------------------------------------------------------------------------------------+
| Grants for sha256user@localhost                                                                         |
+---------------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `sha256user`@`localhost`                                                          |
| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, EXECUTE ON `test_db`.* TO `sha256user`@`localhost` |
+---------------------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
# 刷新权限
FLUSH PRIVILEGES;
</code></pre>
<p>由于权限选项较多, 在<code>sql</code>语句中并不好管理和设置.</p>
<figure data-type="image" tabindex="12"><a href="https://imgse.com/i/pSw8uDK"><img src="https://s1.ax1x.com/2023/01/30/pSw8uDK.png" alt="pSw8uDK.png" loading="lazy"></a></figure>
<p><code>navicat</code>提供更为直观的图形界面设置</p>
<p>上述设置:</p>
<ol>
<li>创建一个只针对数据库<code>test_db</code>的用户</li>
<li>允许这个用户可以在test_db中进行任意的操作</li>
<li>不允许访问其他的数据库.</li>
</ol>
<figure data-type="image" tabindex="13"><a href="https://imgse.com/i/pSw8nu6"><img src="https://s1.ax1x.com/2023/01/30/pSw8nu6.png" alt="pSw8nu6.png" loading="lazy"></a></figure>
<p>同步自动生成<code>sql</code>语句.</p>
<pre><code class="language-bash"># 在test_db用户之下, 能够查看的数据库
mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| performance_schema |
| test_db            |
+--------------------+
3 rows in set (0.00 sec)

# 创建数据库
mysql&gt; create database test_db_a;
ERROR 1044 (42000): Access denied for user 'test_db_user'@'localhost' to database 'test_db_a'
</code></pre>
<pre><code class="language-bash"># 删除用户
mysql&gt; DROP USER IF EXISTS test_user;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; show warnings;
+-------+------+--------------------------------------------------+
| Level | Code | Message                                          |
+-------+------+--------------------------------------------------+
| Note  | 3162 | Authorization ID 'test_user'@'%' does not exist. |
+-------+------+--------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; DROP USER IF EXISTS test_user@localhost;
Query OK, 0 rows affected (0.01 sec)
</code></pre>
<ul>
<li>
<p>赋予权限</p>
<pre><code class="language-bash"># 赋予root的权限
grant all privileges on *.* to 'alex'@'localhost';

# 在wsl/linux下, 将直接以用户名进行登录
(base) alex@DESKTOP-F6VO5U4:/mnt/c/Users/Lian$ mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 18
Server version: 8.0.31-0ubuntu0.20.04.2 (Ubuntu)

Copyright (c) 2000, 2022, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt;

#全局权限
GRANT super,select on *.* to 'sha256user'@'localhost';

#库权限
GRANT select,insert,update,delete,create,alter,execute on `test_db`.* to 'sha256user'@'localhost';

#表权限
GRANT select,insert on `testdb`.test_table to 'sha256user'@'localhost';

#列权限
GRANT select (col1), insert (col1, col2) ON `test_db`.test_table to 'sha256user'@'localhost';
</code></pre>
</li>
<li>
<p>撤销权限</p>
<pre><code class="language-bash"># 撤销部分的权限
REVOKE
    priv_type [(column_list)]
      [, priv_type [(column_list)]] ...
    ON [object_type] priv_level
    FROM user [, user] ...

# 撤销全部的
REVOKE ALL [PRIVILEGES], GRANT OPTION
    FROM user [, user] ...
</code></pre>
<pre><code class="language-bash">mysql&gt; show grants for 'sha256user'@'localhost';
+---------------------------------------------------------------------------------------------------------+
| Grants for sha256user@localhost                                                                         |
+---------------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `sha256user`@`localhost`                                                          |
| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, EXECUTE ON `test_db`.* TO `sha256user`@`localhost` |
+---------------------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)

# 撤销掉 select 权限从数据库test_db
mysql&gt; revoke select on `test_db`.* from 'sha256user'@'localhost';
Query OK, 0 rows affected (0.01 sec)

mysql&gt; show grants for 'sha256user'@'localhost';
+-------------------------------------------------------------------------------------------------+
| Grants for sha256user@localhost                                                                 |
+-------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `sha256user`@`localhost`                                                  |
| GRANT INSERT, UPDATE, DELETE, CREATE, ALTER, EXECUTE ON `test_db`.* TO `sha256user`@`localhost` |
+-------------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
</code></pre>
</li>
</ul>
<h3 id="210-查询缓存">2.10 查询缓存</h3>
<p>从各种资料来看, 查询缓存已经名存实亡.</p>
<blockquote>
<p><em>Although MySQL Query Cache was meant to improve performance, it has serious scalability issues and it can easily become a severe bottleneck</em></p>
</blockquote>
<pre><code class="language-bash">mysql&gt; show variables like '%query_cache%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | NO    |
+------------------+-------+
1 row in set (0.00 sec)
</code></pre>
<ul>
<li><a href="https://blog.csdn.net/LiushaoMr/article/details/107879835">译文-MySQL开发团队的文章 MySQL 8.0: 不再支持查询缓存</a></li>
<li><a href="https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/">MySQL 8.0: Retiring Support for the Query Cache</a></li>
</ul>
<h3 id="211-视图">2.11 视图</h3>
<blockquote>
<p>MySQL supports views, including updatable views. Views are stored queries that when invoked produce a result set. A view acts as a virtual table.</p>
<p>虚拟表的角色</p>
</blockquote>
<p>视图的一个明显的好处在于控制数据的可访问范围, 将这种控制精确到每个细节, 如字段.</p>
<pre><code class="language-mysql">mysql&gt; create view test_j_v as select * from test_j limit 100;
Query OK, 0 rows affected (0.02 sec)

# 视图也出现表中
mysql&gt; show tables;
+-------------------+
| Tables_in_test_db |
+-------------------+
| sales             |
| t1                |
| t2                |
| test              |
| test_a            |
| test_b            |
| test_d            |
| test_e            |
| test_f            |
| test_g            |
| test_h            |
| test_i            |
| test_j            | #
| test_j_v          | # 创建的基于test_j的视图
| test_k            |
| test_table        |
| user_trade        |
+-------------------+
17 rows in set (0.00 sec)

# 和表一样, 查看结构
# 但是需要注意原表有索引, 在视图上是没有这个的
mysql&gt; desc test_j_v;
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| id      | int      | YES  |     | NULL    |       |
| name    | char(4)  | YES  |     | NULL    |       |
| address | char(64) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)

# 查看创建的语句
mysql&gt; show create view test_j_v;
+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
| View     | Create View
                                                                                                      | character_set_client | collation_connection |
+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
| test_j_v | CREATE ALGORITHM=UNDEFINED DEFINER=`alex`@`localhost` SQL SECURITY DEFINER VIEW `test_j_v` AS select `test_j`.`id` AS `id`,`test_j`.`name` AS `name`,`test_j`.`address` AS `address` from `test_j` limit 100 | utf8mb4
         | utf8mb4_0900_ai_ci   |
+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
1 row in set (0.00 sec)

mysql&gt; select * from test_j_v limit 1;
+------+-----------+---------------------------------------------+
| id   | name      | address                                     |
+------+-----------+---------------------------------------------+
|  433 | 顾宇宁    | 中国北京市房山区岳琉路992号1室              |
+------+-----------+---------------------------------------------+
1 row in set (0.00 sec)

# 更新数据源表, 数据会自动更新到视图上
mysql&gt; update test_j set name = '顾先生' where id = '433';

mysql&gt; select * from test_j limit 1;
+------+-----------+---------------------------------------------+
| id   | name      | address                                     |
+------+-----------+---------------------------------------------+
|  433 | 顾先生    | 中国北京市房山区岳琉路992号1室              |
+------+-----------+---------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; select * from test_j_v limit 1;
+------+-----------+---------------------------------------------+
| id   | name      | address                                     |
+------+-----------+---------------------------------------------+
|  433 | 顾先生    | 中国北京市房山区岳琉路992号1室              |
+------+-----------+---------------------------------------------+
1 row in set (0.00 sec)

# 为源数据表增加索引
mysql&gt; create index index_id on test_j (id);
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings:
mysql&gt; desc test_j;
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| id      | int      | YES  | MUL | NULL    |       |
| name    | char(4)  | YES  |     | NULL    |       |
| address | char(64) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)

# 试图无索引
mysql&gt; desc test_j_v;
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| id      | int      | YES  |     | NULL    |       |
| name    | char(4)  | YES  |     | NULL    |       |
| address | char(64) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
3 rows in set (0.01 sec)

# 对视图进行更新操作的限制
# 假如视图是可允许更新的, 在视图上的操作会同步到源表中
mysql&gt; create view test_m_v as select * from test_m where id &lt; 100;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; delete from test_m_v where id = 3;
Query OK, 1 row affected (0.00 sec)

mysql&gt; create view test_m_v_a as select * from test_m limit 100;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; delete from test_m_v_a where id = 3;
ERROR 1288 (HY000): The target table test_m_v_a of the DELETE is not updatable

# 但是需要注意创建索引, 无法创建, 不是基础表
mysql&gt; create index j_v_index on test_j_v (name);
ERROR 1347 (HY000): 'test_db.test_j_v' is not BASE TABLE

# 删除操作针对视图
mysql&gt; delete from test_j_v where id =433;
ERROR 1288 (HY000): The target table test_j_v of the DELETE is not updatable

# 删除视图
drop view test_j_v;
</code></pre>
<blockquote>
<p>在MySQL中 视图不仅可查询 还可以更新. 这意味着您可以使用<a href="https://www.begtut.com/mysql/mysql-insert-statement.html">INSERT</a>或 <a href="https://www.begtut.com/mysql/mysql-update-data.html">UPDATE</a>语句通过可更新视图插入或更新基表的行. 此外 您可以使用<a href="https://www.begtut.com/mysql/mysql-delete-statement.html">DELETE</a>语句通过视图删除基础表的行.</p>
<p>但是 要创建可更新<a href="https://www.begtut.com/mysql/introduction-sql-views.html">视图</a> 定义<a href="https://www.begtut.com/mysql/introduction-sql-views.html">视图</a>的<a href="https://www.begtut.com/mysql/mysql-select-statement-query-data.html">SELECT语句</a>不得包含以下任何元素:</p>
<ul>
<li><a href="https://www.begtut.com/mysql/mysql-aggregate-functions.html">聚合函数</a>  如<a href="https://www.begtut.com/mysql/mysql-min.html">MIN</a> <a href="https://www.begtut.com/mysql/mysql-max-function.html">MAX</a> <a href="https://www.begtut.com/mysql/mysql-sum.html">SUM</a> <a href="https://www.begtut.com/mysql/mysql-avg.html">AVG</a>和 <a href="https://www.begtut.com/mysql/mysql-count.html">COUNT</a>.</li>
<li><a href="https://www.begtut.com/mysql/mysql-distinct.html">DISTINCT</a></li>
<li><a href="https://www.begtut.com/mysql/mysql-group-by.html">GROUP BY</a>子句.</li>
<li><a href="https://www.begtut.com/mysql/mysql-having.html">HAVING</a>子句.</li>
<li><a href="https://www.begtut.com/mysql/sql-union-mysql.html">UNION</a>或UNION ALL子句.</li>
<li><a href="https://www.begtut.com/mysql/mysql-left-join.html">左连接</a>或外连接.</li>
<li><a href="https://www.begtut.com/mysql/mysql-subquery.html">子查询 </a>中的<a href="https://www.begtut.com/mysql/mysql-select-statement-query-data.html">SELECT</a>子句或在引用表<a href="https://www.begtut.com/mysql/mysql-where.html">WHERE</a>语句出现在FROM子句中.</li>
<li>引用<code>FROM</code>子句中的不可更新视图</li>
<li>仅引用文字值</li>
<li>对基表的任何列的多次引用</li>
</ul>
</blockquote>
<h2 id="三-基本命令">三. 基本命令</h2>
<p>基本情况查询和管理.</p>
<pre><code class="language-mysql">-- 查看帮助
help
-- 查看具体的项的帮助
help show
-- ------------------------------------- 查看帮助文档
mysql&gt; help in;
Name: 'IN'
Description:
Syntax:
expr IN (value,...)

Returns 1 (true) if expr is equal to any of the values in the IN()
list, else returns 0 (false).

Type conversion takes place according to the rules described in
https://dev.mysql.com/doc/refman/8.0/en/type-conversion.html, applied
to all the arguments. If no type conversion is needed for the values in
the IN() list, they are all non-JSON constants of the same type, and
expr can be compared to each of them as a value of the same type
(possibly after type conversion), an optimization takes place. The
values the list are sorted and the search for expr is done using a
binary search, which makes the IN() operation very quick.

URL: https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html

Examples:
mysql&gt; SELECT 2 IN (0,3,5,7);
        -&gt; 0
mysql&gt; SELECT 'wefwf' IN ('wee','wefwf','weg');
        -&gt; 1
-- ---------------------------------------------------------------
-- dual, mysql中的虚拟表
SELECT VERSION() from DUAL;
-- 二者是等价的, 都是查看mysql版本
SELECT VERSION();

-- 查看所有的表
show tables;

-- 查看数据库中表的情况, 表的数据大小, 索引大小等
show table status from db_name;

-- 查看表的创建sql语句, 将包含engine等信息
show create table table_name;
# 注意, 返回的内容不支持中文内容显示?

# 查看所有的表行数
select count(*) from table_name;
-- count(*), 包含null的行也会计算进来, 有别于count(col_name)

desc table_name;
# 查看表字段
show columns from table_name;
# 更详细
show full columns from table_name;

# 查看数据库, 索引等存储大小情况
show table status from test_db;
</code></pre>
<pre><code class="language-mysql">-- 修改数据库登录密码
mysqladmin -uroot -pOld_pwd password new_pwd;

-- 查看用户的连接情况
show processlist;

# 强制杀死某个进程
kill process_id;

SELECT user, host, db, command FROM information_schema.processlist;

# 查看所有的用户
SELECT user FROM mysql.user;
# 查看当前用户
select user();
-- 等价
SELECT current_user();

# 查看用户的具体权限
select * from mysql.user where user=user_name \G

# 查看变量, 这里查找带有cache的变量
show variables like '%cache%';

# 查看主从
show slave status\G
</code></pre>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/show.html">show commands</a></li>
</ul>
<h2 id="四-四-日志">四. 四. 日志</h2>
<ul>
<li>重做日志(<code>redo log</code>)</li>
<li>回滚日志(<code>undo log</code>)</li>
<li>二进制日志(<code>binlog</code>)</li>
<li>错误日志(<code>errorlog</code>)</li>
<li>慢查询日志(<code>slow query log</code>)</li>
<li>一般查询日志(<code>general log</code>)</li>
<li>中继日志(<code>relay log</code>)</li>
</ul>
<figure data-type="image" tabindex="14"><a href="https://imgse.com/i/pSwezX4"><img src="https://s1.ax1x.com/2023/01/30/pSwezX4.png" alt="pSwezX4.png" loading="lazy"></a></figure>
<p><code>redo log</code>, <code>undo log</code>, <code>binlog</code>三大日志构成了<code>MySQL</code>保障数据在<code>完整性</code>, <code>容灾处理</code>, <code>安全</code>等方面核心部分.</p>
<p><em>注意: 并不是所有的引擎都会启用上述的日志.</em></p>
<pre><code class="language-mysql">-- 产看日志的情况
show master logs;
mysql&gt; show master logs;
+---------------+-----------+-----------+
| Log_name      | File_size | Encrypted |
+---------------+-----------+-----------+
| binlog.000001 | 140126119 | No        |
| binlog.000002 |       157 | No        |
| binlog.000003 |   6837022 | No        |
+---------------+-----------+-----------+
3 rows in set (0.00 sec)
-- 查看日志的具体内容
show binlog event in '{日志的名称}';
-- 删除日志, 全部执行
reset master;
-- 执行删除日志
purge binary logs to '{日志名称}';
-- 根据时间
purge binary logs before '2019-04-02 22:46:26';
-- 查看命令行的帮助
help purge binary logs;
</code></pre>
<pre><code class="language-bash">mysql&gt; show global variables like '%general_log%';
+------------------+------------------------------------+
| Variable_name    | Value                              |
+------------------+------------------------------------+
| general_log      | OFF                                |
| general_log_file | /var/lib/mysql/DESKTOP-F6VO5U4.log |
+------------------+------------------------------------+
2 rows in set (0.01 sec)

mysql&gt; SHOW  GLOBAL VARIABLES LIKE '%slow%';
+-----------------------------+-----------------------------------------+
| Variable_name               | Value                                   |
+-----------------------------+-----------------------------------------+
| log_slow_admin_statements   | OFF                                     |
| log_slow_extra              | OFF                                     |
| log_slow_replica_statements | OFF                                     |
| log_slow_slave_statements   | OFF                                     |
| slow_launch_time            | 2                                       |
| slow_query_log              | OFF                                     |
| slow_query_log_file         | /var/lib/mysql/DESKTOP-F6VO5U4-slow.log |
+-----------------------------+-----------------------------------------+
7 rows in set (0.00 sec)
</code></pre>
<pre><code class="language-bash">SHOW GLOBAL VARIABLES LIKE '%log%';
+------------------------------------------------+------------------------------------------------+
| Variable_name                                  | Value                                          |
+------------------------------------------------+------------------------------------------------+
| activate_all_roles_on_login                    | OFF                                            |
| back_log                                       | 151                                            |
| binlog_cache_size                              | 32768                                          |
| binlog_checksum                                | CRC32                                          |
| binlog_direct_non_transactional_updates        | OFF                                            |
| binlog_encryption                              | OFF                                            |
| binlog_error_action                            | ABORT_SERVER                                   |
| binlog_expire_logs_auto_purge                  | ON                                             |
| binlog_expire_logs_seconds                     | 2592000                                        |
| binlog_format                                  | ROW                                            |
| binlog_group_commit_sync_delay                 | 0                                              |
| binlog_group_commit_sync_no_delay_count        | 0                                              |
| binlog_gtid_simple_recovery                    | ON                                             |
| binlog_max_flush_queue_time                    | 0                                              |
| binlog_order_commits                           | ON                                             |
| binlog_rotate_encryption_master_key_at_startup | OFF                                            |
| binlog_row_event_max_size                      | 8192                                           |
| binlog_row_image                               | FULL                                           |
| binlog_row_metadata                            | MINIMAL                                        |
| binlog_row_value_options                       |                                                |
| binlog_rows_query_log_events                   | OFF                                            |
| binlog_stmt_cache_size                         | 32768                                          |
| binlog_transaction_compression                 | OFF                                            |
| binlog_transaction_compression_level_zstd      | 3                                              |
| binlog_transaction_dependency_history_size     | 25000                                          |
| binlog_transaction_dependency_tracking         | COMMIT_ORDER                                   |
| expire_logs_days                               | 0                                              |
| general_log                                    | OFF                                            |
| general_log_file                               | /var/lib/mysql/DESKTOP-F6VO5U4.log             |
| innodb_api_enable_binlog                       | OFF                                            |
| innodb_flush_log_at_timeout                    | 1                                              |
| innodb_flush_log_at_trx_commit                 | 1                                              |
| innodb_log_buffer_size                         | 16777216                                       |
| innodb_log_checksums                           | ON                                             |
| innodb_log_compressed_pages                    | ON                                             |
| innodb_log_file_size                           | 50331648                                       |
| innodb_log_files_in_group                      | 2                                              |
| innodb_log_group_home_dir                      | ./                                             |
| innodb_log_spin_cpu_abs_lwm                    | 80                                             |
| innodb_log_spin_cpu_pct_hwm                    | 50                                             |
| innodb_log_wait_for_flush_spin_hwm             | 400                                            |
| innodb_log_write_ahead_size                    | 8192                                           |
| innodb_log_writer_threads                      | ON                                             |
| innodb_max_undo_log_size                       | 1073741824                                     |
| innodb_online_alter_log_max_size               | 134217728                                      |
| innodb_print_ddl_logs                          | OFF                                            |
| innodb_redo_log_archive_dirs                   |                                                |
| innodb_redo_log_capacity                       | 104857600                                      |
| innodb_redo_log_encrypt                        | OFF                                            |
| innodb_undo_log_encrypt                        | OFF                                            |
| innodb_undo_log_truncate                       | ON                                             |
| log_bin                                        | ON                                             |
| log_bin_basename                               | /var/lib/mysql/binlog                          |
| log_bin_index                                  | /var/lib/mysql/binlog.index                    |
| log_bin_trust_function_creators                | OFF                                            |
| log_bin_use_v1_row_events                      | OFF                                            |
| log_error                                      | /var/log/mysql/error.log                       |
| log_error_services                             | log_filter_internal; log_sink_internal         |
| log_error_suppression_list                     |                                                |
| log_error_verbosity                            | 2                                              |
| log_output                                     | FILE                                           |
| log_queries_not_using_indexes                  | OFF                                            |
| log_raw                                        | OFF                                            |
| log_replica_updates                            | ON                                             |
| log_slave_updates                              | ON                                             |
| log_slow_admin_statements                      | OFF                                            |
| log_slow_extra                                 | OFF                                            |
| log_slow_replica_statements                    | OFF                                            |
| log_slow_slave_statements                      | OFF                                            |
| log_statements_unsafe_for_binlog               | ON                                             |
| log_throttle_queries_not_using_indexes         | 0                                              |
| log_timestamps                                 | UTC                                            |
| max_binlog_cache_size                          | 18446744073709547520                           |
| max_binlog_size                                | 104857600                                      |
| max_binlog_stmt_cache_size                     | 18446744073709547520                           |
| max_relay_log_size                             | 0                                              |
| relay_log                                      | DESKTOP-F6VO5U4-relay-bin                      |
| relay_log_basename                             | /var/lib/mysql/DESKTOP-F6VO5U4-relay-bin       |
| relay_log_index                                | /var/lib/mysql/DESKTOP-F6VO5U4-relay-bin.index |
| relay_log_info_file                            | relay-log.info                                 |
| relay_log_info_repository                      | TABLE                                          |
| relay_log_purge                                | ON                                             |
| relay_log_recovery                             | OFF                                            |
| relay_log_space_limit                          | 0                                              |
| slow_query_log                                 | OFF                                            |
| slow_query_log_file                            | /var/lib/mysql/DESKTOP-F6VO5U4-slow.log        |
| sql_log_off                                    | OFF                                            |
| sync_binlog                                    | 1                                              |
| sync_relay_log                                 | 10000                                          |
| sync_relay_log_info                            | 10000                                          |
| terminology_use_previous                       | NONE                                           |
+------------------------------------------------+------------------------------------------------+
91 rows in set (0.01 sec)
</code></pre>
<h3 id="41-重做日志redo-log">4.1 重做日志(redo log)</h3>
<p><em>注意: <code>redo log</code>属于<code>MySQL</code>存储引擎<code>InnoDB</code>的事务日志.</em></p>
<p>作用: 确保事务的<em>持久性</em>, <code>redo</code>日志记录事务执行后的状态 用来恢复未写入<code>data file</code>的已成功事务更新的数据. 防止在发生故障的时间点 尚有脏页未写入磁盘 在重启<code>MySQL</code>服务的时候 根据<code>redo log</code>进行重做 从而达到事务的持久性这一特性.</p>
<p>内容: 记录的是物理数据页面的修改的信息, 其<code>redo log</code>是顺序写入<code>redo log file</code>的物理文件中去的.</p>
<p>什么时候产生: 事务开始之后就产生<code>redo log</code>, <code>redo log</code>的落盘并不是随着事务的提交才写入的, 而是在事务的执行过程中 便已经开始写入<code>redo log</code>文件中. 重做日志是在事务开始之后逐步写入重做日志文件, 而不一定是事务提交才写入重做日志缓存 重做日志有一个缓存区<code>Innodb_log_buffer</code>, <code>Innodb_log_buffer</code>的默认大小为<code>8M</code>, <code>Innodb</code>存储引擎先将重做日志写入<code>innodb_log_buffef</code>中.</p>
<p><code>InnoDB</code> 提供了 <em>innodb_flush_log_at_trx_commit</em> 参数 它有三种可能取值: <a href="https://time.geekbang.org/column/article/76161">参考</a></p>
<pre><code class="language-bash">mysql&gt; show variables like 'innodb_flush_log_at_trx_commit';
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_flush_log_at_trx_commit | 1     |
+--------------------------------+-------+
1 row in set (0.00 sec)
</code></pre>
<ul>
<li>设置为 0 的时候 表示每次事务提交时都只是把 <code>redo log</code> 留在 <code>redo log buffer</code> 中 .</li>
<li>设置为 1 的时候 表示每次事务提交时都将 <code>redo log</code> 直接持久化到磁盘.</li>
<li>设置为 2 的时候 表示每次事务提交时都只是把 <code>redo log</code> 写到 <code>page cache</code>.</li>
</ul>
<p>什么时候释放: 当对应事务的脏页写入到磁盘之后, <code>redo log</code>的使命也就完成了, 重做日志占用的空间就可以重用( 被覆盖).</p>
<p>对应的物理文件: 默认情况下 对应的物理文件位于数据库的<code>data</code>目录下的<code>ib_logfile1&amp;ib_logfile2....</code>.</p>
<p>参数设置:</p>
<ul>
<li>
<p><code>innodb_log_group_home_dir </code>指定日志文件组所在的路径 默认<code>./ </code> 表示在数据库的数据目录.</p>
<pre><code class="language-bash">mysql&gt; show variables like 'innodb_log_group_home_dir';
+---------------------------+-------+
| Variable_name             | Value |
+---------------------------+-------+
| innodb_log_group_home_dir | ./    |
+---------------------------+-------+
1 row in set (0.00 sec)
</code></pre>
</li>
<li>
<p><code>innodb_log_files_in_group </code>指定重做日志文件组中文件的数量 默认 <code>2</code>.</p>
</li>
</ul>
<p>关于文件的大小和数量 由以下两个参数配置:</p>
<ul>
<li><code>innodb_log_file_size</code>, 重做日志文件的大小</li>
<li><code>innodb_mirrored_log_groups</code>, 指定了日志镜像文件组的数量 默认<code>1</code>.</li>
</ul>
<h3 id="42-回滚日志undo-log">4.2 回滚日志(undo log)</h3>
<p>作用: 保证数据的<strong>原子性</strong> 保存了事务发生之前的数据的一个版本 可以用于回滚 同时可以提供多版本并发( <code>MVCC</code>)控制下的读, 也即非锁定读</p>
<p>内容: 逻辑格式的日志 在执行<code>undo</code>的时候 仅仅是将数据从逻辑上恢复至事务之前的状态 而不是从物理页面上操作实现的 这一点是不同于<code>redo log</code>的.</p>
<p>什么时候产生: 事务开始之前 将当前是的版本生成<code>undo log, undo</code> 也会产生 <code>redo</code> 来保证<code>undo log</code>的可靠性.</p>
<p>什么时候释放: 当事务提交之后 <code>undo log</code>并不能立马被删除 而是放入待清理的链表 由purge线程判断是否由其他事务在使用<code>undo</code>段中表的上一个事务之前的版本信息 决定是否可以清理<code>undo log</code>的日志空间.</p>
<p>对应的物理文件: <code>MySQL5.6</code>之前 <code>undo</code>表空间位于共享表空间的回滚段中 共享表空间的默认的名称是<code>ibdata</code> 位于数据文件目录中. <code>MySQL5.6</code>之后 <code>undo</code>表空间可以配置成独立的文件 但是提前需要在配置文件中配置 完成数据库初始化后生效且不可改变undo log文件的个数. 如果初始化数据库之前没有进行相关配置 那么就无法配置成独立的表空间了.</p>
<p>关于<code>MySQL5.7</code>之后的独立<code>undo</code> 表空间配置参数如下:</p>
<ul>
<li><code>innodb_undo_directory = /data/undospace/</code> –undo独立表空间的存放目录 <code>innodb_undo_logs = 128</code> –回滚段为<code>128KB innodb_undo_tablespaces = 4</code> –指定有4个<code>undo log</code>文件, 如果<code>undo</code>使用的共享表空间 这个共享表空间中又不仅仅是存储了undo的信息 共享表空间的默认为与MySQL的数据目录下面 其属性由参数<code>innodb_data_file_path</code>配置.</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210518221445247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzk5NjE1,size_16,color_FFFFFF,t_70" alt="20210518221445247.png" loading="lazy"></figure>
<p>当执行事务的过程中遇到了崩溃, 一般会会经历如下几个阶段来进行恢复:</p>
<ul>
<li>分析阶段( <code>Analysis</code>) : 该阶段从 <code>undo log</code> 的最后一次检查点( <code>check point</code> 可理解为在这个点之前所有应该持久化的变动都已安全落盘) 开始扫描日志 找出所有没有 <code>End Record</code> ( 当事务的日志落盘 数据也落盘 则处于 <code>End Record</code>状态) 的事务 组成待恢复的事务集合( 一般包括 <code>Transaction Table</code> 和 <code>Dirty Page Table</code>) .</li>
<li>重做阶段( <code>Redo</code>) : 该阶段依据分析阶段中, 产生的待恢复的事务集合来重演历史( <code>Repeat History</code>)  找出所有包含 <code>Commit Record</code>( 事务的日志落盘, 但是数据没有落盘 则处于 <code>Commit Record</code> 状态)  的日志 将它们写入磁盘 写入完成后增加一条 End Record, 然后移除出待恢复事务集合.</li>
<li>回滚阶段( <code>Undo</code>) : 该阶段处理经过分析 重做阶段后剩余的恢复事务集合 此时剩下的都是需要回滚的事务( 被称为 Loser)  根据 <code>Undo Log</code> 中的信息回滚这些事务.</li>
</ul>
<h3 id="43-二进制日志binlog">4.3 二进制日志(binlog)</h3>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210518210627487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzk5NjE1,size_16,color_FFFFFF,t_70" alt="20210518210627487.png" loading="lazy"></figure>
<p>作用: 主要用于保障主从复制, <code>从库</code>利用<code>主库</code>上的<code>binlog</code>进行重播, 实现主从同步, 以及数据库的基于时间点的还原.</p>
<p>内容: 逻辑格式的日志 可以简单认为就是执行过的事务中的<code>sql</code>语句. 但又不完全是sql语句这么简单 而是包括了执行的<code>sql</code>语句( 增删改) 反向的信息 也就意味着<code>delete</code>对应着<code>delete</code>本身和其反向的<code>insert</code>; update对应着update执行前后的版本的信息; insert对应着delete和insert本身的信息. 在使用<code>mysqlbinlog</code>解析<code>binlog</code>之后一些都会真相大白. 因此可以基于<code>binlog</code>做到类似于<code>oracle</code>的闪回功能 其实都是依赖于<code>binlog</code>中的日志记录.</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/img_convert/394bc3d525ea9c754377311b3f51dab6.png" alt="394bc3d525ea9c754377311b3f51dab6.png" loading="lazy"></figure>
<p>图中的 <code>write</code>, 指的就是指把日志写入到文件系统的 page cache, 并没有把数据持久化到磁盘, 所以速度比较快.<br>
图中的<code> fsync</code>, 才是将数据持久化到磁盘的操作. 一般情况下 我们认为<code> fsync</code> 才占磁盘的 IOPS.<br>
<code>write</code> 和 <code>fsync</code> 的时机 是由参数 <em>sync_binlog</em> 控制的:</p>
<pre><code class="language-bash">mysql&gt; show variables like 'sync_binlog';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| sync_binlog   | 1     |
+---------------+-------+
1 row in set (0.00 sec)
</code></pre>
<ul>
<li><code>sync_binlog=0</code> 的时候 表示每次提交事务都只 <code>write</code> 不<code> fsync</code>;</li>
<li><code>sync_binlog=1</code> 的时候 表示每次提交事务都会执行 <code>fsync</code>;</li>
<li><code>sync_binlog=N(N&gt;1)</code> 的时候 表示每次提交事务都 <code>write</code> 但累积<code>N </code>个事务后才 <code>fsync</code>.</li>
</ul>
<p>什么时候产生:事务提交的时候 一次性将事务中的<code>sql</code>语句( 一个事务可能对应多个<code>sql</code>语句) 按照一定的格式记录到<code>binlog</code>中. 这里与<code>redo log</code>很明显的差异就是<code>redo log</code>并不一定是在事务提交的时候刷新到磁盘 <code>redo log</code>是在事务开始之后就开始逐步写入磁盘. 因此对于事务的提交 即便是较大的事务 提交(<code>commit</code>)都是很快的 但是在开启了<code>bin_log</code>的情况下 对于较大事务的提交 可能会变得比较慢一些. 这是因为<code>binlog</code>是在事务提交的时候一次性写入的造成的, 这些可以通过测试验证.</p>
<p>什么时候释放: <code>binlog</code>的默认是保持时间由参数<code>expire_logs_days</code>配置 也就是说对于非活动的日志文件 在生成时间超过<code>expire_logs_days</code>配置的天数之后 会被自动删除.</p>
<h3 id="44-错误日志errorlog">4.4 错误日志(errorlog)</h3>
<p><code>debug</code>类型日志</p>
<p>顾名思义, 错误日志记录着<code>mysqld</code>启动和停止,以及服务器在运行过程中发生的错误的相关信息. 在默认情况下 系统记录错误日志的功能是关闭的, 错误信息被输出到标准错误输出.</p>
<h3 id="45-慢查询日志slow-query-log">4.5 慢查询日志(slow query log)</h3>
<p><code>debug</code>类型日志</p>
<p>慢日志记录执行时间过长和没有使用索引的查询语句, 报错<code>select, update, delete</code>以及<code>insert</code>语句, 慢日志只会记录执行成功的语句.</p>
<h3 id="46-一般查询日志general-log">4.6 一般查询日志(general log)</h3>
<p><code>debug</code>类型日志.</p>
<p>记录了服务器接收到的每一个查询或是命令 无论这些查询或是命令是否正确甚至是否包含语法错误 general log 都会将其记录下来  记录的格式为<code>{Time  Id  Command Argument}</code>也正因为mysql服务器需要不断地记录日志 开启<code>General log</code>会产生不小的系统开销.  因此 <code>Mysql</code>默认是把<code>General log</code>关闭的.</p>
<h3 id="47-中继日志relay-log">4.7 中继日志(relay log)</h3>
<figure data-type="image" tabindex="18"><img src="https://pic4.zhimg.com/80/v2-8ea2854b14977cfb3a07cfcf753493af_720w.webp" alt="v2-8ea2854b14977cfb3a07cfcf753493af_720w1673922312320.jpg" loading="lazy"></figure>
<p>中继日志(<code>relay log</code>)只在主从服务器架构的从服务器上存在. 从服务器(<code>slave</code>)为了与主服务器(<code>Master</code>)保持一致, 要从主服务器读取二进制日志的内容, 并且把读取到的信息写入本地的日志文件中, 这个从服务器本地的日志文件就叫中继日志. 然后, 从服务器读取中继日志, 并根据中继日志的内容对从服务器的数据进行更新, 完成主从服务器的数据同步.</p>
<ul>
<li><a href="https://blog.csdn.net/qq_42799615/article/details/115982904">还在纠缠MySQL的redo log, binlog, undo log 这几个日志间的关系吗? 一文梳理 轻轻松松搞懂! </a></li>
<li><a href="https://www.cnblogs.com/myseries/p/10728533.html">MySQL中的几种日志了解 </a></li>
</ul>
<h2 id="五-引擎">五. 引擎</h2>
<p><em>引擎是一个容易被忽略的关键点, 大量关于<code>事务, mvcc, 锁</code>的诸般介绍文章, 大多没提及是在什么引擎之下的.</em></p>
<figure data-type="image" tabindex="19"><a href="https://imgse.com/i/pSwmYjg"><img src="https://s1.ax1x.com/2023/01/30/pSwmYjg.png" alt="pSwmYjg.png" loading="lazy"></a></figure>
<p><a href="https://www.begtut.com/wp-content/uploads/2019/08/MySQL-Storage-Engines-Feature-Summary.pdf">图源</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">官方文档</a></p>
<pre><code class="language-mysql"># 查看所有的引擎
show engines;

show engines \G
# 查看引擎的详情
show engine innodb status\G

mysqld --default-storage-engine=MyISAM
-- 修改表的引擎
ALTER TABLE table_name ENGINE = engine_name;
-- 创建表时, 指定引擎
create table test(
    id int primary key
) engine = MyISAM;
</code></pre>
<table>
<thead>
<tr>
<th>Engine</th>
<th>Support</th>
<th>Comment</th>
<th>Transactions</th>
<th>XA</th>
<th>Savepoints</th>
</tr>
</thead>
<tbody>
<tr>
<td>MEMORY</td>
<td>YES</td>
<td>Hash based, stored in memory, useful for temporary tables</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>MRG_MYISAM</td>
<td>YES</td>
<td>Collection of identical MyISAM tables</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>CSV</td>
<td>YES</td>
<td>CSV storage engine</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>FEDERATED</td>
<td>NO</td>
<td>Federated MySQL storage engine</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>PERFORMANCE_SCHEMA</td>
<td>YES</td>
<td>Performance Schema</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>MyISAM</td>
<td>YES</td>
<td>MyISAM storage engine</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td><strong>InnoDB</strong></td>
<td><strong>DEFAULT</strong></td>
<td>Supports transactions, row-level locking, and foreign keys</td>
<td><strong>YES</strong></td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>YES</td>
<td>/dev/null storage engine (anything you write to it disappears)</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>ARCHIVE</td>
<td>YES</td>
<td>Archive storage engine</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdn.net/20180825204504669?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYWdhbDg5MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="engine" loading="lazy"></figure>
<p>几个主要的引擎之间的差异, 注意只有<code>InnoDB</code>引擎<strong>支持</strong><code>事务</code>, <code>行级锁</code>, 和<code>外键</code>.</p>
<h2 id="六-事务">六. 事务</h2>
<pre><code class="language-mysql">select @@transaction_isolation;
-- 查看事务的隔离等级
show variables like 'transaction_isolation';

-- 查看正在运行的事务
select * from information_schema.innodb_trx;
</code></pre>
<pre><code class="language-bash">mysql&gt; select * from information_schema.innodb_trx;
+-----------------+-----------+---------------------+-----------------------+------------------+------------+---------------------+---------------------------------------------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+---------------------+
| trx_id          | trx_state | trx_started         | trx_requested_lock_id | trx_wait_started | trx_weight | trx_mysql_thread_id | trx_query                                   | trx_operation_state | trx_tables_in_use | trx_tables_locked | trx_lock_structs | trx_lock_memory_bytes | trx_rows_locked | trx_rows_modified | trx_concurrency_tickets | trx_isolation_level | trx_unique_checks | trx_foreign_key_checks | trx_last_foreign_key_error | trx_adaptive_hash_latched | trx_adaptive_hash_timeout | trx_is_read_only | trx_autocommit_non_locking | trx_schedule_weight |
+-----------------+-----------+---------------------+-----------------------+------------------+------------+---------------------+---------------------------------------------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+---------------------+
|           17877 | RUNNING   | 2023-01-06 16:20:13 | NULL                  | NULL             |          5 |
           51 | NULL                                        | NULL                |                 0 |
    1 |                2 |                  1128 |               3 |                 3 |                       0 | READ COMMITTED      |                 1 |                      1 | NULL                       |
   0 |                         0 |                0 |                          0 |                NULL |
| 283946307949064 | RUNNING   | 2023-01-06 16:19:30 | NULL                  | NULL             |          0 |
           49 | select * from information_schema.innodb_trx | NULL                |                 0 |
    0 |                0 |                  1128 |               0 |                 0 |                       0 | READ COMMITTED      |                 1 |                      1 | NULL                       |
   0 |                         0 |                0 |                          0 |                NULL |
+-----------------+-----------+---------------------+-----------------------+------------------+------------+---------------------+---------------------------------------------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+---------------------+
</code></pre>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>trx_id</code></td>
<td>事务id</td>
</tr>
<tr>
<td><code>trx_state</code></td>
<td>事务状态 <code>LOCK WAIT</code>代表发生了锁等待</td>
</tr>
<tr>
<td><code>trx_started</code></td>
<td>事务开始时间</td>
</tr>
<tr>
<td><code>trx_requested_lock_id</code></td>
<td>请求锁<code>id</code>, 事务当前正在等待锁的标识 可以join关联<code>INNODB_LOCKS.lock_id</code></td>
</tr>
<tr>
<td><code>trx_wait_started</code></td>
<td>事务开始锁等待的时间</td>
</tr>
<tr>
<td><code>trx_weight</code></td>
<td>事务的权重</td>
</tr>
<tr>
<td><code>trx_mysql_thread_id</code></td>
<td>事务线程 <code>ID</code> 可以join关联<code>PROCESSLIST.ID</code></td>
</tr>
<tr>
<td><code>trx_query</code></td>
<td>事务正在执行的 <code>SQL</code> 语句</td>
</tr>
<tr>
<td><code>trx_operation_state</code></td>
<td>事务当前操作状态</td>
</tr>
<tr>
<td><code>trx_isolation_level</code></td>
<td>当前事务的隔离级别</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一般来说 事务是必须满足4个条件( <code>ACID</code>) : : 原子性( <strong>A</strong>tomicity 或称不可分割性)  一致性( <strong>C</strong>onsistency)  隔离性( <strong>I</strong>solation 又称独立性)  持久性( <strong>D</strong>urability) .</p>
</blockquote>
<ul>
<li>原子性: 指处于同一个事务中的多条语句是不可分割的.</li>
<li>一致性: 事务必须使数据库从一个一致性状态变换到另外一个一致性状态. 比如转账, 转账前两个账户余额之和为2k, 转账之后也应该是2K.</li>
<li>隔离性: 指多线程环境下, 一个线程中的事务不能被其他线程中的事务打扰.</li>
<li>持久性: 事务一旦提交(<code>commit</code>) 就应该被永久保存起来.</li>
</ul>
<p>事务控制语句:</p>
<ul>
<li><code>BEGIN</code> 或 <code>START TRANSACTION</code> 显式地开启一个事务;</li>
<li><code>COMMIT</code> 也可以使用 <code>COMMIT WORK</code> 不过二者是等价的. <code>COMMIT</code> 会提交事务 并使已对数据库进行的所有修改成为永久性的;</li>
<li><code>ROLLBACK</code> 也可以使用 <code>ROLLBACK WORK</code> 不过二者是等价的. 回滚会结束用户的事务 并撤销正在进行的所有未提交的修改;</li>
<li><code>SAVEPOINT identifier</code> <code>SAVEPOINT</code> 允许在事务中创建一个保存点 一个事务中可以有多个 SAVEPOINT;</li>
<li><code>RELEASE SAVEPOINT identifier</code> 删除一个事务的保存点 当没有指定的保存点时 执行该语句会抛出一个异常;</li>
<li><code>ROLLBACK TO identifier</code> 把事务回滚到标记点;</li>
<li><code>SET TRANSACTION</code> 用来设置事务的隔离级别. <code>InnoDB</code> 存储引擎提供事务的隔离级别有READ UNCOMMITTED <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>.</li>
</ul>
<p><code>MySQL</code> 事务处理主要有两种方法:</p>
<p><em>注意: python的中的<code>mysql_connnector</code>默认状态是处于事务中执行的, 必须<code>commit</code>后才能写入数据库.</em></p>
<p>1 用<code>BEGIN</code>, <code>ROLLBACK</code>, <code>COMMIT</code>来实现</p>
<ul>
<li><code>BEGIN</code>, 开始一个事务</li>
<li><code>ROLLBACK</code>, 事务回滚</li>
<li><code>COMMIT</code>, 事务确认</li>
</ul>
<p>2 直接用 <code>SET </code>来改变 <code>MySQL</code> 的自动提交模式:</p>
<ul>
<li><code>SET AUTOCOMMIT=0</code>, 禁止自动提交,</li>
<li><code>SET AUTOCOMMIT=1</code>, 开启自动提交,</li>
</ul>
<h3 id="61-隔离等级">6.1 隔离等级</h3>
<pre><code class="language-bash">mysql&gt; set autocommit = 0;

mysql&gt; select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)
# REPEATABLE-READ, MySQL 的默认级别
</code></pre>
<pre><code class="language-mysql">set global transaction isolation level read committed;
-- 修改隔离等级
</code></pre>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读( Dirty Read)</th>
<th>不可重复读( NonRepeatable Read)</th>
<th>幻读( Phantom Read)</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读( Read uncommitted)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>**已提交读( Read committed) **</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读( Repeatable read)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>**可串行化( Serializable ) **</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<p>从上往下, 隔离强度逐渐增强, 性能逐渐变差. <strong>可串行化( Serializable ) <strong>, 解决了所有的问题, 但是是以单线程</strong>依次</strong>执行对应的事务的低效率换取而来.</p>
<blockquote>
<p><code>MySQL</code> 的 <code>InnoDB</code> 引擎才支持事务, 其中<strong>可重复读</strong>是<strong>默认</strong>的隔离级别.</p>
<p>读未提交和串行化基本上是不需要考虑的隔离级别, 前者不加锁限制, 后者相当于单线程执行, 效率太差.</p>
<p>读提交解决了脏读问题, 行锁解决了并发更新的问题. 并且 <code>MySQL</code>在可重复读级别解决了幻读问题, 是通过行锁和间隙锁的组合 <code>Next-Key</code> 锁实现的.</p>
</blockquote>
<h4 id="611-read-uncommitted">6.1.1 Read uncommitted</h4>
<figure data-type="image" tabindex="21"><img src="https://pic4.zhimg.com/80/v2-77225da0805e43183c076c24f270e75b_720w.webp" alt="v2-77225da0805e43183c076c24f270e75b_720w1672988725248.jpg" loading="lazy"></figure>
<pre><code class="language-bash"># session a
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) DEFAULT NULL,
  `age` tinyint(4) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

insert into user values (1, 'test', 1)

# 变更事务等级
set global transaction isolation level read uncommitted;

# 登录session_b

# session_a
BEGIN;
update user set age = 10;

# session_b
select * from user;
# age = 10

# session_a
rollback;

# 这就一位着session_b这个时候拿到的数据是脏数据, a数据已经复原
</code></pre>
<blockquote>
<p><strong>脏读</strong>, 指的是读到了其他事务未提交的数据, 未提交意味着这些数据可能会回滚, 也就是可能最终不会存到数据库中, 也就是不存在的数据. 读到了并一定最终存在的数据, 这就是脏读.</p>
</blockquote>
<h4 id="612-read-committed">6.1.2 Read committed</h4>
<p><code>mysql</code>默认的事务隔离等级.</p>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:left">事务A</th>
<th style="text-align:left">事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td style="text-align:left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">BEGIN;</td>
<td style="text-align:left">BEGIN;</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"></td>
<td style="text-align:left">SELECT * FROM students WHERE id = 1; -- Alice</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">UPDATE students SET name = 'Bob' WHERE id = 1;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">COMMIT;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"></td>
<td style="text-align:left">SELECT * FROM students WHERE id = 1; -- Bob</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"></td>
<td style="text-align:left">COMMIT;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在Read Committed隔离级别下 一个事务可能会遇到不可重复读( Non Repeatable Read) 的问题.</p>
<p><strong>不可重复读</strong> 在一个事务内 多次读同一数据 在这个事务还没有结束时 如果另一个事务恰好修改了这个数据 那么 在第一个事务中 两次读取的数据就可能不一致.</p>
</blockquote>
<h4 id="613-repeatable-read">6.1.3 Repeatable Read</h4>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:left">事务A</th>
<th style="text-align:left">事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td style="text-align:left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">BEGIN;</td>
<td style="text-align:left">BEGIN;</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"></td>
<td style="text-align:left">SELECT * FROM students WHERE id = 99; -- empty</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">INSERT INTO students (id, name) VALUES (99, 'Bob');</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">COMMIT;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"></td>
<td style="text-align:left">SELECT * FROM students WHERE id = 99; -- empty</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"></td>
<td style="text-align:left">UPDATE students SET name = 'Alice' WHERE id = 99; -- 1 row affected</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"></td>
<td style="text-align:left">SELECT * FROM students WHERE id = 99; -- Alice</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"></td>
<td style="text-align:left">COMMIT;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在Repeatable Read隔离级别下 一个事务可能会遇到幻读( Phantom Read) 的问题.</p>
<p><strong>幻读</strong> 在一个事务中 第一次查询某条记录 发现没有 但是 当试图更新这条不存在的记录时 竟然能成功 并且 再次读取同一条记录 它就神奇地出现了.</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/117476959">MySQL事务隔离级别和实现原理(看这一篇文章就够了! )</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1245266514539200">廖雪峰-SQL</a></li>
</ul>
<h3 id="62-autocommit">6.2 autocommit</h3>
<pre><code class="language-mysql"># 返回当前会话的自动事务提交的状态
select @@session.autocommit;
select @@autocommit;
</code></pre>
<p>注意在<code>set autocommit = 0;</code>强制事务的情况.</p>
<figure data-type="image" tabindex="22"><a href="https://imgse.com/i/pSw8oG9"><img src="https://s1.ax1x.com/2023/01/30/pSw8oG9.jpg" alt="pSw8oG9.jpg" loading="lazy"></a></figure>
<pre><code class="language-bash"># session_a
# 将autocommit设置为0, 不主动提交事务
mysql&gt; select * from test_o;
+------+------+--------+---------+
| id   | name | gender | address |
+------+------+--------+---------+
|    1 | tes  | n      | m       |
|    1 | test | i      | o       |
|    1 | test | m      | us      |
|    2 | tony | f      | china   |
+------+------+--------+---------+
4 rows in set (0.00 sec)

mysql&gt; set autocommit = 0;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update test_o set name = 'alex' where id = 1;
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0

# session_b, 进行同样的操作, 由于session_a中的操作尚未提交事务, 处于锁定的状态, session_b无法执行操作.
mysql&gt; update test_o set name = 'jam' where id = 1;
# 等待超时
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

# 然后在session_a执行commit操作
commit;

# session_b, 重新执行此命令
mysql&gt; update test_o set name = 'jam' where id = 1;

# session_a, session_a无法看到
mysql&gt; select * from test_o;
+------+------+--------+---------+
| id   | name | gender | address |
+------+------+--------+---------+
|    1 | alex | n      | m       |
|    1 | alex | i      | o       |
|    1 | alex | m      | us      |
|    2 | tony | f      | china   |
+------+------+--------+---------+

# 新登录进来的, session_c
mysql&gt; select * from test_o;
+------+------+--------+---------+
| id   | name | gender | address |
+------+------+--------+---------+
|    1 | jam  | n      | m       |
|    1 | jam  | i      | o       |
|    1 | jam  | m      | us      |
|    2 | tony | f      | china   |
+------+------+--------+---------+

# session_b
mysql&gt; select * from test_o;
+------+------+--------+---------+
| id   | name | gender | address |
+------+------+--------+---------+
|    1 | jam  | n      | m       |
|    1 | jam  | i      | o       |
|    1 | jam  | m      | us      |
|    2 | tony | f      | china   |
+------+------+--------+---------+

# 需要将set autocommit = 1;之后, session_a才能看到改变的数据

# session_a 再继续执行commit之后
mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from test_o;
+------+------+--------+---------+
| id   | name | gender | address |
+------+------+--------+---------+
|    1 | jam  | n      | m       |
|    1 | jam  | i      | o       |
|    1 | jam  | m      | us      |
|    2 | tony | f      | china   |
+------+------+--------+---------+
# 继续在session_b执行update操作
# session_a依然无法直接看到变化, 需要commit之后才能看到变化

# 暂不清楚上述的执行逻辑
</code></pre>
<h3 id="63-mvcc">6.3 MVCC</h3>
<blockquote>
<p>The so-called <code>MVCC</code> in <code>mysql</code> refers to the process of accessing the version chain while executing ordinary <strong><code>SELECT</code> operations using <code>RC</code> and <code>RR</code> transactions with two isolation levels, which enables read/write and write-write operations of different transactions</strong> to be executed concurrently, thus improving system performance, and their biggest difference lies in the different timing of generating <code>ReadView</code>.</p>
</blockquote>
<blockquote>
<p><code>MVCC( Multi-Version Concurrent Control)</code> 即多版本并发控制协议 它的目标是在保证数据一致性的前提下 提供一种高并发的访问性能. 在MVCC协议中 每个用户在连接数据库时看到的是一个具有一致性状态的镜像 每个事务在提交到数据库之前对其他用户均是不可见的. 当事务需要更新数据时 不会直接覆盖以前的数据 而是生成一个新的版本的数据 因此一条数据会有多个版本存储 但是同一时刻只有最新的版本号是有效的. 因此 读的时候就可以保证总是以当前时刻的版本的数据可以被读到 不论这条数据后来是否被修改或删除.</p>
</blockquote>
<blockquote>
<p><a href="https://so.csdn.net/so/search?q=MVCC&amp;spm=1001.2101.3001.7020">MVCC</a> 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能. 一般是在使用读已提交( READ COMMITTED) 和可重复读( Repeatable Read) 隔离级别的事务中实现.</p>
</blockquote>
<blockquote>
<p><strong>当前读</strong></p>
<p>像 select in share mode( 共享锁)  select for update update insert delete( 排它锁) 这些操作都是一种当前读 当前读就是它读取的是记录的最新版本的数据. 读取时还要保证其他并发事务不能修改当前的记录 会对读取的记录进行加锁.</p>
<p><strong>快照读</strong></p>
<p>就像不加锁的select操作就是快照读 即不加锁的非阻塞读;</p>
<p>快照读的前提就是隔离级别不是串行级别 串行级别下的快照读会退化成当前读;</p>
<p>之所以出现快照读的情况 是基于提高并发性能的考虑 快照读的实现是基于多版本并发控制 即MVCC 可以认为MVCC是行锁的一个变种 但它在很多情况下都避免了加锁操作 降低了开销;</p>
<p>既然是基于多版本 即快照读可能读到的并不一定是数据的最新版本 而有可能是之前的历史版本.</p>
</blockquote>
<h4 id="631-mvcc解决的问题">6.3.1 MVCC解决的问题</h4>
<p>数据库并发场景有三种 分别为:</p>
<ul>
<li>读读(r-r): 不存在任何问题(不涉及到数据的变化) 也不需要并发控制</li>
<li><strong>读写(r-w)</strong>: 有线程安全问题 可能会造成事务隔离性问题 可能遇到<strong>脏读 幻读 不可重复读</strong></li>
<li>写写(w-w): 有线程安全问题 可能存在更新丢失问题(如何判断到底那次写入的信息是可信的, 或者是被认为是最终的版本的?)</li>
</ul>
<p><code>MVCC</code>是一种用来解决读写冲突的无锁并发控制 也就是为事务分配单项增长的时间戳 为每个修改保存一个版本 版本与事务时间戳关联 读操作只读该事务开始前的数据库的快照 所以<code>MVCC</code>可以为数据库解决以下问题:</p>
<ul>
<li>在并发读写数据库时 可以做到在读操作时不用阻塞写操作 写操作也不用阻塞读操作 提高了数据库并发读写的性能</li>
<li>解决脏读 幻读 不可重复读等事务隔离问题 但是<strong>不能解决</strong>更新丢失问题</li>
</ul>
<p>多数情况下, 写入数据相对于读取数据, 其次数是相对较少的, 不能因为写入数据长期锁表导致需求量更高的读取数据出现问题, 读写冲突是优先解决的问题.</p>
<ul>
<li><a href="https://www.cnblogs.com/hanease/p/15734249.html">MVCC基本原理</a></li>
</ul>
<h2 id="七-锁">七. 锁</h2>
<pre><code class="language-mysql">show open tables;
-- 查看表的锁情况
show status like 'innodb_row_lock%';
</code></pre>
<pre><code class="language-bash">mysql&gt; show status like 'table%';
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
| Table_locks_immediate      | 5     |
| Table_locks_waited         | 0     |
| Table_open_cache_hits      | 823   |
| Table_open_cache_misses    | 29    |
| Table_open_cache_overflows | 0     |
+----------------------------+-------+

# 1. table_locks_waited
# 出现表级锁定争用而发生等待的次数( 不能立即获取锁的次数 每等待一次值加1)  此值高说明存在着较严重的表级锁争用情况
# 2. table_locks_immediate
# 产生表级锁定次数 不是可以立即获取锁的查询次数 每立即获取锁加1

mysql&gt; show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 0     |
| Innodb_row_lock_time_avg      | 0     |
| Innodb_row_lock_time_max      | 0     |
| Innodb_row_lock_waits         | 0     |
+-------------------------------+-------+

# 1. innodb_row_lock_current_waits //当前正在等待锁定的数量
# 2. innodb_row_lock_time //从系统启动到现在锁定总时间长度
# 3. innodb_row_lock_time_avg //每次等待所花平均时间
# 4. innodb_row_lock_time_max //从系统启动到现在等待最长的一次所花时间
# 5. innodb_row_lock_waits //系统启动后到现在总共等待的次数
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://p1.meituan.net/dpplatform/0c145da4d7e64060c496029fcd3678c263537.png" alt="lock" loading="lazy"></figure>
<blockquote>
<p>锁机制用于管理对共享资源的并发访问 是对数据库的一种保护机制 也是数据库在事务操作中保证事务数据一致性和完整性的一种机制. 当有多个用户并发的去存取数据时 在数据库中就可能会产生多个事务同时去操作一行数据的情况 如果我们不对此类并发操作不加以控制的话 就可能会读取和存储不正确的数据 最终破坏了数据的一致性.</p>
</blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL_InnoDB Locking</a></p>
<p>注意不同的锁在有<code>index</code>和无<code>index</code>的差异</p>
<blockquote>
<p>This section describes lock types used by <code>InnoDB</code>.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-shared-exclusive-locks">Shared and Exclusive Locks</a>, 共享和排他锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks">Intention Locks</a>, 意向锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-record-locks">Record Locks</a>, 记录锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks">Gap Locks</a>, 间隙锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks">Next-Key Locks</a>, 临键锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-insert-intention-locks">Insert Intention Locks</a>, 插入意向锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-auto-inc-locks">AUTO-INC Locks</a>, 自增锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-predicate-locks">Predicate Locks for Spatial Indexes</a>, 预测锁</li>
</ul>
</blockquote>
<ul>
<li>
<p>对于<code> insert, update, delete, InnoDB</code> 会自动给涉及的数据加排他锁(<code>X</code>), 只有查询 <code>select </code>需要我们手动设置排他锁.</p>
</li>
<li>
<p>对于一般的 <code>select</code> 语句 <code>InnoDB</code> 不会加任何锁 也就是可以多个并发去进行 <code>select</code> 的操作 不会有任何的锁冲突 因为根本没有锁.</p>
</li>
</ul>
<h3 id="71-行锁record-lock">7.1 行锁(record lock)</h3>
<p>注意<code>索引</code></p>
<blockquote>
<p>A record lock is a lock on an <strong>index record</strong>. For example, <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> prevents any other transaction from inserting, updating, or deleting rows where the value of <code>t.c1</code> is <code>10</code>.</p>
</blockquote>
<pre><code class="language-bash">mysql&gt; select * from next;
+----+------+
| id | name |
+----+------+
|  1 | ok   |
|  2 | cx   |
|  3 | ciy  |
|  5 | a    |
|  6 | p    |
|  7 | b    |
+----+------+
6 rows in set (0.00 sec)

# session a
set autocommit = 0;

update next set name = 'cx' where id = 2;
# 更新id为2的项

# session b
# 更新其他行则没问题
mysql&gt; update next set name = 'ok' where id = 1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

# 更新相同的id的数据, 就会被阻止
mysql&gt; update next set name = 'ok' where id = 2;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre>
<h3 id="72-间隙锁gap-lock">7.2 间隙锁(gap lock)</h3>
<p>注意<code>索引</code></p>
<blockquote>
<p>A gap lock is a lock on a gap between <strong>index records</strong>, or a lock on the gap before the first or after the last index record. For example, <code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> prevents other transactions from inserting a value of <code>15</code> into column <code>t.c1</code>, whether or not there was already any such value in the column, because the gaps between all existing values in the range are locked.</p>
</blockquote>
<ul>
<li>有<strong>索引</strong>, 扫描到的项锁上</li>
<li>无索引, 可能扫全表(即行锁升级为<strong>表锁</strong>)</li>
</ul>
<p><code>select ... for update</code>类似的, 也是间隙锁.</p>
<figure data-type="image" tabindex="24"><a href="https://imgse.com/i/pS0ep40"><img src="https://s1.ax1x.com/2023/01/31/pS0ep40.png" alt="pS0ep40.png" loading="lazy"></a></figure>
<pre><code class="language-bash"># 无索引
# session a
mysql&gt; update next set name = 'abc' where id&gt; 1 and id &lt; 6;
Query OK, 2 rows affected (0.00 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql&gt; select * from next;
+----+------+
| id | name |
+----+------+
|  1 | ok   |
|  3 | abc  |
|  9 | cx   |
|  5 | abc  |
|  6 | p    |
|  9 | b    |
+----+------+
6 rows in set (0.00 sec
# id的列内容是混乱的

# session b
mysql&gt; update next set name = 'cs' where id = 1;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; update next set name = 'cs' where id = 3;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; update next set name = 'cs' where id = 9;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre>
<pre><code class="language-bash"># 有索引
mysql&gt; select * from next;
+----+------+
| id | name |
+----+------+
|  1 | ok   |
|  3 | abc  |
|  5 | abc  |
|  6 | p    |
|  7 | cx   |
|  9 | b    |
+----+------+
6 rows in set (0.00 sec)

mysql&gt; update next set name = 'dc' where id&gt; 1 and id &lt; 6;
Query OK, 2 rows affected (0.00 sec)
Rows matched: 2  Changed: 2  Warnings: 0

# session b
# id = 1, 没有纳入
mysql&gt; update next set name = 'cs' where id = 1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

# 3, 在其中
mysql&gt; update next set name = 'cs' where id = 3;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre>
<h3 id="73-临键锁next-key-lock">7.3 临键锁(next-key lock)</h3>
<p>注意<code>索引</code></p>
<blockquote>
<p>A next-key lock is a combination of a <strong>record lock</strong> on the <strong>index record</strong> and a <strong>gap lock</strong> on the gap before the index record.</p>
</blockquote>
<p>这是行锁和间隙锁结合的变种.</p>
<h3 id="74-自增锁auto-inc-lock">7.4 自增锁(auto-inc lock)</h3>
<blockquote>
<p>An <code>AUTO-INC</code> lock is a <strong>special table-level lock</strong> taken by transactions inserting into tables with <code>AUTO_INCREMENT</code> columns. In the simplest case, if one transaction is inserting values into the table, any other transactions must wait to do their own inserts into that table, so that rows inserted by the first transaction receive consecutive primary key values.</p>
</blockquote>
<p>专属于自增主键操作的锁.</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a></p>
<pre><code>mysql&gt; show variables like 'innodb_autoinc_lock_mode';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 2     |
+--------------------------+-------+
1 row in set (0.01 sec)
</code></pre>
<figure data-type="image" tabindex="25"><a href="https://imgse.com/i/pS0ZN1U"><img src="https://s1.ax1x.com/2023/01/31/pS0ZN1U.png" alt="pS0ZN1U.png" loading="lazy"></a></figure>
<table>
<thead>
<tr>
<th style="text-align:left">Command-Line Format</th>
<th><code>--innodb-autoinc-lock-mode=#</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">System Variable</td>
<td><code>innodb_autoinc_lock_mode</code></td>
</tr>
<tr>
<td style="text-align:left">Scope</td>
<td>Global</td>
</tr>
<tr>
<td style="text-align:left">Dynamic</td>
<td>No</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-set-var"><code>SET_VAR</code></a> Hint Applies</td>
<td>No</td>
</tr>
<tr>
<td style="text-align:left">Type</td>
<td>Integer</td>
</tr>
<tr>
<td style="text-align:left">Default Value</td>
<td><code>2</code></td>
</tr>
<tr>
<td style="text-align:left">Valid Values</td>
<td><code>0``1``2</code></td>
</tr>
</tbody>
</table>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_lock_mode">lock mode</a> to use for generating <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_auto_increment">auto-increment</a> values. Permissible values are 0, 1, or 2, for traditional, consecutive, or interleaved, respectively.</p>
<p>The default setting is 2 (interleaved) as of MySQL 8.0, and 1 (consecutive) before that. The change to interleaved lock mode as the default setting reflects the change from statement-based to row-based replication as the default replication type, which occurred in MySQL 5.7. Statement-based replication requires the consecutive auto-increment lock mode to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of SQL statements, whereas row-based replication is not sensitive to the execution order of SQL statements.</p>
<p>For the characteristics of each lock mode, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes">InnoDB AUTO_INCREMENT Lock Modes</a>.</p>
<h3 id="75-排他锁exclusive-lock共享锁shared-lock">7.5 排他锁(exclusive lock)/共享锁(shared lock)</h3>
<ul>
<li>
<p>排他锁, 即<code>X</code>.</p>
</li>
<li>
<p>共享锁, 即<code>S</code>.</p>
<figure data-type="image" tabindex="26"><a href="https://imgse.com/i/pS0eKC6"><img src="https://s1.ax1x.com/2023/01/31/pS0eKC6.png" alt="pS0eKC6.png" loading="lazy"></a></figure>
<p>共享锁, A加锁不影响B中的数据读取, 但是阻止B中的数据更新.</p>
</li>
</ul>
<figure data-type="image" tabindex="27"><a href="https://imgse.com/i/pS0eIr4"><img src="https://s1.ax1x.com/2023/01/31/pS0eIr4.png" alt="pS0eIr4.png" loading="lazy"></a></figure>
<p>对<code>A</code>加共享锁, 对<code>B</code>加共享锁, 对<code>C</code>加排他锁(<code>for update</code>).</p>
<p>共享锁之间不受影响, 但是加共享锁后, 加入排他锁, 则会冲突. 注意<strong>索引</strong>的存在.</p>
<blockquote>
<p><code>InnoDB</code> implements standard row-level locking where there are two types of locks, <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock">shared (<code>S</code>) locks</a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock">exclusive (<code>X</code>) locks</a>.</p>
<ul>
<li>A <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock">shared (<code>S</code>) lock</a> permits the transaction that holds the lock to read a row.</li>
<li>共享锁允许事务在读取行数据时执行加锁</li>
<li>An <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock">exclusive (<code>X</code>) lock</a> permits the transaction that holds the lock to update or delete a row.</li>
<li>排他共享</li>
</ul>
<p>If transaction <code>T1</code> holds a shared (<code>S</code>) lock on row <code>r</code>, then requests from some distinct transaction <code>T2</code> for a lock on row <code>r</code> are handled as follows:</p>
<ul>
<li>A request by <code>T2</code> for an <code>S</code> lock can be granted immediately. As a result, both <code>T1</code> and <code>T2</code> hold an <code>S</code> lock on <code>r</code>.</li>
<li>A request by <code>T2</code> for an <code>X</code> lock cannot be granted immediately.</li>
</ul>
<p>If a transaction <code>T1</code> holds an exclusive (<code>X</code>) lock on row <code>r</code>, a request from some distinct transaction <code>T2</code> for a lock of either type on <code>r</code> cannot be granted immediately. Instead, transaction <code>T2</code> has to wait for transaction <code>T1</code> to release its lock on row <code>r</code>.</p>
</blockquote>
<p>记录锁 间隙锁 临键锁都是排它锁 而记录锁的使用方法跟排它锁介绍一致.</p>
<table>
<thead>
<tr>
<th>兼容性</th>
<th>加锁方式</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>S锁: 共享锁</td>
<td>加了S锁的记录 允许其他事务再加S锁 不允许其他事务再加X锁</td>
<td>select…lock in share mode</td>
</tr>
<tr>
<td>X锁: 排他锁</td>
<td>加了X锁的记录 不允许其他事务再加S锁或者X锁</td>
<td>select…for update</td>
</tr>
</tbody>
</table>
<h3 id="76-意向锁">7.6 意向锁</h3>
<p><code>InnoDB</code>自动执行.</p>
<ul>
<li>意向共享锁, 即<code>IS</code></li>
<li>意向排他锁, 即<code>Ix</code></li>
</ul>
<blockquote>
<p><code>InnoDB</code> supports <em>multiple granularity locking</em> which permits coexistence of row locks and table locks. For example, a statement such as <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html"><code>LOCK TABLES ... WRITE</code></a> takes an exclusive lock (an <code>X</code> lock) on the specified table. To make locking at multiple granularity levels practical, <code>InnoDB</code> uses <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock">intention locks</a>. Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. There are two types of intention locks:</p>
<p>InnoDB支持不同锁粒度, 允许表锁和行锁实现共存.例如 lock 语句是排他锁针对特定的表. 为了实现不同锁粒度, InnoDB支持意向锁, 意向锁是表层级的锁, 用于标记事务需要对表中的一行需要什么类型的锁.</p>
<ul>
<li>An <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock">intention shared lock</a> (<code>IS</code>) indicates that a transaction intends to set a <em>shared</em> lock on individual rows in a table.</li>
<li>意向共享锁, 意味着事务准备对单独行进行设置共享锁在一个表中.</li>
<li>An <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock">intention exclusive lock</a> (<code>IX</code>) indicates that a transaction intends to set an exclusive lock on individual rows in a table.</li>
<li>意向共享锁, 意味着事务准备对单独行进行设置排他锁在一个表中.</li>
</ul>
</blockquote>
<p>Table-level lock type compatibility is summarized in the following matrix.</p>
<p><strong>表级</strong>别的锁之间的相关兼容情况.</p>
<p>注意这里指的是<strong>表级别</strong>的锁.</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"><code>X</code></th>
<th style="text-align:left"><code>IX</code></th>
<th style="text-align:left"><code>S</code></th>
<th style="text-align:left"><code>IS</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>X</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
</tr>
<tr>
<td style="text-align:left"><code>IX</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Compatible</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Compatible</td>
</tr>
<tr>
<td style="text-align:left"><code>S</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Compatible</td>
<td style="text-align:left">Compatible</td>
</tr>
<tr>
<td style="text-align:left"><code>IS</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Compatible</td>
<td style="text-align:left">Compatible</td>
<td style="text-align:left">Compatible</td>
</tr>
</tbody>
</table>
<p>意向锁的存在是为了协调行锁和表锁的关系 支持多粒度( 表锁与行锁) 的锁并存.</p>
<ul>
<li>意向共享锁( IS锁) : 事务在请求S锁前 要先获得IS锁.</li>
<li>意向排他锁( IX锁) : 事务在请求X锁前 要先获得IX锁.</li>
</ul>
<p>例子: 事务A修改user表的记录r 会给记录r上一把行级的排他锁( X)  同时会给user表上一把意向排他锁( IX)  这时事务B要给user表上一个表级的排他锁就会被阻塞. 意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求.</p>
<p>为什么意向锁是表级锁呢?</p>
<p>当我们需要加一个排他锁时 需要根据意向锁去判断表中有没有数据行被锁定(行锁).</p>
<ul>
<li>
<p>如果意向锁是行锁 则需要遍历每一行数据去确认</p>
</li>
<li>
<p>如果意向锁是表锁 则只需要判断一次即可知道有没数据行被锁定 提升性能.</p>
</li>
</ul>
<p>意向锁怎么支持表锁和行锁并存?</p>
<ul>
<li>首先明确并存的概念是指数据库同时支持表 行锁 而不是任何情况都支持一个表中同时有一个事务A持有行锁 又有一个事务B持有表锁 因为表一旦被上了一个表级的写锁 肯定不能再上一个行级的锁.</li>
<li>如果事务A对某一行上锁 其他事务就不可能修改这一行. 这与&quot; 事务B锁住整个表就能修改表中的任意一行&quot; 形成了冲突. 所以 没有意向锁的时候 让行锁与表锁共存 就会带来很多问题. 于是有了意向锁的出现 如q1的答案中 数据库不需要在检查每一行数据是否有锁 而是直接判断一次意向锁是否存在即可 能提升很多性能.</li>
</ul>
<p><a href="https://blog.csdn.net/u010841296/article/details/87909468">MySQL的共享锁(S) 排他锁(X) 意向共享锁(IS) 意向排他锁(IX)的关系</a></p>
<h3 id="77-插入意向锁">7.7 插入意向锁</h3>
<blockquote>
<p>An insert intention lock is a type of gap lock set by <a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p>
</blockquote>
<figure data-type="image" tabindex="28"><a href="https://imgse.com/i/pS0inld"><img src="https://s1.ax1x.com/2023/01/31/pS0inld.png" alt="pS0inld.png" loading="lazy"></a></figure>
<p>在A执行事务, 使用<code>select .. for update</code>锁定, B执行插入操作.</p>
<h3 id="78-表锁">7.8 表锁</h3>
<pre><code class="language-mysql">-- 主动对表进行锁定
lock tables test_o read [write];
-- 遵循, 谁加锁, 谁解锁, 其他的线程不能解锁
-- read, 阻止写入

-- write, 阻止读取
-- 会导致update等操作一直处于等待的状态
unlock tables;
</code></pre>
<h3 id="79-乐观锁">7.9 乐观锁</h3>
<p>简而言之, 就是人为通过简单的状态字段来判断数据的变化情况.</p>
<p><code>乐观锁</code>是相<code>对悲观锁</code>而言的 乐观锁<strong>假设</strong>数据一般情况下不会造成冲突 所以在数据进行提交更新的时候 才会正式对数据的冲突与否进行检测 如果发现冲突了 则返回给用户错误的信息 让用户决定如何去做.</p>
<p>应用场景, 适用于<strong>读多写少</strong> 因为如果出现大量的写操作, 写冲突的可能性就会增大 业务层需要不断重试 会大大降低系统性能.</p>
<p>实现方式, 一般使用数据版本(<code>version</code>)记录机制实现 在数据库表中增加一个数字类型的<code>version</code>字段来实现. 当读取数据时 将<code>version</code>字段的值一同读出 数据每更新一次 对此<code>version</code>值加一. 当我们提交更新的时候 判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对 如果数据库表当前版本号与第一次取出来的<code>version</code>值相等 则予以更新 否则认为是过期数据.</p>
<h3 id="710-悲观锁">7.10 悲观锁</h3>
<p>悲观锁 正如其名 具有强烈的独占和排他特性 每次去拿数据的时候都认为别人会修改 对数据被外界( 包括本系统当前的其他事务 以及来自外部系统的事务处理) 修改持保守态度 因此 在整个数据处理过程中 将数据处于锁定状态.</p>
<p>应用场景, 适用于并发量不大, 写入操作比较频繁, 数据一致性比较高的场景.</p>
<p>在<code>MySQL</code>中使用悲观锁, 必须关闭<code>MySQL</code>的自动提交 <code>set autocommit=0</code>. <code>共享锁</code>和<code>排它锁</code>是悲观锁的不同的实现, 都属于悲观锁的范畴.</p>
<ul>
<li><a href="https://learnku.com/articles/39212">参考链接</a></li>
</ul>
<h2 id="八-索引">八. 索引</h2>
<pre><code class="language-mysql"># 查看索引
show index from table_name;
show keys from table_name;
-- 二者返回的结果是一致的

-- 不能直接看
show full columns from table_name;
# 这里返回的数据不准确

# 后期创建主键
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column_name` );

# 各种写法上的差异, 效果一致
CREATE TABLE test_2(id INT NOT NULL,
                        c1 INT,
                        CONSTRAINT pk2 PRIMARY KEY(id));

# 等价? 下面的语句实际创建的也是primary key?
# 在只有unique时, 显示的primary
# 但是二者共存时, PRI 和 UNI才会区分开来
create table cbs (
	id int unsigned not null primary key,
	name char(4) not null,
	unique index index_name (name)
);

mysql&gt; create table cbsi (
    -&gt;  id int unsigned not null,
    -&gt;  name char(4) not null,
    -&gt;  unique index index_name (name)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

-- 注意这里的显示问题, 并没有显示UNI, 而是显示PRI
mysql&gt; desc cbsi;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int unsigned | NO   |     | NULL    |       |
| name  | char(4)      | NO   | PRI | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

-- 实际上是index
mysql&gt; show index from cbsi;
+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null
| Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| cbsi  |          0 | index_name |            1 | name        | A         |           0 |     NULL |   NULL |
| BTREE      |         |               | YES     | NULL       |
+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+

alter table `table_name` add unique (`column_name`);
# 默认使用colum_name作为index_name
alter table bbc drop index id_name;
-- 注意这里的创建方式创建的键应当不是primary key

# 创建唯一索引
create unique index index_name on abc (name);
# 创建索引
CREATE INDEX indexName ON table_name (column_name);

# 创建联合索引
alter table bbc add unique key `id_name` (id, name);

create table test_table (
    -- 建表时创建主键
    id int unsigned not null primary key,
    name char(4) not null,
    address varchar(32) not null,
    -- 在创建表时创建index
    index index_name (name),
    -- 创建多个索引
    index index_addr (address)
);

create table fox (
	id int unsigned not null primary key,
	name char(4) not null,
	address varchar(32) not null,
	index index_addr (address),
	unique index index_name (name)
);

create table test_k (
	id int unsigned,
    -- 等价
	name char(4) unique,
	gender char(1),
	address varchar(32) not null
);

create table test_l (
	id int unsigned,
    -- 等价
	name char(4) unique key,
	gender char(1),
	address varchar(32) not null
);

create table test_m (
	id int unsigned,
	name char(4),
	gender char(1),
	address varchar(32) not null,
    -- 等价
	unique key key_name (name)
);

create table test_n (
	id int unsigned,
	name char(4),
	gender char(1),
	address varchar(32) not null,
    -- 等价
	unique index key_name (name)
);

-- 不支持 column + unique index
create table test_p (
	id int unsigned,
	name char(4) unique index,
	gender char(1),
	address varchar(32) not null
);
-- key/index, 创建, 效果一样

create table dpi (
	id int unsigned not null primary key,
	name char(4) not null,
	address varchar(32) not null,
	index index_addr (address),
	unique key index_name (name)
);

create table test_c (
	id int unsigned not null,
	name char(4) not null,
	gender char(1),
	address varchar(32) not null,
    -- name, 这里被纳入联合主键
	primary key (id, name),
	index index_addr (address),
    -- 这里name 被添加到唯一主键
    -- 最终显示的PRI, name
	unique key index_name (name),
    # 同一个数据库不允许存在同名的 约束检查?
    # ERROR 3822 (HY000): Duplicate check constraint name 'check_gender'.
	constraint check_gender check (gender in ('男', '女'))
);

# 删除索引
alter table bbc drop index id_name;

# 删除主键
alter table abc drop primary key;
</code></pre>
<pre><code class="language-bash">create table test_o (
	id int unsigned,
	name char(4),
	gender char(1),
	address varchar(32) not null,
    # 注意这里, 联合索引
	unique index id_name (id, name)
);

# 插入id_name 相同的数据
mysql&gt; insert into test_o values (1, 'test', 'n', 'm'), (1, 'test', 'i', 'o');
ERROR 1062 (23000): Duplicate entry '1-test' for key 'test_o.id_name'

mysql&gt; select * from test_o;
+------+------+--------+---------+
| id   | name | gender | address |
+------+------+--------+---------+
|    1 | tes  | n      | m       |
|    1 | test | i      | o       |
+------+------+--------+---------+
2 rows in set (0.00 sec)

# 遵循最左原则
mysql&gt; explain select * from test_o where name = 'test';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra
    |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_o | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from test_o where id = 2;
+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test_o | NULL       | ref  | id_name       | id_name | 5       | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; desc test_o;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| id      | int unsigned | YES  | MUL | NULL    |       |
| name    | char(4)      | YES  |     | NULL    |       |
| gender  | char(1)      | YES  |     | NULL    |       |
| address | varchar(32)  | NO   |     | NULL    |       |
+---------+--------------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql&gt; show index from test_o;
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test_o |          0 | id_name  |            1 | id          | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| test_o |          0 | id_name  |            2 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
2 rows in set (0.00 sec)

mysql&gt; show full columns from test_o;
+---------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+
| Field   | Type         | Collation          | Null | Key | Default | Extra | Privileges                      | Comment |
+---------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+
| id      | int unsigned | NULL               | YES  | MUL | NULL    |       | select,insert,update,references |
     |
| name    | char(4)      | utf8mb4_0900_ai_ci | YES  |     | NULL    |       | select,insert,update,references |
     |
| gender  | char(1)      | utf8mb4_0900_ai_ci | YES  |     | NULL    |       | select,insert,update,references |
     |
| address | varchar(32)  | utf8mb4_0900_ai_ci | NO   |     | NULL    |       | select,insert,update,references |
     |
+---------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+
4 rows in set (0.00 sec)

</code></pre>
<h3 id="81-index和key">8.1 index和key</h3>
<p>二者在不少方面是相似的. <code>Index</code>, 顾名思义, 起到的是<code>索引</code>的作用, 并不对数据进行<code>约束</code>; <code>Key</code>, 除了起到索引左右的同时还起到约束数据的作用, 如<code>primary key</code>, 除了作为索引, 其还约束每一行的唯一性.</p>
<p><code>primary key</code>(主键) 和 <code>unique keys/indexs</code>(唯一键约束), 注意这二者的区别.</p>
<pre><code class="language-bash">mysql&gt; select * from next;
+----+------+
| id | name |
+----+------+
|  1 | ok   |
|  2 | cx   |
|  3 | ciy  |
|  5 | a    |
|  6 | p    |
|  7 | b    |
+----+------+
6 rows in set (0.00 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

# id为primary key
# 当修改数据, 导致位置错乱, 会自动调整成顺序
mysql&gt; update next set id = 4 where id =2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from next;
+----+------+
| id | name |
+----+------+
|  1 | ok   |
|  3 | ciy  |
|  4 | cx   |
|  5 | a    |
|  6 | p    |
|  7 | b    |
+----+------+
6 rows in set (0.00 sec)
</code></pre>
<p><code>主键</code>, 每张表只允许存在<code>1</code>个(不是字段, 是主键); <code>唯一约束</code>, 每张表可以存在<code>多</code>个, 二者对于数据的要求都是唯一性; index, 数据索引, 可以存在重复项, 一张表可以存在多个index.</p>
<p>不适合索引的字段/情况:</p>
<ul>
<li>重复数据多, 如性别</li>
<li>更新频繁, 需要反复维护索引</li>
<li>表数据偏少.</li>
</ul>
<h3 id="82-约束">8.2 约束</h3>
<figure data-type="image" tabindex="29"><img src="https://img-blog.csdnimg.cn/20200219175103313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvcnNlcw==,size_16,color_FFFFFF,t_70#pic_center" alt="20200219175103313.png" loading="lazy"></figure>
<ul>
<li>
<p>非空约束(<code>NOT NULL</code>),用于确保字段不会出现空值. 例如学生信息表中, 学生的姓名, 出生日期, 性别等一定要有数据.</p>
<pre><code class="language-mysql">create table test_table (
    -- 主键约束
    id int unsigned not null primary key,
    -- 非空约束
    name char(4) not null
);
</code></pre>
</li>
<li>
<p>唯一约束(<code>UNIQUE</code>)用于确保字段中的值不会重复. 例如每个学生的身份证, 手机号等需要唯一.</p>
</li>
<li>
<p>主键约束(<code>Primary Key</code>)用于 唯一标识表中的每一行数据. 例如学生信息表中, 学号通常作为主键. 主键字段不能为空并且唯一 每个表可以有且只能有一个主键.</p>
</li>
<li>
<p>外键约束(<code>Foreign Key</code>)用于建立两个表之间的参照完整性. 例如学生属于班级, 学生信息表中的班级字段是一个外键 引用了班级表的主键. 对于外键引用 被引用的数据必须存在; 学生不可能属于一个不存在的班级.</p>
<pre><code class="language-mysql">CREATE TABLE dept
    ( department_id INTEGER NOT NULL PRIMARY KEY
    , department_name CHARACTER VARYING(30) NOT NULL
    );

# 需要进行外键约束的主表必须先创建
CREATE TABLE emp
    ( employee_id   INTEGER NOT NULL PRIMARY KEY
    , first_name    CHARACTER VARYING(20)
    , last_name     CHARACTER VARYING(25) NOT NULL
    , salary        NUMERIC(8,2)
    , manager_id    INTEGER
    , department_id INTEGER
    , CONSTRAINT    fk_emp_dept
                    FOREIGN KEY (department_id)
                    REFERENCES dept(department_id)
    );
</code></pre>
</li>
<li>
<p>检查约束(<code>CHECK</code>)可以定义更多的业务规则. 例如, 性别的取值只能为 &quot;男&quot; 或 &quot;女&quot;, 用户名必须大写等;</p>
<pre><code class="language-mysql">CREATE TABLE t_check(
  id INT PRIMARY KEY,
  c1 INT CHECK (c1 IS NOT NULL),
  c2 VARCHAR(10),
  c3 INT,
  c4 INT,
  -- 限制c2的内容必须是 ('START', 'CLOSE'), 不允许为空
  CONSTRAINT check_c2 CHECK (c2 IN ('START', 'CLOSE'))
);

# 变更检查约束
ALTER TABLE t_check
    ADD CONSTRAINT check_c3c4 CHECK ( c3 &gt; c4 );
</code></pre>
</li>
<li>
<p>默认值(<code>DEFAULT</code>) 用于为字段提供默认的数据. 例如, 玩家注册时的级别默认为1级.</p>
</li>
</ul>
<h3 id="83-索引的设计">8.3 索引的设计</h3>
<p>三星索引, 可能是对于一个查询语句最好的索引.<br>
三星索引, 顾名思义, 是满足了三个星级的索引.</p>
<p>★☆☆</p>
<p>定义: 如果与一个查询相关的索引行是相邻的, 或者至少相距足够靠近的话, 那这个索引就可以标记上一颗星.</p>
<p>收益: 它最小化了必须扫描的索引片的宽度.</p>
<p>实现: 把 <code>WHERE</code> 后的等值条件列作为索引最开头的列, 如此, 必须扫描的索引片宽度就会缩至最短.</p>
<p>★★☆</p>
<p>定义: 如果索引行的顺序与查询语句的需求一致, 则索引可以标记上第二颗星.</p>
<p>收益: 它排除了排序操作.</p>
<p>实现: 将 <code>ORDER BY</code> 列加入到索引中, 保持列的顺序</p>
<p>★★★</p>
<p>定义: 如果索引行中包含查询语句中的所有列, 那么这个索引就可以标记上第三颗星.</p>
<p>收益: 这避免了访问表的操作(避免了回表操作), 只访问索引就可以满足了.</p>
<p>实现: 将查询语句中剩余的列都加入到索引中.</p>
<h3 id="84-联合索引">8.4 联合索引</h3>
<ul>
<li>最左侧原则</li>
</ul>
<figure data-type="image" tabindex="30"><img src="https://p0.meituan.net/dpplatform/77d1ecab161b58faacbca688555d45b424625.png" alt="复合索引" loading="lazy"></figure>
<p>联合主键使用<code>sales_employee</code>和<code>fiscal_year</code>组成主键, 当检索的是<strong>最左侧</strong>的项时使用索引, 其他的则不会使用索引.</p>
<pre><code class="language-mysql">EXPLAIN SELECT * from sales WHERE sales_employee = '2016' and fiscal_year=2015;
-- 也不会使用索引, 那怕是遵循最左侧的原则
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://p1.meituan.net/dpplatform/5043ccd8ac1c32dce8fb35a77f0f988028094.png" alt="差异" loading="lazy"></figure>
<p><em>注意: 当语句中的<code>like</code>不加&quot;%&quot;符号.</em></p>
<p>但是需要注意的是, 引擎的差异.</p>
<pre><code class="language-mysql">create table ttp (
	id int unsigned not null,
	name char(4) not null,
	gender char(1),
	primary key (id, name),
	address varchar(32) not null,
	index index_addr (address)
) engine=MyISAM;
</code></pre>
<pre><code class="language-mysql">create table gps (
	id int unsigned not null,
	name char(4) not null,
	gender char(1),
	primary key (id, name),
	address varchar(32) not null,
	index index_addr (address)
);
</code></pre>
<p><code>ttp table</code>使用了<code>MyISAM</code>引擎, <code>gps table</code>,使用默认的<code>InnoDB</code>.</p>
<pre><code class="language-bash">mysql&gt; explain select * from ttp where name = 'alex';
+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | ttp   | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from gps where name = 'alex';
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | gps   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<p>使用<code>MyISAM</code>引擎的情况下, 尽管不遵循最左侧的原则, 但是并没有执行全表扫描.</p>
<h3 id="85-自增主键">8.5 自增主键</h3>
<pre><code class="language-mysql">create table test_d (
	id int unsigned primary key auto_increment,
	name char(4) not null,
	gender char(1),
	address varchar(32) not null,
	index index_addr (address)
);

insert into test_d (name, gender, address) values
('alex', '男', 'china'), ('tony', '男', 'us');

create table test_e (
	id int unsigned primary key auto_increment,
	name char(4) not null,
	gender char(1),
	address varchar(32) not null,
	index index_addr (address)
) auto_increment = 10;
-- 设置自增从10开始
insert into test_e (name, gender, address) values
('alex', '男', 'china'), ('tony', '男', 'us');

insert into test_e (name, gender, address) values
('piel', '男', 'us');
delete from test_e where id = 12;

insert into test_e (name, gender, address) values
('piel', '男', 'us');
</code></pre>
<pre><code class="language-bash">mysql&gt; select * from test_e;
+----+------+--------+---------+
| id | name | gender | address |
+----+------+--------+---------+
| 10 | alex | 男     | china   |
| 11 | tony | 男     | us      |
| 13 | piel | 男     | us      |
+----+------+--------+---------+
</code></pre>
<pre><code class="language-mysql">-- 删除原有的不连续的lid
ALTER TABLE test_e DROP COLUMN id;

-- 重建新的id列
ALTER TABLE article ADD article_id TINYINT(4) PRIMARY KEY NOT NULL AUTO_INCREMENT FIRST;
-- 不清楚这种删除重建的资源的消耗

-- 亦或者手动将自增重新设置
-- 需要在删除数据后进行
alter table test_e auto_increment = 12;
</code></pre>
<p>需要注意假如自增的主键同时是作为<code>外键</code>使用时的情形.</p>
<h3 id="86-前缀索引">8.6 前缀索引</h3>
<p>前缀索引顾名思义, 只使用作为索引的字段的部分数据作为索引, 以减少索引的资源占用.</p>
<pre><code class="language-mysql"># 创建一个存储过程, 插入测试数据

delimiter $$
CREATE PROCEDURE rand_test_data (in i_many int)
BEGIN
	DECLARE ic int DEFAULT 0;

	drop table if EXISTS test_table;

	CREATE TABLE test_table (id int not null, col varchar(32));

	set @autocommit = 0;

	REPEAT
		insert into test_table (id, col)  VALUES (ic, LEFT ( concat(rand() * 1000000000000, 'ajkshxm' ), 18 ));
		set ic = ic + 1;
	UNTIL
		ic = i_many
	END REPEAT;

	COMMIT;

	set @autocommit = 1;

end $$
delimiter ;

# 插入十万条数据
call rand_test_data(100000);

# 无索引状态
mysql&gt; select * from test_table where col = '4413703861.100324c';
Empty set (0.05 sec)

# 前缀占比长度, 独一无二的行占总行数的比例
mysql&gt; select
count(d    -&gt; count(distinct left(col, 3)) / count(*) as c3,
    -&gt; count(distinct left(col, 4)) / count(*) as c4,
    -&gt; count(distinct left(col, 5)) / count(*) as c5,
(distin    -&gt; count(distinct left(col, 5)) / count(*) as c6,
distinct    -&gt; count(distinct left(col, 7)) / count(*) as c7,
    -&gt; count(distinct left(col, 8)) / count(*) as c8,
    -&gt; count(distinct left(col, 9)) / count(*) as c9,
    -&gt; count(distinct left(col, 10)) / count(*) as c10,
    -&gt; count(distinct left(col, 11)) / count(*) as c11,
(distin    -&gt; count(distinct left(col, 12)) / count(*) as c12
    -&gt;  from test_table;
+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| c3     | c4     | c5     | c6     | c7     | c8     | c9     | c10    | c11    | c12    |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| 0.0090 | 0.0900 | 0.6024 | 0.6024 | 0.9929 | 0.9976 | 0.9980 | 0.9980 | 0.9980 | 0.9980 |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
1 row in set (0.93 sec)

# 可以明显看到数据到了 c7, 时, 再提升长度, 比例已经趋于平缓
mysql&gt; alter table test_table add index (col(7));
Query OK, 0 rows affected (0.67 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc test_table;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   |     | NULL    |       |
| col   | varchar(32) | YES  | MUL | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

# 在进行测试时, 时间消耗巨幅减少
mysql&gt; select * from test_table where col = '4413703861.100324c';
Empty set (0.00 sec)

mysql&gt; explain analyze select * from test_table where col = '4413703861.100324c';
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN
                                                                                                              |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -&gt; Filter: (test_table.col = '4413703861.100324c')  (cost=0.35 rows=1) (actual time=0.023..0.023 rows=0 loops=1)
    -&gt; Index lookup on test_table using col (col='4413703861.100324c')  (cost=0.35 rows=1) (actual time=0.022..0.022 rows=0 loops=1)
 |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
</code></pre>
<h3 id="87-主键的选择">8.7 主键的选择</h3>
<ul>
<li>自增主键, 这是相对好的选择, 除了自增中断的弊端之外, 没有相对明显的缺点. 整数占用的资源少, 检索的速度极快.</li>
<li><code>UUID</code>, 长度过长, 资源消耗较大.</li>
<li><code>snowflake</code>, <code>twitter</code>开源的分布式主键, 或者基于其基础上进行修改的衍生算法.</li>
<li><code>nanoid</code>, 一个开销较小的不重复主键.</li>
</ul>
<h3 id="88-btree">8.8 BTREE</h3>
<ul>
<li>聚簇索引: 数据存储和索引放在了一块 找到索引也就找到了数据, 在<code>InnoDB</code>聚簇索引的叶子节点存储行记录 因此  <code>InnoDB</code>必须要有且只有一个聚簇索引.
<ul>
<li>如果表定义了主键, 则<code>Primary Key</code>就是聚簇索引.</li>
<li>如果表没有定义主键, 则第一个非空唯一索引(<code>Not NULL Unique</code>)列是聚簇索引.</li>
<li>否则, <code>InnoDB</code>会创建一个隐藏的<code>row-id</code>作为聚集索引.</li>
</ul>
</li>
<li>非聚簇索引: 数据与索引分开储存 索引的叶子节点指向数据的对应行.</li>
<li>辅助索引: <code>InnoDB中</code> 在聚簇索引之上创建的索引为<code>辅助索引</code> 存的是搜索列为<code>key</code>, 主键为<code>value</code>, 比如说找到身份证 再找到<code>id</code> 然后根据<code>id</code>找到姓名.</li>
</ul>
<p>聚簇索引的优势</p>
<p>物理顺序和索引顺序一致 所以找到数据的时候 把页也加载了到了<code>buffer</code>中.</p>
<p>聚簇索引的缺点</p>
<p>维护索引非常昂贵 特别是插入新行或者分页的时候</p>
<p>什么时候用聚簇索引:</p>
<ul>
<li>
<p>当事务要搜索排序的时候.</p>
</li>
<li>
<p>取出一定范围数据的时候</p>
</li>
</ul>
<figure data-type="image" tabindex="32"><img src="https://ask.qcloudimg.com/http-save/2146679/3cp4c7vlbh.png" alt="1313648-202107220" loading="lazy"></figure>
<ul>
<li><a href="https://www.cnblogs.com/cangqinglang/p/15042752.html">参考链接_A</a></li>
<li><a href="https://blog.csdn.net/u013967628/article/details/84305511">参考链接_B</a></li>
<li><a href="https://blog.csdn.net/cristianoxm/article/details/121957011">聚簇索引 非聚簇索引 普通索引 唯一索引_ximeneschen的博客-CSDN博客_聚簇索引和索引</a></li>
</ul>
<h3 id="89-null值的影响">8.9 Null值的影响</h3>
<blockquote>
<p><code>MySql</code>难以优化引用可空列查询 它会使索引 索引统计和值更加复杂. 可空列需要更多的存储空间 还需要<code>mysql</code>内部进行特殊处理. 可空列被索引后 每条记录都需要一个额外的字节 还能导致<code>MyISAM</code> 中固定大小的索引变成可变大小的索引.</p>
<ul>
<li>
<ul>
<li>出自&lt; 高性能mysql第二版&gt;</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="language-bash">mysql&gt; create index name_index on test_g (name);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; explain select * from test_g where name = 'tong';
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
| id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test_g | NULL       | ref  | name_index    | name_index | 17      | const |    1 |   100.00 | Using index condition |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; show index from test_g;
+--------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test_g |          0 | PRIMARY    |            1 | id          | A         |           2 |     NULL |   NULL |      | BTREE      |         |
       | YES     | NULL       |
| test_g |          1 | index_addr |            1 | address     | A         |           2 |     NULL |   NULL |      | BTREE      |         |
       | YES     | NULL       |
| test_g |          1 | name_index |            1 | name        | A         |           2 |     NULL |   NULL | YES  | BTREE      |         |
       | YES     | NULL       |
+--------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.01 sec)

mysql&gt; show full columns from test_g;
+---------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+
| Field   | Type         | Collation          | Null | Key | Default | Extra | Privileges                      | Comment |
+---------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+
| id      | int unsigned | NULL               | NO   | PRI | NULL    |       | select,insert,update,references |         |
| name    | char(4)      | utf8mb4_0900_ai_ci | YES  | MUL | NULL    |       | select,insert,update,references |         |
| gender  | char(1)      | utf8mb4_0900_ai_ci | YES  |     | NULL    |       | select,insert,update,references |         |
| address | varchar(32)  | utf8mb4_0900_ai_ci | NO   | MUL | NULL    |       | select,insert,update,references |         |
+---------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+

# 直接执行 is null, 索引依然没有失效
mysql&gt; explain select * from test_g where name is null;
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
| id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test_g | NULL       | ref  | name_index    | name_index | 17      | const |    1 |   100.00 | Using index condition |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<p><code>null</code>可能导致索引的失效, 但是不是一定会导致索引失效.(<em>注意这只是局部的测试, 使用环境还需要考虑例如不同的引擎的影响等各类因素.</em>)</p>
<blockquote>
<p>MySQL can perform the same optimization on <em><code>col_name</code></em> <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null"><code>IS NULL</code></a> that it can use for <em><code>col_name</code></em> <code>=</code> <em><code>constant_value</code></em>. For example, MySQL can use indexes and ranges to search for <code>NULL</code> with <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null"><code>IS NULL</code></a>.</p>
</blockquote>
<ul>
<li>
<p>所有使用<code>NULL</code>值的情况 都可以通过一个有意义的值的表示 这样有利于代码的可读性和可维护性 并能从约束上增强业务数据的规范性.</p>
</li>
<li>
<p><code>NULL</code>值到非<code>NULL</code>的更新无法做到原地更新 更容易发生索引分裂 从而影响性能. (注意: 但把<code>NULL</code>列改为<code>NOT NULL</code>带来的性能提示很小 除非确定它带来了问题 否则不要把它当成优先的优化措施 最重要的是使用的列的类型的适当性.)</p>
</li>
<li>
<p><code>NULL</code>值在<code>timestamp</code>类型下容易出问题 特别是没有启用参数<code>explicit_defaults_for_timestamp</code></p>
</li>
<li>
<p><code>NOT IN !=</code> 等负向条件查询在有 <code>NULL</code> 值的情况下返回永远为空结果 查询容易出错.</p>
</li>
<li>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html">参考链接-IS NULL Optimization</a></p>
</li>
</ul>
<h3 id="810-索引失效的场景">8.10 索引失效的场景</h3>
<p><em>注意: 部分情形可能实际中并非如此, 在实际环境中应该多使用explain语句来检查索引的使用情况.</em></p>
<ul>
<li>
<p>查询条件包含<code>or</code> 可能导致索引失效.(多条件可转为<code>union all</code>和间接实现)</p>
</li>
<li>
<p>字段类型是字符串 <code>where</code>时一定用引号括起来 否则索引失效(数字/字符串, 不加与区分, 也能返回正确的结果, 但是在使用索引上有所差异).</p>
</li>
<li>
<p><code>like</code>通配符可能导致索引失效.</p>
</li>
<li>
<p>联合索引 查询时的条件列不是联合索引中的第一个列 索引失效.</p>
</li>
<li>
<p>在索引列上使用<code>mysql</code>的<code>内置函数</code>, 索引失效.</p>
</li>
<li>
<p>对索引列<code>运算</code>(如 + - * /), 索引可能失效.</p>
<pre><code class="language-bash">mysql&gt; explain select id from next where id + 1 &gt; 4;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra
                   |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | next  | NULL       | index | NULL          | PRIMARY | 4       | NULL |    6 |   100.00 | Using
where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.01 sec)
</code></pre>
</li>
<li>
<p>索引字段上使用( ! = 或者 &lt; &gt; not in) 时, 可能会导致索引失效.</p>
</li>
<li>
<p>索引字段上使用<code>is null</code>, <code>is not null</code> 可能导致索引失效.</p>
</li>
<li>
<p>左连接查询或者右连接查询查询关联的字段编码格式不一样 可能导致索引失效.</p>
</li>
<li>
<p><code>mysql</code>估计使用全表扫描要比使用索引快,则不使用索引.</p>
</li>
</ul>
<h2 id="九-explain解析">九. explain解析</h2>
<pre><code class="language-bash"># format
# json
mysql&gt; explain format=json select * from user_trade limit 10\G
*************************** 1. row ***************************
EXPLAIN: {
  &quot;query_block&quot;: {
    &quot;select_id&quot;: 1,
    &quot;cost_info&quot;: {
      &quot;query_cost&quot;: &quot;80.85&quot;
    },
    &quot;table&quot;: {
      &quot;table_name&quot;: &quot;user_trade&quot;,
      &quot;access_type&quot;: &quot;ALL&quot;,
      &quot;rows_examined_per_scan&quot;: 796,
      &quot;rows_produced_per_join&quot;: 796,
      &quot;filtered&quot;: &quot;100.00&quot;,
      &quot;cost_info&quot;: {
        &quot;read_cost&quot;: &quot;1.25&quot;,
        &quot;eval_cost&quot;: &quot;79.60&quot;,
        &quot;prefix_cost&quot;: &quot;80.85&quot;,
        &quot;data_read_per_join&quot;: &quot;118K&quot;
      },
      &quot;used_columns&quot;: [
        &quot;user_name&quot;,
        &quot;piece&quot;,
        &quot;price&quot;,
        &quot;pay_amount&quot;,
        &quot;goods_category&quot;,
        &quot;pay_time&quot;
      ]
    }
  }
}
1 row in set, 1 warning (0.00 sec)
</code></pre>
<pre><code class="language-bash">mysql&gt; explain select * from gps where name = 'alex' and id=1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | gps   | NULL       | const | PRIMARY       | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<table>
<thead>
<tr>
<th>列名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>执行编号 标识<code>select</code>所属的行. 如果在语句中没子查询或关联查询 只有唯一的select 每行都将显示1. 否则, 内层的<code>select</code>语句一般会顺序编号, 对应于其在原始语句中的位置.</td>
</tr>
<tr>
<td>select_type</td>
<td>显示本行是简单或复杂<code>select</code>. 如果查询有任何复杂的子查询 则最外层标记为PRIMARY( <code>DERIVED</code>, <code>UNION</code>, <code>UNION RESUlT</code>)</td>
</tr>
<tr>
<td>table</td>
<td>访问引用哪个表( 引用某个查询 如&quot;gps&quot;)</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>数据访问/读取操作类型( ALL index range ref eq_ref const/system NULL)</td>
</tr>
<tr>
<td>possible_keys</td>
<td>哪一些索引可能有利于高效的查找</td>
</tr>
<tr>
<td>key</td>
<td>显示mysql决定采用哪个索引来优化查询</td>
</tr>
<tr>
<td>key_len</td>
<td>显示mysql在索引里使用的字节数</td>
</tr>
<tr>
<td>ref</td>
<td>显示了之前的表在key列记录的索引中查找值所用的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>为了找到所需的行而需要读取的行数 估算值 不精确. 通过把所有rows列值相乘 可粗略估算整个查询会检查的行数</td>
</tr>
<tr>
<td>Extra</td>
<td>额外信息 如using index filesort等</td>
</tr>
</tbody>
</table>
<h3 id="91-id">9.1 id</h3>
<p>id是用来顺序标识整个查询中<code>SELELCT</code> 语句的 在嵌套查询中<code>id</code>越大的语句越先执行. 该值可能为<code>NULL</code>. 如果这一行用来说明的是其他行的联合结果.</p>
<h3 id="92-select_type">9.2 select_type</h3>
<p>表示查询的类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>simple</code></td>
<td>简单子查询 不包含子查询和<code>union</code></td>
</tr>
<tr>
<td><code>primary</code></td>
<td>包含union或者子查询 最外层的部分标记为<code>primary</code></td>
</tr>
<tr>
<td><code>subquery</code></td>
<td>一般子查询中的子查询被标记为<code>subquery</code> 也就是位于<code>select</code>列表中的查询</td>
</tr>
<tr>
<td><code>derived</code></td>
<td>派生表, 该临时表是从子查询派生出来的 位于form中的子查询</td>
</tr>
<tr>
<td><code>union</code></td>
<td>位于<code>union</code>中第二个及其以后的子查询被标记为<code>union</code> 第一个就被标记为<code>primary</code>如果是<code>union</code>位于<code>from</code>中则标记为<code>derived</code></td>
</tr>
<tr>
<td><code>union result</code></td>
<td>用来从匿名临时表里检索结果的<code>select</code>被标记为<code>union result</code></td>
</tr>
<tr>
<td><code>dependent union</code></td>
<td>顾名思义 首先需要满足<code>UNION</code>的条件 及<code>UNION</code>中第二个以及后面的<code>SELECT</code>语句 同时该语句依赖外部的查询</td>
</tr>
<tr>
<td><code>subquery</code></td>
<td>子查询中第一个<code>SELECT</code>语句</td>
</tr>
<tr>
<td><code>dependent subquery</code></td>
<td>和<code>DEPENDENT UNION</code>相对<code>UNION</code>一样</td>
</tr>
</tbody>
</table>
<h3 id="93-table">9.3 table</h3>
<p>对应行正在访问哪一个表 表名或者别名</p>
<ul>
<li>关联优化器会为查询选择关联顺序 左侧深度优先</li>
<li>当<code>from</code>中有子查询的时候 表名是<code>derivedN</code>的形式 <code>N</code>指向子查询 也就是<code>explain</code>结果中的下一列</li>
<li>当有<code>union result</code>的时候 表名是<code>union 1,2</code>等的形式 1,2表示参与<code>union</code>的<code>query id</code></li>
</ul>
<p>注意: <code>MySQL</code>对待这些表和普通表一样 但是这些 &quot;临时表&quot; 是没有任何索引的.</p>
<h3 id="94-type">9.4 type</h3>
<p>type显示的是访问类型 是较为重要的一个指标 结果值从好到坏依次是:<br>
<code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code> , 一般来说 得保证查询至少达到<code>range</code>级别 最好能达到<code>ref</code>.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>All</td>
<td>最坏的情况,全表扫描</td>
</tr>
<tr>
<td>index</td>
<td>和全表扫描一样. 只是扫描表的时候按照索引次序进行而不是行. 主要优点就是避免了排序, 但是开销仍然非常大. 如在Extra列看到Using index 说明正在使用覆盖索引 只扫描索引的数据 它比按索引次序全表扫描的开销要小很多</td>
</tr>
<tr>
<td>range</td>
<td>范围扫描 一个有限制的索引扫描. key 列显示使用了哪个索引. 当使用=  &lt;&gt; &gt; &gt;= &lt; &lt;= IS NULL &lt;=&gt; BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range</td>
</tr>
<tr>
<td>ref</td>
<td>一种索引访问 它返回所有匹配某个单个值的行. 此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生. 这个类型跟eq_ref不同的是 它用在关联操作只使用了索引的最左前缀 或者索引不是UNIQUE和PRIMARY KEY. ref可以用于使用=或&lt;=&gt;操作符的带索引的列.</td>
</tr>
<tr>
<td>eq_ref</td>
<td>最多只返回一条符合条件的记录. 使用唯一性索引或主键查找时会发生 ( 高效)</td>
</tr>
<tr>
<td>const</td>
<td>当确定最多只会有一行匹配的时候 <code>MySQL</code>优化器会在查询前读取它而且只读取一次 因此非常快. 当主键放入<code>where</code>子句时 <code>mysql</code>把这个查询转为一个常量( 高效)</td>
</tr>
<tr>
<td>system</td>
<td>这是<code>const</code>连接类型的一种特例 表仅有一行满足条件.</td>
</tr>
<tr>
<td>Null</td>
<td>意味说<code>mysql</code>能在优化阶段分解查询语句 在执行阶段甚至用不到访问表或索引( 高效)</td>
</tr>
</tbody>
</table>
<h3 id="95-possible_keys">9.5 possible_keys</h3>
<p>显示查询使用了哪些索引 表示该索引可以进行高效地查找 但是列出来的索引对于后续优化过程可能是没有用的</p>
<h3 id="96-key">9.6 key</h3>
<p><code>key</code>列显示<code>MySQL</code>实际决定使用的键( 索引) . 如果没有选择索引 键是<code>NULL</code>. 要想强制<code>MySQL</code>使用或忽视<code>possible_keys</code>列中的索引 在查询中使用<code>FORCE INDEX</code> <code>USE INDEX</code>或者<code>IGNORE INDEX</code>.</p>
<h3 id="97-key_len">9.7 key_len</h3>
<p><code>key_len</code>列显示<code>MySQL</code>决定使用的键长度. 如果键是<code>NULL</code> 则长度为<code>NULL</code>. 使用的索引的长度. 在不损失精确性的情况下 长度越短越好 .</p>
<h3 id="98-ref">9.8 ref</h3>
<p><code>ref</code>列显示使用哪个列或常数与<code>key</code>一起从表中选择行.</p>
<h3 id="99-rows">9.9 rows</h3>
<p><code>rows</code>列显示<code>MySQL</code>认为它执行查询时必须检查的行数. 注意这是一个预估值.</p>
<h3 id="910-extra">9.10 Extra</h3>
<p><code>Extra</code>是<code>EXPLAIN</code>输出中另外一个很重要的列 该列显示<code>MySQL</code>在查询过程中的一些详细信息 <code>MySQL</code>查询优化器执行查询的过程中对查询计划的重要补充信息.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using filesort</td>
<td><code>MySQL</code>有两种方式可以生成有序的结果 通过排序操作或者使用索引 当Extra中出现了<code>Using filesort</code> 说明<code>MySQL</code>使用了后者 但注意虽然叫<code>filesort</code>但并不是说明就是用了文件来进行排序 只要可能排序都是在内存里完成的. 大部分情况下利用索引排序更快 所以一般这时也要考虑优化查询了. 使用文件完成排序操作 这是可能是ordery by group by语句的结果 这可能是一个CPU密集型的过程 可以通过选择合适的索引来改进性能 用索引来为查询结果排序.</td>
</tr>
<tr>
<td>Using temporary</td>
<td>用临时表保存中间结果 常用于<code>GROUP BY</code> 和 <code>ORDER BY</code>操作中 一般看到它说明查询需要优化了 就算避免不了临时表的使用也要尽量避免硬盘临时表的使用.</td>
</tr>
<tr>
<td>Not exists</td>
<td>MYSQL优化了LEFT JOIN 一旦它找到了匹配<code>LEFT JOIN</code>标准的行  就不再搜索了.</td>
</tr>
<tr>
<td>Using index</td>
<td>说明查询是覆盖了索引的 不需要读取数据文件 从索引树( 索引文件) 中即可获得信息. 如果同时出现using where 表明索引被用来执行索引键值的查找 没有using where 表明索引用来读取数据而非执行查找动作. 这是MySQL服务层完成的 但无需再回表查询记录.</td>
</tr>
<tr>
<td>Using index condition</td>
<td>这是<code>MySQL 5.6</code>出来的新特性 叫做&quot; 索引条件推送&quot; . 简单说一点就是<code>MySQL</code>原来在索引上是不能执行如like这样的操作的 但是现在可以了 这样减少了不必要的IO操作 但是只能用在二级索引上.</td>
</tr>
<tr>
<td>Using where</td>
<td>使用了<code>WHERE</code>从句来限制哪些行将与下一张表匹配或者是返回给用户. <strong>注意</strong>: Extra列出现<code>Using where</code>表示<code>MySQL</code>服务器将存储引擎返回服务层以后再应用WHERE条件过滤.</td>
</tr>
<tr>
<td>Using join buffer</td>
<td>使用了连接缓存: <code>Block Nested Loop</code> 连接算法是块嵌套循环连接;<code>Batched Key Access</code> 连接算法是批量索引连接</td>
</tr>
<tr>
<td>impossible where</td>
<td><code>where</code>子句的值总是<code>false</code> 不能用来获取任何元组</td>
</tr>
<tr>
<td>select tables optimized away</td>
<td>在没有GROUP BY子句的情况下 基于索引优化MIN/MAX操作 或者对于MyISAM存储引擎优化COUNT(*)操作 不必等到执行阶段再进行计算 查询执行计划生成的阶段即完成优化.</td>
</tr>
<tr>
<td>distinct</td>
<td>优化<code>distinct</code>操作 在找到第一匹配的元组后即停止找同样值的动作</td>
</tr>
</tbody>
</table>
<h3 id="911-1-查看性能">9.11 1 查看性能</h3>
<pre><code class="language-bash"># profile
# 开启检测
SET SESSION profiling = 1;
# do something
select * from test;
# 查看执行的速度
mysql&gt; SHOW PROFILES;
+----------+------------+-----------------------------------------------------------------------------------------------------+
| Query_ID | Duration   | Query
          |
+----------+------------+-----------------------------------------------------------------------------------------------------+
|        1 | 0.00107400 | SELECT DATABASE()
          |
|        2 | 0.00329250 | show databases
          |
|        3 | 0.00131350 | show tables
          |
|        4 | 0.00120475 | show tables
          |
|        5 | 0.00488875 | select count(*) from  tb_emp_bigdata
          |
|        6 | 0.00027975 | select * from tb_emp_bigdata limit 20
          |
|        7 | 0.03996850 | select *from tb_emp_bigdata A where A.deptno in (select B.deptno from tb_dept_bigdata B)
          |
|        8 | 0.04442800 | select *from tb_emp_bigdata A where exists(select 1 from tb_dept_bigdata B where B.deptno=A.deptno) |
+----------+------------+-----------------------------------------------------------------------------------------------------+

# --- 单条语句可以使用
mysql&gt; explain analyze select * from test_table where exists (select 1 from test_a where test_a.col = test_table.col);

| EXPLAIN
| -&gt; Inner hash join (test_table.col = `&lt;subquery2&gt;`.col)  (cost=5008925664.64 rows=5008894001) (actual time=952.272..952.272 rows=0 loops=1)
    -&gt; Table scan on test_table  (cost=30976.71 rows=997152) (actual time=0.018..395.888 rows=1000000 loops=1)
    -&gt; Hash
        -&gt; Table scan on &lt;subquery2&gt;  (cost=10102.66..10733.05 rows=50232) (actual time=39.797..43.171 rows=49865 loops=1)
            -&gt; Materialize with deduplication  (cost=10102.65..10102.65 rows=50232) (actual time=39.796..39.796 rows=49865 loops=1)
                -&gt; Filter: (test_a.col is not null)  (cost=5079.45 rows=50232) (actual time=0.019..24.711 rows=50000 loops=1)
                    -&gt; Table scan on test_a  (cost=5079.45 rows=50232) (actual time=0.018..22.378 rows=50000 loops=1)
1 row in set, 1 warning (0.96 sec)

mysql&gt; show warnings;
+-------+------+------------------------------------------------------------------------------------+
| Level | Code | Message                                                                            |
+-------+------+------------------------------------------------------------------------------------+
| Note  | 1276 | Field or reference 'test_db.test_table.col' of SELECT #2 was resolved in SELECT #1 |
+-------+------+------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
<p>这种方法已经被废弃, 等待删除. 将使用<code>Performance Schema</code>替代这个功能.</p>
<ul>
<li><a href="https://blog.csdn.net/solinger/article/details/122300008">参考链接_Mysql Performance_schema简介, 表和常用性能查询</a></li>
</ul>
<h2 id="十-基本使用">十. 基本使用</h2>
<figure data-type="image" tabindex="33"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/qmueOKvY16H1wVNnmc6HsYpjURUDudMrBR52ScZucJsaGPWxZhGsibrpW0zOlvXXAIK98KRPMVtCITdyuOerGXA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="640.png" loading="lazy"></figure>
<ul>
<li>
<p>DDL, data definition language, 数据定义语言</p>
<p>主要用于<strong>维护存储数据的结构</strong>, 这种结构包括数据库, 表, 视图, 索引, 聚簇等.</p>
<p>常用命令:</p>
<ul>
<li><code>create</code> 创建数据库和数据库的一些对象</li>
<li><code>drop</code> 删除数据库/表, 索引, 条件约束以及数据表的权限等</li>
<li><code>alter</code> 修改数据库表的定义及数据属性</li>
</ul>
</li>
<li>
<p>DML, data management language, 数据管理语言</p>
<p>主要用于对数据库对象中包含的<strong>数据进行操作</strong></p>
<p>常用命令:</p>
<ul>
<li><code>insert</code> 向数据库中插入一条数据</li>
<li><code>delete</code> 删除表中的一条或者多条记录</li>
<li><code>updata</code> 修改表中的数据</li>
</ul>
</li>
<li>
<p>DQL, data query language, 数查询语言</p>
<p>主要用于<strong>查询</strong>数据库当中的数据</p>
<p>常用命令</p>
<ul>
<li><code>selete</code> 查询表中的数据</li>
<li><code>from</code> 查询哪张表 视图</li>
<li><code>where</code> 约束条件</li>
</ul>
</li>
<li>
<p>DCL, data control language, 数据库控制语言</p>
<p>主要控制数据库对象的<strong>用户管理</strong>, <strong>权限管理</strong> <strong>事务</strong>和<strong>实时监视</strong>.</p>
<p>常用命令:</p>
<ul>
<li><code>grant</code>分配权限给用户</li>
<li><code>revoke</code>撤回数据库中某用户的权限</li>
<li><code>rollback</code> 回滚</li>
<li><code>commit</code> 事务提交</li>
</ul>
</li>
</ul>
<p>注意: <code>commit</code></p>
<p>在数据库的插入 删除和修改操作时 只有当事务在提交到数据库时才算完成. 在事务提交前 只有操作数据库的这个人才能有权看到所做的事情 别人只有在最后提交完成后才可以看到. 提交数据有三种类型: <code>显式提交</code> <code>隐式提</code>交及<code>自动提交</code>.</p>
<ul>
<li>
<p>显式提交<br>
用<code>commit</code>命令直接完成的提交为显式提交. <code>commit</code>;</p>
</li>
<li>
<p>隐式提交<br>
用<code>SQL</code>命令间接完成的提交为隐式提交, 这些命令有:</p>
<p><code>alter</code> <code>audit</code> <code>comment</code> <code>connect</code> <code>create</code> <code>disconnect</code> <code>drop</code> <code>exit</code> <code>grant</code> <code>noaudit</code> <code>quit</code> <code>revoke</code> <code>rename</code>.</p>
<pre><code class="language-bash"> # session a
 set autocommit = 0;
 # 删除掉主键
 alter table next drop primary key;

 # session b
mysql&gt; desc next;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int unsigned | NO   |     | NULL    |       |
| name  | char(4)      | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre>
</li>
<li>
<p>自动提交<br>
若把<code>autocommit</code>设置为<code>on(1)</code> 则在插入 修改 删除语句执行后 系统将自动进行提交. <code>set autocommit on;</code></p>
</li>
</ul>
<h3 id="101-增">10.1 增</h3>
<ul>
<li>
<p>数据库</p>
<pre><code class="language-mysql">-- 创建数据库, 一般情况下默认database的创建参数即可, 如字符集, 引擎等.
CREATE DATABASE [IF NOT EXISTS] database_name;
create database db_name;
</code></pre>
</li>
<li>
<p>表</p>
<pre><code class="language-mysql">-- 创建表
create table tb_name (column_name column_type);
create table [IF NOT EXISTS] tb_name (column_name column_type);

# 复制表的结构方式进行创建表
mysql&gt; desc next;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int unsigned | NO   | PRI | NULL    |       |
| name  | char(4)      | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql&gt; create table copy_t as select * from next where 1 &lt;&gt; 1;
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc copy_t;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int unsigned | NO   |     | NULL    |       |
| name  | char(4)      | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre>
</li>
<li>
<p>字段</p>
<pre><code class="language-mysql">alter table test_s add address varchar(10) not null;
# 等价
alter table test_s add column gender char(1) not null;

# 将心增加的列添加到第一列
alter table test_s add country char(10) not null first;
# 将新增的列添加到id列之后
alter table test_s add school char(10) not null after id;
</code></pre>
</li>
<li>
<p>行</p>
<pre><code class="language-mysql">INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );
# 当插入的内容和字段完全对应时, 可以省略字段名称
INSERT INTO table_name VALUES ( value1, value2,...valueN );

# 插入时忽视错误
INSERT IGNORE INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );
# 查看错误
show warnings;

mysql&gt; insert ignore into test_s values (1, 't');
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; show warnings;
+---------+------+----------------------------------------------+
| Level   | Code | Message                                      |
+---------+------+----------------------------------------------+
| Warning | 1062 | Duplicate entry '1' for key 'test_s.PRIMARY' |
+---------+------+----------------------------------------------+
1 row in set (0.00 sec)

# 插入多条数据
INSERT INTO employee(emp_id, emp_name, sex, dept_id, manager, hire_date, job_id, salary, bonus, email)
VALUES ( 27, '李四', '女', 5, 18, current_date, 10, 6000, NULL, 'lisi@shuguo.com'),
       ( 28, '王五', '男', 5, 18, current_date, 10, 6500, NULL, 'wangwu@shuguo.com'),
       ( 29, '赵六', '女', 5, 18, current_date, 10, 6700, NULL, 'zhaoliu@shuguo.com');

# 使用replace into 也能插入数据
replace into test_s (id,name) values(5,'aa'),(6,'bb');
</code></pre>
</li>
</ul>
<h3 id="102-删">10.2 删</h3>
<ul>
<li>
<p>数据库</p>
<pre><code class="language-mysql">drop database db_name;
</code></pre>
</li>
<li>
<p>表</p>
<pre><code class="language-mysql">drop table table_name;
</code></pre>
</li>
<li>
<p>字段</p>
<pre><code class="language-mysql">alter table drop col_name;
</code></pre>
</li>
<li>
<p>行</p>
<pre><code class="language-mysql">DELETE FROM table_name [WHERE Clause]
-- delete, 大批量的数据删除, 会导致缓存表占用超出缓存大小.
-- truncate, 将整个表的数据清空, 实际上是复制表结构, 将原来的整个表删掉.
</code></pre>
</li>
</ul>
<h3 id="103-改">10.3 改</h3>
<ul>
<li>
<p>数据库</p>
<pre><code class="language-mysql">-- 不支持直接修改名称之类的操作
-- 将数据导出来
-- 将数据添加到新的数据库
-- 操作见数据备份
</code></pre>
</li>
<li>
<p>表</p>
<pre><code class="language-mysql">-- 重命名表名称
RENAME TABLE old_table_name TO new_table_name;
</code></pre>
</li>
<li>
<p>字段</p>
<pre><code class="language-mysql">-- change, 改名称, 改数据类型
-- modify, 改数据类型

# 修改字段的数据类型
alter table test_s modify gender char(2);

# 修改字段的名称和数据类型
alter table test_s change country nation varchar(5);
</code></pre>
</li>
<li>
<p>行</p>
<pre><code class="language-mysql">-- update
-- on duplicate key update
-- replace

UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]

-- REPLACE(string, from_string, new_string)
-- 修改name字段的所有内容, 将'te' 全部改成 'ab'
UPDATE test_s SET name=replace(name, 'te', 'ab');

# 没有数据, 则插入数据, 有, 则变更
replace into test_s (id,name) values(5,'cc'),(6,'ee');
mysql&gt; select * from test_s;
+----+------+
| id | name |
+----+------+
|  1 | alex |
|  1 | abst |
|  2 | tony |
|  3 | abs  |
|  5 | aa   |
|  6 | bb   |
+----+------+
6 rows in set (0.00 sec)

#
mysql&gt; replace into test_s (id,name) values(5,'cc'),(6,'ee');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; select * from test_s;
+----+------+
| id | name |
+----+------+
|  1 | alex |
|  1 | abst |
|  2 | tony |
|  3 | abs  |
|  5 | aa   |
|  6 | bb   |
|  5 | cc   |
|  6 | ee   |
+----+------+
8 rows in set (0.00 sec

mysql&gt; desc test_s;
+-------+---------+------+-----+---------+----------------+
| Field | Type    | Null | Key | Default | Extra          |
+-------+---------+------+-----+---------+----------------+
| id    | int     | NO   | PRI | NULL    | auto_increment |
| name  | char(4) | YES  |     | NULL    |                |
+-------+---------+------+-----+---------+----------------+

mysql&gt; select * from test_s;
+----+------+
| id | name |
+----+------+
|  1 | alex |
|  2 | abst |
|  3 | to   |
|  4 | abs  |
|  5 | aa   |
|  6 | bb   |
|  7 | cc   |
|  8 | ee   |
+----+------+

# 注意这里的插入, name, char(4), 但是没办法插入数据, 尽管后面的if语句返回的数据长度为4
mysql&gt; INSERT INTO test_s (id, name)
    -&gt; VALUES (3, 'jupyter')
    -&gt; ON DUPLICATE KEY UPDATE name = if(length(values(name)) &gt; 4, substring(values(name), 1, 4), values(name));
ERROR 1406 (22001): Data too long for column 'name' at row 1

# 将name的长度改为7, 则可以修改
# -&gt; 推测修改, 是先进行values的数据的校检, 才会执行后续, 由于jupyter的长度大于4, 则先执行报错, 而不是先执行if语句的数据返回再进行校检.

# 索引没有使用?
mysql&gt; explain INSERT INTO test_s (id, name)
    -&gt; VALUES (3, 'jupyter')
    -&gt; ON DUPLICATE KEY UPDATE name = if(length(values(name)) &gt; 4, substring(values(name), 1, 4), values(name));
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | INSERT      | test_s | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | NULL  |
</code></pre>
</li>
</ul>
<h2 id="十一-关键字">十一. 关键字</h2>
<h3 id="111-changemodify">11.1 change/modify</h3>
<ul>
<li>modify, 只能修改字段的数据类型</li>
<li>change, 既能改数据类型, 也能改字段的名称.</li>
</ul>
<pre><code class="language-mysql"># 修改字段的数据类型
alter table test_s modify gender char(2);
# 修改字段的名称和数据类型
alter table test_s change country nation varchar(5);
</code></pre>
<h3 id="112-between">11.2 between</h3>
<pre><code class="language-mysql">mysql&gt; select * from next where id between 1 and 3;
+----+------+
| id | name |
+----+------+
|  1 | alex |
|  3 | ciy  |
|  2 | tom  |
+----+------+
# where column_name between a and b, include a and b(包括两个条件端点)

# 索引的使用
mysql&gt; explain select id from next where id between 3 and 7;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra
                   |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | next  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    4 |   100.00 | Using
where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select id from next where id &gt; 3 and id &lt; 7;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra
                   |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | next  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using
where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h3 id="113-inexists">11.3 in/exists</h3>
<blockquote>
<p>当列表中的值都是常量时 <code>MySQL</code>执行以下步骤:</p>
<ul>
<li>首先 评估基于所述值<a href="https://www.begtut.com/mysql/mysql-data-types.html">类型</a>的的<code>column_1</code>所述的或<code>expr </code>表达的结果 .</li>
<li>其次 对值进行排序.</li>
<li>第三 使用二进制搜索算法搜索值. 因此 使用<code>IN</code> 运算符查询执行带有常量列表的速度非常快.</li>
</ul>
</blockquote>
<p><code>exists</code>用于对外表记录做筛选. <code>exists</code>会遍历外表 将外查询表的每一行 代入内查询进行判断. 当<code>exists</code>里的条件语句能够返回记录行时 条件就为真 返回外表当前记录. 反之如果<code>exists</code>里的条件语句不能返回记录行 条件为假 则外表当前记录被丢弃.</p>
<pre><code>select a.* from A a where exists(select 1 from B b where a.id=b.id)
</code></pre>
<p><code>in</code>是先把后边的语句查出来放到临时表中, 然后遍历临时表 将临时表的每一行, 代入外查询去查找.</p>
<pre><code>select * from Awhere id in(select id from B);
</code></pre>
<p>子查询的表比较大的时候 使用<code>exists</code>可以有效减少总的循环次数来提升速度; 当外查询的表比较大的时候 使用<code>in</code>可以有效减少对外查询表循环遍历来提升速度.</p>
<pre><code class="language-bash">mysql&gt; select * from next where name in ('alex', 'ciy');
+----+------+
| id | name |
+----+------+
|  1 | alex |
|  3 | ciy  |
+----+------+
2 rows in set (0.01 sec)
# 反之, NOT IN

# 索引的使用
mysql&gt; explain select id from next where id in (1, 7);
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra
                   |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | next  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using
where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<p>注意当 <code>in</code> (<code>condition</code>/条件) 中存在 <code>null</code> 值时出现的异常现象</p>
<pre><code class="language-bash">create table t4(c1 int,c2 int);

create table t5 (c1 int,c2 int);

insert into t4 values(1,2);

insert into t4 values(1,3);

insert into t5 values(1,2);

insert into t5 values(1,null);

# 当null存在
select * from t4 where c2 not in(select c2 from t5);
# empty set

mysql&gt; select * from t5;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    2 |
|    1 | NULL |
+------+------+
2 rows in set (0.00 sec)

# 将这里的 null 去掉
mysql&gt; update t5 set c2 = 4 where c2 is null;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from t5;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    2 |
|    1 |    4 |
+------+------+
2 rows in set (0.00 sec)

mysql&gt; select * from t4 where t4.c2 not in(select t5.c2 from t5);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    3 |
+------+------+
1 row in set (0.00 sec)
# ----------------------------------------------------------------------------------

select * from t4 where not exists(select 1 from t5 where t5.c2=t4.c2);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    3 |
+------+------+
1 row in set (0.00 sec)

# -------------------------------------
select * from employees where hire_date in (select distinct hire_date from employees order by hire_date limit 3, 1);
ERROR 1235 (42000): This version of MySQL doesn't yet support 'LIMIT &amp; IN/ALL/ANY/SOME subquery'
</code></pre>
<ul>
<li><a href="https://stackoverflow.com/questions/6362112/in-clause-with-null-or-is-null">IN Clause with NULL or IS NULL</a></li>
</ul>
<h3 id="114-andor">11.4 and/or</h3>
<pre><code class="language-bash">mysql&gt; explain select * from next where id = 7 or (id = 3 and id = 5);
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | next  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h3 id="115-havingwhere">11.5 having/where</h3>
<p><code>having</code>解决<code>where</code>无法和聚合函数一exit起使用的问题.</p>
<pre><code class="language-bash">mysql&gt; select count(*) as c from sales group by sales_employee;
+---+
| c |
+---+
| 3 |
| 3 |
| 3 |
+---+
3 rows in set (0.00 sec)

mysql&gt; select count(*) as c from sales group by sales_employee having c &gt; 1;
+---+
| c |
+---+
| 3 |
| 3 |
| 3 |
+---+
3 rows in set (0.00 sec)

mysql&gt; select count(*) as c from sales group by sales_employee where c &gt; 1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use
near 'where c &gt; 1' at line 1
</code></pre>
<h3 id="116-group-byrollup">11.6 group by/rollup</h3>
<ul>
<li><code>rollup</code>, 相当于增加一个小计和合计的扩展.</li>
</ul>
<pre><code class="language-bash">mysql&gt; SELECT year, country, product, SUM(profit) AS profit
    -&gt;        FROM sales_a
    -&gt;        GROUP BY year, country, product;
+------+---------+------------+--------+
| year | country | product    | profit |
+------+---------+------------+--------+
| 2000 | Finland | Computer   |   1500 |
| 2000 | India   | Calculator |    150 |
| 2000 | India   | Computer   |   1200 |
| 2000 | Finland | Phone      |    100 |
| 2001 | USA     | Calculator |     50 |
| 2001 | USA     | Computer   |   2700 |
| 2001 | USA     | TV         |    250 |
| 2000 | USA     | Calculator |     75 |
| 2000 | USA     | Computer   |   1500 |
| 2001 | Finland | Phone      |     10 |
+------+---------+------------+--------+
10 rows in set (0.00 sec)

# rollup 进一步扩展和合并的数据类型
mysql&gt; SELECT year, country, product, SUM(profit) AS profit
    -&gt;        FROM sales_A
    -&gt;        GROUP BY year, country, product WITH ROLLUP;
ERROR 1146 (42S02): Table 'test_db.sales_A' doesn't exist
mysql&gt; SELECT year, country, product, SUM(profit) AS profit
    -&gt;        FROM sales_a
    -&gt;        GROUP BY year, country, product WITH ROLLUP;
+------+---------+------------+--------+
| year | country | product    | profit |
+------+---------+------------+--------+
| 2000 | Finland | Computer   |   1500 |
| 2000 | Finland | Phone      |    100 |
| 2000 | Finland | NULL       |   1600 |
| 2000 | India   | Calculator |    150 |
| 2000 | India   | Computer   |   1200 |
| 2000 | India   | NULL       |   1350 |
| 2000 | USA     | Calculator |     75 |
| 2000 | USA     | Computer   |   1500 |
| 2000 | USA     | NULL       |   1575 |
| 2000 | NULL    | NULL       |   4525 |
| 2001 | Finland | Phone      |     10 |
| 2001 | Finland | NULL       |     10 |
| 2001 | USA     | Calculator |     50 |
| 2001 | USA     | Computer   |   2700 |
| 2001 | USA     | TV         |    250 |
| 2001 | USA     | NULL       |   3000 |
| 2001 | NULL    | NULL       |   3010 |
| NULL | NULL    | NULL       |   7535 |
+------+---------+------------+--------+
18 rows in set (0.00 sec)

| 2000 | Finland | NULL       |   1600
# 芬兰 2000 年的总和
| 2000 | NULL    | NULL       |   4525 |
# 所有项的 2000 年的总和
| NULL | NULL    | NULL       |   7535 |
# 全部的总和
</code></pre>
<h3 id="117-deletetruncate">11.7 delete/truncate</h3>
<p>删除表格内容, 注意这里的删除在<code>InnoDB</code>下, 实际上并不执行真真意义上的删除操作, 而是采用标记的方式, 标记要删除的位置, 当有新的数据插入到相应的位置时, 直接使用标记的位置, 复用, 减少对表格结构的影响.</p>
<pre><code class="language-mysql">-- 删除表格的全部数据
-- 假如表特别大, 会导致超出临时表大小错误
delete from table [where ...];
</code></pre>
<p>要想回收这部分被标记删除的表空间可以使用:</p>
<pre><code class="language-mysql">ALTER TABLE table_name ENGINE=INNODB;
# 或者是
OPTIMIZE TABLE table_name;
</code></pre>
<p>二者的区别, 简单理解, 在于, <code>ALTER</code>是<code>recreate</code>, 而<code>optimize</code>是<code>recreate + analyze</code>.</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html"><code>OPTIMIZE TABLE</code></a> works for <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html"><code>InnoDB</code></a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html"><code>MyISAM</code></a>, and <a href="https://dev.mysql.com/doc/refman/5.7/en/archive-storage-engine.html"><code>ARCHIVE</code></a> tables. <a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html"><code>OPTIMIZE TABLE</code></a> is also supported for dynamic columns of in-memory <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"><code>NDB</code></a> tables. It does not work for fixed-width columns of in-memory tables, nor does it work for Disk Data tables. The performance of <code>OPTIMIZE</code> on NDB Cluster tables can be tuned using <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-options-variables.html#option_mysqld_ndb-optimization-delay"><code>--ndb-optimization-delay</code></a>, which controls the length of time to wait between processing batches of rows by <a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html"><code>OPTIMIZE TABLE</code></a>. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-limitations-resolved.html">Previous NDB Cluster Issues Resolved in NDB Cluster 8.0</a>.</p>
<p>针对的引擎</p>
</blockquote>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html">optimize</a></li>
</ul>
<p>实际上并不是逐行删除数据, 而是直接删除表格, 然后重建新的表格, 不支持事务(应该理解为自动执行<code>commit</code>).</p>
<p><code>truncate</code> 和 <code>delete</code> 的区别</p>
<p>从逻辑上说 <code>TRUNCATE</code> 语句与 <code>DELETE</code> 语句作用相同 但是在某些情况下 两者在使用上有所区别.</p>
<ul>
<li><code>DELETE</code> 是 <code>DML</code> 类型的语句; <code>TRUNCATE</code> 是 <code>DDL</code> 类型的语句. 它们都用来清空表中的数据.</li>
<li><code>DELETE</code> 是逐行一条一条删除记录的; <code>TRUNCATE</code> 则是直接删除原来的表 再重新创建一个一模一样的新表 而不是逐行删除表中的数据 执行数据比 <code>DELETE</code> 快. 因此需要删除表中全部的数据行时 尽量使用 <code>TRUNCATE</code> 语句  可以缩短执行时间.</li>
<li><code>DELETE</code> 删除数据后 配合事件回滚可以找回数据; <code>TRUNCATE</code> <strong>不支持事务</strong>的回滚 数据删除后无法找回.</li>
<li><code>DELETE</code> 删除数据后 系统不会重新设置自增字段的计数器; <code>TRUNCATE</code> 清空表记录后 系统会重新设置自增字段的计数器.</li>
<li><code>DELETE</code> 的使用范围更广 因为它可以通过 <code>WHERE</code> 子句指定条件来删除部分数据; 而 <code>TRUNCATE</code> 不支持 <code>WHERE</code> 子句 只能删除整体.</li>
<li><code>DELETE</code> 会返回删除数据的行数 但是 <code>TRUNCATE</code> 只会返回 0 没有任何意义.</li>
</ul>
<h3 id="118-collate">11.8 collate</h3>
<p>这个关键字在涉及到数据库排序上, 需要注意, 如大小写, 中英文等.</p>
<blockquote>
<p><code>MySQL collation</code>是一系列的<code>rules</code>, 用来在特定<code>character set</code>中比较字符. <code>MySQL</code>中支持很多字符集, 而每种字符集会存在多种<code>collation</code>, 并默认选择一种. 字符串比较作用于字符串类型的列, 如<code>VARCHAR,CHAR,TEXT</code>. <code>Collation</code>会影响到<code>ORDER BY, Where, distinct, group by, having</code>以及字符串索引.</p>
<p><code>collation</code>中一般以&quot;_ci&quot;, &quot;_cs&quot;,&quot;_bin&quot;结尾, 其中, ci表示case insensitive, <code>cs</code>表示<code>case sensitive</code>, <code>bin</code>表示<code>binary</code>. 项目中使用<code>charset utf8</code>并使用其<code>collation utf8_unicode_ci</code>, 所以, 字符串比较是大小写不敏感.</p>
</blockquote>
<pre><code class="language-mysql">-- 默认的字符集和collation之间的关联
show CHARACTER SET;
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://p0.meituan.net/csc/7803440b4b82b0da51f9350d61bc534538646.png" alt="collation" loading="lazy"></figure>
<pre><code class="language-mysql">show collation;
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://p0.meituan.net/csc/9a0d0a19d6e0c0c50be6994a5853cfb142761.png" alt="collation_x" loading="lazy"></figure>
<p>优先级顺序是 <code>SQL语句 &gt; 列级别设置 &gt; 表级别设置 &gt; 库级别设置 &gt; 实例级别设置</code>.也就是说列上所指定的<code>COLLATE</code>可以覆盖表上指定的<code>COLLATE</code> 表上指定的<code>COLLAT</code>E可以覆盖库级别的<code>COLLATE</code>. 如果没有指定 则继承下一级的设置. 即列上面没有指定<code>COLLATE</code> 则该列的<code>COLLATE</code>和表上设置的一样.</p>
<pre><code class="language-mysql">SELECT k
FROM t1
ORDER BY k COLLATE latin1_german2_ci;
# 优先使用语句中的collation
</code></pre>
<p>在指定的语句下使用相应的<code>collation</code>.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/charset-collate.html">collation document</a></li>
</ul>
<h3 id="119-prepareexecutedeallocate">11.9 prepare/execute/deallocate</h3>
<p>预编译处理</p>
<ul>
<li>
<p>PREPARE</p>
</li>
<li>
<p>EXECUTE</p>
<pre><code class="language-mysql">EXECUTE stmt_name
    [USING @var_name [, @var_name] ...]
# 后面传入参数必须事变量名称
</code></pre>
</li>
<li>
<p>DEALLOCATE PREPARE</p>
</li>
</ul>
<pre><code class="language-mysql"># 动态执行, 需要使用到变量
delimiter $$
CREATE PROCEDURE rand_test_data (in table_name VARCHAR(32), in i_many int)
BEGIN
	select i_many as data_count, table_name as 'table_name';

	# 注意这里不能使用 declare cmd varchar(64);
	set @d_cmd = concat('drop table if EXISTS ', table_name, ';');

	# 将字符串编译为sql的实际可执行的语句
	PREPARE drop_table_cmd from @d_cmd;
	# 执行
	EXECUTE drop_table_cmd;
	# 删除
	DEALLOCATE PREPARE drop_table_cmd;

	set @c_cmd = CONCAT('CREATE table ', table_name, ' (id int not null PRIMARY KEY auto_increment, col varchar(32));');

	PREPARE create_table_cmd from @c_cmd;

	EXECUTE create_table_cmd;

	DEALLOCATE PREPARE create_table_cmd;
end $$
delimiter ;
</code></pre>
<blockquote>
<p>A statement prepared in stored program context cannot refer to stored procedure or function parameters or <strong>local variables</strong> because they go out of scope when the program ends and would be unavailable were the statement to be executed later outside the program. As a workaround, refer instead to user-defined variables, which also have session scope;</p>
</blockquote>
<pre><code class="language-bash">mysql&gt; select * from test_table;
+----+--------------------+
| id | col                |
+----+--------------------+
|  0 | 441053925492.851aj |
|  1 | 327509761161.6456a |
|  2 | 314387060063.3203a |
|  3 | 589406047565.3093a |
|  4 | 3869088370.2310624 |
|  5 | 251127329888.87216 |
|  6 | 244029415067.31268 |
|  7 | 466765116403.5919a |
|  8 | 601737367549.6665a |
|  9 | 608391519271.2019a |
+----+--------------------+
10 rows in set (0.00 sec)

# 预编译 - 带有参数的语句
mysql&gt; PREPARE cmd from 'select * from test_table where id = ?;';
Query OK, 0 rows affected (0.01 sec)
Statement prepared

mysql&gt; SET @test_id = 1;
Query OK, 0 rows affected (0.00 sec)

# 传入参数
mysql&gt; EXECUTE cmd USING @test_id;
+----+--------------------+
| id | col                |
+----+--------------------+
|  1 | 327509761161.6456a |
+----+--------------------+
1 row in set (0.00 sec)

mysql&gt; EXECUTE cmd using 1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use
near '1' at line 1
mysql&gt; DEALLOCATE PREPARE cmd;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<ul>
<li><a href="https://stackoverflow.com/questions/28985362/syntax-error-on-using-declare-and-prepared-statement-inside-create-procedure">Syntax Error on using DECLARE and prepared statement inside CREATE PROCEDURE</a></li>
</ul>
<h2 id="十二-函数存储过程">十二. 函数/存储过程</h2>
<p>对于<code>VBA</code>有所了解, 这二者的区别就相对容易区分.</p>
<ul>
<li><code>sub</code>, 类似于<code>PROCEDURE</code></li>
<li><code>function</code>, 则对应<code>function</code></li>
</ul>
<pre><code class="language-vb">sub t_sub()
    debug.print t_func()
end sub

function t_func() as string
    test = 'test'
end function

sub test()
    t_sub
end sub

'假如 sub t_sub 需要返回数据, 需要通过byref(按引用传递参数), 参数可以被修改, 在原函数/sub中得到这个发生变化的函数, 作为返回值.

sub t_sub(byref i as long)

end sub
</code></pre>
<p>返回值的区别.</p>
<ul>
<li>函数有1个返回值,而存储过程是通过参数返回的,可以有多个或者没有</li>
</ul>
<p>调用的区别,函数可以在查询语句中直接调用,而存储过程必须单独调用.</p>
<ul>
<li>函数: 一般情况下是用来计算并返回一个计算结果;</li>
<li>存储过程:  一般是用来完成特定的数据操作( 比如修改 插入数据库表或执行某些DDL语句等等)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">存储过程</th>
<th style="text-align:center">函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用于在数据库中完成特定的操作或者任务(如插入 删除)</td>
<td style="text-align:center">执行特定的任务, 返回数据.</td>
</tr>
<tr>
<td style="text-align:center">程序头部声明用<code>procedure</code></td>
<td style="text-align:center">程序头部声明用<code>function</code></td>
</tr>
<tr>
<td style="text-align:center">程序头部声明时不需要描述返回类型</td>
<td style="text-align:center">程序头部声明要描述返回类型 而且<code>PL/SQ</code>L块中至少要包括一个有效的<code>return</code>语句</td>
</tr>
<tr>
<td style="text-align:center">以编译后的形式存放在数据库中</td>
<td style="text-align:center">以编译后的形式存放在数据库中</td>
</tr>
<tr>
<td style="text-align:center">可以使用<code>in/out/in out</code>三种模式的参数</td>
<td style="text-align:center">不支持三种模式的参数</td>
</tr>
<tr>
<td style="text-align:center">可以作为一个独立的PL/SQL语句来执行</td>
<td style="text-align:center">不能独立执行 必须作为表达式的一部分调用</td>
</tr>
<tr>
<td style="text-align:center">可以通过<code>out /in out</code>返回零个或者多个值</td>
<td style="text-align:center">通过<code>return</code>语句返回一个值 且该值要与申明部分一致.</td>
</tr>
<tr>
<td style="text-align:center"><code>SQL</code>语句(<code>DML</code>或<code>SELECT</code>)中不可调用存储过程</td>
<td style="text-align:center"><code>SQL</code>语句(<code>DML</code>或<code>SELECT</code>)中可以调用函数</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">-- shell 中查看内容很混乱, 在navicat中, 查看
show FUNCTION STATUS;
show PROCEDURE STATUS;
</code></pre>
<h3 id="121-和">12.1 @和@@</h3>
<blockquote>
<p>@是用户变量 @@是系统变量</p>
<p>一般情况下, 变量前不加 @, 则默认为<code>session</code>变量</p>
</blockquote>
<p><code>set</code>赋值方式, 注意性能的影响</p>
<pre><code class="language-mysql">set @test_int = 1;
set @test_int := 1;
-- 二者是等价的

set @test_int = @test_int + 1;

select @test_int;
# 2

-- 设置系统层的变量
SET GLOBAL varname = some_value;

-- 查看全局变量
SHOW GLOBAL VARIABLES;
</code></pre>
<pre><code class="language-mysql">select @test_int := 1;
-- 只允许这种方式
-- =, 标识比较符号在select语句
</code></pre>
<p>和<code>declare</code>声明变量的主要区别</p>
<ul>
<li><code>declare</code>声明的变量只能在存储过程中使用, 而<code>set</code> 则不受限制.</li>
<li>变量的声明周期, <code>declare</code>相当于<code>vba</code>中的本地变量(<code>JavaScript</code>中的<code>let/const</code>), 用完就扔. <code>set</code>, <code>session</code>相当于模块级别的变量, <code>global</code>相当于<code>public</code>的全局变量, 这些变量可以一直存活, 直到<code>session</code>或者数据库退出才销毁.</li>
</ul>
<h3 id="122-delimiter">12.2 delimiter</h3>
<pre><code class="language-mysql">delimiter $$
create procedure test()
	select * from table;
	set i = 1;
	.....
end $$
delimiter ;
</code></pre>
<p><code>delimiter</code>, 间隔符, 实际上起到的作用就是将<code>mysql</code>默认的 <strong>&quot;;&quot;</strong> 符号修改为其他的符号, 如 <strong>&quot;$&quot;</strong>, 来阻止带有&quot;;&quot;符号的语句的<code>立即</code>执行.</p>
<p>默认情况下, <code>mysql</code>的间隔符为<code>;</code>, 当语句中包含这个符号, 这个语句就会马上被<code>mysql</code>执行.</p>
<p>修改之后, 就可以输入带有&quot;;&quot;的子语句, 而不会马上执行, 只有当语句中包含 <code>delimiter</code>指定的符号才会被执行.</p>
<pre><code class="language-mysql">-- 默认状态下&quot;;&quot;被视作语句的结尾, 也是执行命令的标识
select  * from table;
</code></pre>
<p><code>delimiter</code>主要应用场景为各类复杂语句的创建, 如自定义函数, 事件等.</p>
<p>同时<code>MySQL</code>提供一个<code>\G</code>作为结尾执行的标志, 用于针对多字段的长内容提供更好的阅读体验, 而不是乱糟糟的一堆文字.</p>
<pre><code class="language-bash">character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
*************************** 27. row ***************************
                  Db: test_db
                Name: rand_test_a_data
                Type: PROCEDURE
             Definer: alex@localhost
            Modified: 2023-01-16 21:29:41
             Created: 2023-01-16 21:29:41
       Security_type: DEFINER
             Comment:
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
*************************** 28. row ***************************
                  Db: test_db
                Name: rand_test_data
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2023-01-16 19:16:49
             Created: 2023-01-16 19:16:49
       Security_type: DEFINER
             Comment:
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
28 rows in set (0.00 sec)
</code></pre>
<h3 id="123-declare">12.3 declare</h3>
<pre><code class="language-bash">DECLARE var_name[,...] type [DEFAULT value]
</code></pre>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/declare.html"><code>DECLARE</code></a> is permitted only inside a <a href="https://dev.mysql.com/doc/refman/8.0/en/begin-end.html"><code>BEGIN ... END</code></a> compound statement and must be at its start, before any other statements.</p>
<p>DECLARE 关键字声明的变量 只能在存储过程(begin...end)中使用, 最开始的行.</p>
</blockquote>
<blockquote>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/declare.html"><code>DECLARE</code></a> statement is used to define various items local to a program:</p>
<ul>
<li>Local variables. See <a href="https://dev.mysql.com/doc/refman/8.0/en/stored-program-variables.html">Section 13.6.4, &quot; Variables in Stored Programs&quot; </a>.</li>
<li>Conditions and handlers. See <a href="https://dev.mysql.com/doc/refman/8.0/en/condition-handling.html">Section 13.6.7, &quot; Condition Handling&quot; </a>.</li>
<li>Cursors. See <a href="https://dev.mysql.com/doc/refman/8.0/en/cursors.html">Section 13.6.6, &quot; Cursors&quot; </a>.</li>
</ul>
<p>Declarations must follow a certain order. Cursor declarations must appear before handler declarations. Variable and condition declarations must appear before cursor or handler declarations.</p>
<p>声明的先后顺序.</p>
</blockquote>
<p>作用:</p>
<ul>
<li>本地变量</li>
<li>条件和错误处理</li>
<li>游标</li>
</ul>
<pre><code class="language-mysql">-- 用declare定义一个名字为name的字符串类型的变量 变量前面需要加@
-- 常见varchar(MAX), 不限定字符串的长度
declare @name varchar(20);
</code></pre>
<pre><code class="language-mysql">delimiter $$
drop function if exists rand_string;
create function rand_string(n int) returns varchar(255)
begin
    declare chars_str varchar(52) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    declare return_str varchar(255) default '';
    declare i int default 0;
    while i&lt;n do
    set return_str=concat(return_str,substring(chars_str,floor(1+rand()*52),1));
    set i=i+1;
    end while;
    return return_str;
end $$
</code></pre>
<h3 id="124-function">12.4 function</h3>
<pre><code class="language-mysql">CREATE [AGGREGATE] FUNCTION *function_name*  RETURNS {STRING|INTEGER|REAL|DECIMAL}    SONAME *shared_library_name*
</code></pre>
<pre><code class="language-bash"># 假如出现以下错误
ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary
logging is enabled ( you * might* want to use the less safe log_bin_trust_function_creators variable)
--------
# 设置mysql
set global log_bin_trust_function_creators = 1;

set log_bin_trust_function_creators = 1
&gt; 1229 - Variable 'log_bin_trust_function_creators' is a GLOBAL variable and should be set with SET GLOBAL
&gt; 时间: 0s
</code></pre>
<pre><code class="language-mysql">delimiter $$

CREATE function rand_str2(max_len int) returns VARCHAR(20)
BEGIN
	if ( max_len &gt; 10) then
		set max_len = 10;
	ELSEIF (max_len &lt; 2) then
		set max_len = 2;
	end if;
  RETURN substring( rand(), 3, max_len );
END $$

delimiter;

set @r = rand_str2(11);

SELECT @r;
-----------
set @r = rand_str2(1);

SELECT @r;
</code></pre>
<pre><code class="language-mysql"># 删除func
# 响应的func, 将存储在数据库中
drop function func_name;
</code></pre>
<h3 id="125-procedure">12.5 procedure</h3>
<ul>
<li>
<p><code>in</code>, 输入参数</p>
<pre><code class="language-mysql">delimiter $$
create PROCEDURE test_p2 (in i int)
BEGIN
	SELECT * from next where id = i;
end $$

delimiter ;

call test_p2(1);

id   name
1	alex
# 等价的
set @a = 1;
call test_p2(@a);

# 直接传入变量
call test_p2(@b);
------------------------------

delimiter $$
create PROCEDURE test_p3 (in i int)
BEGIN
	set i = 3;
	SELECT * from next where id = i;
	# 3
end $$

delimiter ;

set @o = 1;
call test_p3(@o);

SELECT @o;
# 1
</code></pre>
</li>
<li>
<p><code>inout</code>, 输入/输出参数</p>
<pre><code class="language-mysql">delimiter $$
create PROCEDURE test_p4 (inout i int)
BEGIN
	set i = 3;
	SELECT * from next where id = i;
	# 3
end $$

delimiter ;

set @o = 1;
call test_p4(@o);

SELECT @o;
# 3
</code></pre>
</li>
<li>
<p><code>out</code>, 输出参数, 类似于<code>vba</code>的<code>byref</code></p>
<pre><code class="language-mysql">delimiter $$

create PROCEDURE test_p (out i int)
BEGIN
	# 由于这一步, 传入的是null
    SELECT i;
    # null
    set i = 2;
    # 对变量进行修改
    SELECT i;
    # 2
end $$

delimiter ;

# 相当于 set @a = 0;, 或者之类的生命变量
# 传入参数 @a
call test_p(@a);

SELECT @a;
# 2
# 由于变量在test_p进行赋值2

# 假如直接传入数据
call test_p(0);
&gt; 1414 - OUT or INOUT argument 1 for routine test_db.test_p is not a variable or NEW pseudo-variable in BEFORE trigger
</code></pre>
</li>
</ul>
<pre><code class="language-mysql"># 删除pro
drop PROCEDURE p_name;
</code></pre>
<ul>
<li><a href="https://www.jianshu.com/p/2eaa094adf9e">参考链接, 存储过程( procedure) 和函数( Function) 的区别</a></li>
</ul>
<h2 id="十三-语句">十三. 语句</h2>
<h3 id="131-判断语句">13.1 判断语句</h3>
<h4 id="1311-case">13.1.1 <code>case</code></h4>
<pre><code class="language-mysql">SELECT CASE 1
        WHEN 1 THEN '男'
        WHEN 2 THEN '女'
        ELSE '未知'
    END
as ages;
</code></pre>
<h4 id="1312-if">13.1.2 <code>if</code></h4>
<pre><code class="language-mysql"># if 不带 else
select *, if(age=1,&quot;男&quot;,&quot;女&quot;) as ages from user;

# if 带 else
create procedure dbname.proc_getGrade  (stu_no varchar(20),cour_no varchar(10))
BEGIN
	# 声明变量
    declare stu_grade float;
    # 对变量进行赋值
    select grade into stu_grade from grade where student_no=stu_no and course_no=cour_no;
    # 条件语句
    if stu_grade &gt;= 90 then
        select stu_grade,'A';
    elseif stu_grade &lt; 90 and stu_grade &gt;= 80 then
        select stu_grade,'B';
    elseif stu_grade &lt; 80 and stu_grade &gt;= 70 then
        select stu_grade,'C';
    elseif stu_grade &lt; 70 and stu_grade &gt;= 60 then
        select stu_grade,'D';
    else
        select stu_grade,'E';
    end if;
end
</code></pre>
<h3 id="132-循环语句">13.2 循环语句</h3>
<h4 id="1321-while">13.2.1 <code>while</code></h4>
<pre><code class="language-mysql">DELIMITER $$
    DROP PROCEDURE IF EXISTS test_mysql_while_loop$$
    CREATE PROCEDURE test_mysql_while_loop()
        BEGIN
            DECLARE x  INT;
            DECLARE str  VARCHAR(255);

            SET x = 1;
            SET str =  '';

            WHILE x  &lt;= 5 DO
                SET  str = CONCAT(str, x, ',');
                SET  x = x + 1;
            END WHILE;

            SELECT str;
        END$$
DELIMITER ;
</code></pre>
<h4 id="1322-loop">13.2.2 <code>loop</code></h4>
<pre><code class="language-mysql">[begin_label:] LOOP
    statement_list
END LOOP [end_label]

CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;
</code></pre>
<pre><code class="language-mysql">-- 计算从1到n的值
DELIMITER $$
create procedure pro_test10(n int)
begin
  declare total int default 0;

  c:loop
    set total = total + n;
    set n = n -1;
    if n &lt;= 0 then
       leave c;
    end if;
  end loop c;
  select total;
end$
DELIMITER ;
</code></pre>
<h4 id="1323-repeat">13.2.3 <code>repeat</code></h4>
<pre><code class="language-mysql">REPEAT
	statement_list
UNTIL search_condition END REPEAT;

-- --------------------------------------------------

delimiter $$
CREATE PROCEDURE rand_test_data (in i_many int)
BEGIN
	DECLARE ic int DEFAULT 0;

	drop table if EXISTS test_table;

	CREATE TABLE test_table (id int not null PRIMARY key auto_increment, col varchar(32));

	# 先将自动事务提交关闭
	set @autocommit = 0;

	REPEAT
	# 执行需要循环的数据
		insert into test_table (col)  VALUES (LEFT ( concat( 1000000000000000 * rand(), 'ajkshxm' ), 18 ));
		set ic = ic + 1;
	UNTIL
		# 退出执行的条件
		ic = i_many
	END REPEAT;

	# 改为手动提交
	COMMIT;
	# 恢复设置
	set @autocommit = 1;

end $$
delimiter ;
</code></pre>
<p>注意有个同名字符串函数:</p>
<pre><code class="language-bash">mysql&gt; SELECT REPEAT(&quot;a&quot;, 3);
+----------------+
| REPEAT(&quot;a&quot;, 3) |
+----------------+
| aaa            |
+----------------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="133-公共表达式cet">13.3 公共表达式(CET)</h3>
<p>这是<code>mysql8.x</code>之后版本启用的新特性.</p>
<pre><code class="language-mysql">WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT b, d FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;
</code></pre>
<pre><code class="language-bash"># 可复用对于数据的影响.
mysql&gt; SELECT q1.year,q2.year AS next_year, q1.sum, q2.sum AS next_sum,
    -&gt;                  100*(q2.sum-q1.sum)/q1.sum AS pct
    -&gt;           FROM (SELECT year(from_date) as year, sum(salary) as sum FROM salaries GROUP BY year) AS q1,
    -&gt;                (SELECT year(from_date) as year, sum(salary) as sum FROM salaries GROUP BY year) AS q2
    -&gt;           WHERE q1.year=q2.year-1;
+------+-----------+-------------+-------------+----------+
| year | next_year | sum         | next_sum    | pct      |
+------+-----------+-------------+-------------+----------+
| 1985 |      1986 |   972864875 |  2052895941 | 111.0155 |
| 1986 |      1987 |  2052895941 |  3156881054 |  53.7770 |
| 1987 |      1988 |  3156881054 |  4295598688 |  36.0710 |
| 1988 |      1989 |  4295598688 |  5454260439 |  26.9732 |
| 1989 |      1990 |  5454260439 |  6626146391 |  21.4857 |
| 1990 |      1991 |  6626146391 |  7798804412 |  17.6974 |
| 1991 |      1992 |  7798804412 |  9027872610 |  15.7597 |
| 1992 |      1993 |  9027872610 | 10215059054 |  13.1502 |
| 1993 |      1994 | 10215059054 | 11429450113 |  11.8882 |
| 1994 |      1995 | 11429450113 | 12638817464 |  10.5812 |
| 1995 |      1996 | 12638817464 | 13888587737 |   9.8883 |
| 1996 |      1997 | 13888587737 | 15056011781 |   8.4056 |
| 1997 |      1998 | 15056011781 | 16220495471 |   7.7343 |
| 1998 |      1999 | 16220495471 | 17360258862 |   7.0267 |
| 1999 |      2000 | 17360258862 | 17535667603 |   1.0104 |
| 2000 |      2001 | 17535667603 | 17507737308 |  -0.1593 |
| 2001 |      2002 | 17507737308 | 10243347616 | -41.4925 |
+------+-----------+-------------+-------------+----------+
17 rows in set (2.37 sec)

mysql&gt; WITH CTE AS
    -&gt;            (SELECT year(from_date) AS year, SUM(salary) AS sum FROM salaries GROUP BY year)
    -&gt;            SELECT q1.year,q2.year AS next_year, q1.sum, q2.sum AS next_sum,
    -&gt;                          100*(q2.sum-q1.sum)/q1.sum AS pct FROM
    -&gt;            CTE AS q1, CTE AS q2
    -&gt;            WHERE q1.year = q2.year-1;
+------+-----------+-------------+-------------+----------+
| year | next_year | sum         | next_sum    | pct      |
+------+-----------+-------------+-------------+----------+
| 1985 |      1986 |   972864875 |  2052895941 | 111.0155 |
| 1986 |      1987 |  2052895941 |  3156881054 |  53.7770 |
| 1987 |      1988 |  3156881054 |  4295598688 |  36.0710 |
| 1988 |      1989 |  4295598688 |  5454260439 |  26.9732 |
| 1989 |      1990 |  5454260439 |  6626146391 |  21.4857 |
| 1990 |      1991 |  6626146391 |  7798804412 |  17.6974 |
| 1991 |      1992 |  7798804412 |  9027872610 |  15.7597 |
| 1992 |      1993 |  9027872610 | 10215059054 |  13.1502 |
| 1993 |      1994 | 10215059054 | 11429450113 |  11.8882 |
| 1994 |      1995 | 11429450113 | 12638817464 |  10.5812 |
| 1995 |      1996 | 12638817464 | 13888587737 |   9.8883 |
| 1996 |      1997 | 13888587737 | 15056011781 |   8.4056 |
| 1997 |      1998 | 15056011781 | 16220495471 |   7.7343 |
| 1998 |      1999 | 16220495471 | 17360258862 |   7.0267 |
| 1999 |      2000 | 17360258862 | 17535667603 |   1.0104 |
| 2000 |      2001 | 17535667603 | 17507737308 |  -0.1593 |
| 2001 |      2002 | 17507737308 | 10243347616 | -41.4925 |
+------+-----------+-------------+-------------+----------+
17 rows in set (1.18 sec)

mysql&gt; select count(*) from salaries;
+----------+
| count(*) |
+----------+
|  2844047 |
+----------+
1 row in set (0.05 sec)
</code></pre>
<h4 id="1331-递归cet">13.3.1 递归CET</h4>
<figure data-type="image" tabindex="36"><img src="http://www.yiibai.com/uploads/images/201707/1907/400090722_16608.png" alt="img" loading="lazy"></figure>
<p>递归成员不得包含以下结构:</p>
<ul>
<li>聚合函数 例如<a href="https://www.begtut.com/mysql/mysql-max-function.html">MAX</a> <a href="https://www.begtut.com/mysql/mysql-min.html">MIN</a> <a href="https://www.begtut.com/mysql/mysql-sum.html">SUM</a> <a href="https://www.begtut.com/mysql/mysql-avg.html">AVG</a> <a href="https://www.begtut.com/mysql/mysql-count.html">COUNT</a>等.</li>
<li><a href="https://www.begtut.com/mysql/mysql-group-by.html">GROUP BY</a>子句</li>
<li><a href="https://www.begtut.com/mysql/mysql-order-by.html">ORDER BY</a>子句</li>
<li><a href="https://www.begtut.com/mysql/mysql-limit.html">LIMIT</a> 子句</li>
<li><a href="https://www.begtut.com/mysql/mysql-distinct.html">DISTINCT</a></li>
</ul>
<pre><code class="language-bash"># 当在表中操作, n会报不存在字段的问题
mysql&gt; WITH RECURSIVE cte_count (n)
    -&gt; AS (
    -&gt;       SELECT 1
    -&gt;       UNION ALL
    -&gt;       SELECT n + 1
    -&gt;       FROM cte_count
    -&gt;       WHERE n &lt; 3
SELE    -&gt;     )
    -&gt; SELECT n
    -&gt; FROM cte_count;
+------+
| n    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)
</code></pre>
<p>递归CTE由三个主要部分组成:</p>
<ul>
<li>初始<a href="https://www.begtut.com/mysql/mysql-select-statement-query-data.html">查询</a> 形成CTE结构的基本结果集. 初始查询部分称为锚成员.</li>
<li>递归查询部分是引用CTE名称的查询 因此 它被称为递归成员. 递归成员由<code>UNION ALL</code>或<code>UNION DISTINCT</code>运算符与锚成员连接.</li>
<li>终止条件 确保递归成员不返回任何行时停止递归.</li>
</ul>
<p>递归CTE的执行顺序如下:</p>
<ol>
<li>首先 将成员分为两部分: 锚点和递归成员.</li>
<li>接下来 执行锚成员以形成基本结果集( <code>R0</code>)  并将此基本结果集用于下一次迭代.</li>
<li>然后 执行带有<code>Ri</code>结果集作为输入的递归成员并将其<code>Ri+1</code>作为输出.</li>
<li>之后 重复第三步 直到递归成员返回空结果集 换句话说 满足终止条件.</li>
<li>最后 使用<code>UNION ALL</code>运算符将结果集从R0到Rn组合.</li>
</ol>
<pre><code class="language-bash">drop table if exists test;
create table test(id int not null, col char(18) not null);

insert into test(id, col)
with recursive temp as (
	# 1 n, 为了引入变量n
	select 1 n, LEFT ( concat( 100000000000000 * rand(), 'ajkshxm' ), 18 )
	union
	select n + 1, LEFT ( concat( 100000000000000 * rand(), 'ajkshxm' ), 18 ) from temp where n &lt; 1000)
	select * from temp;

insert into test(id, col) select 2000 + id, LEFT ( concat( 100000000000000 * rand(), 'ajkshxm' ), 18 ) from test where id &lt; 500000;
# 只会执行前1000次
</code></pre>
<pre><code class="language-bash"># 递归的最大深度, 默认为1000
mysql&gt; show variables like '%recursion%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| cte_max_recursion_depth | 1000  |
| max_sp_recursion_depth  | 0     |
+-------------------------+-------+
</code></pre>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/with.html">参考链接</a></li>
<li><a href="https://www.begtut.com/mysql/mysql-recursive-cte.html">begtut_MySQL教程</a></li>
</ul>
<h2 id="十四-十四-查询">十四. 十四. 查询</h2>
<figure data-type="image" tabindex="37"><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0619%2Fcfd72e71j00qc6iqx0019c000hs00gtm.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt="download.png" loading="lazy"></figure>
<pre><code class="language-mysql">SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N][ OFFSET M]
</code></pre>
<ul>
<li>select</li>
<li>where</li>
<li>group by</li>
<li>order by</li>
<li>having</li>
<li>union</li>
<li>like, or, and, exists, in between</li>
</ul>
<h3 id="141-联表查询">14.1 联表查询</h3>
<figure data-type="image" tabindex="38"><img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="sql-join.png" loading="lazy"></figure>
<ul>
<li><code>(INNER)</code> JOIN: 返回两个表中具有匹配值的记录</li>
<li><code>LEFT( OUTER) JOIN</code>: 返回左表中的所有记录 以及右表中的匹配记录</li>
<li><code>RIGHT( OUTER) JOIN</code>: 返回右表中的所有记录 以及左表中匹配的记录</li>
<li><code>FULL( OUTER) JOIN</code>: 当左表或右表中匹配时返回所有记录(<strong>注意</strong>: <code>mysql</code><strong>并不支</strong>持此项)</li>
</ul>
<pre><code class="language-bash"># 注意, 其执行的逻辑
# 拿左表去对应数据, 然后根据对应的join方式得到数据, 假如有where, 再进一步处理数据
|id_left|id_right|
|1|null
|2|2|
|3|3|

# 返回左表对应的数据
mysql&gt; select t1.id from t1 left join t2 on t1.id = t2.id;
# 1, 没有对应的数据, 但是属于左表, 同样返回
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)

# 返回左表的数据, 但是其判断的依据是量表进行匹配后, 与左边对应的右表的项为空的项
# 执行先后, join 优先于 where
# 即拿到了join的数据, 然后再进行where筛选
mysql&gt; select t1.id from t1 left join t2 on t1.id = t2.id where t2.id is null;
+----+
| id |
+----+
|  1 |
+----+
1 row in set (0.00 sec)

# INSERT INTO t1 VALUES (1),(2),(3);
# INSERT INTO t2 VALUES (2),(3),(4);

# 返回两个表都存在的数据
mysql&gt; select t1.id from t1 join t2 on t1.id = t2.id;
+----+
| id |
+----+
|  2 |
|  3 |
+----+
2 rows in set (0.00 sec)

|t2|t1|
|2|2|
|3|3|
|4|null|
# 返回右侧的内容 t1
mysql&gt; select t1.id from t1 right join t2 on t1.id = t2.id;
+------+
| id   |
+------+
|    2 |
|    3 |
| NULL |
+------+
3 rows in set (0.00 sec)

# 返回右侧表的, t1
mysql&gt; select t1.id from t1 right join t2 on t1.id = t2.id where t1.id is null;
+------+
| id   |
+------+
| NULL |
+------+
1 row in set (0.00 sec)

# join full?
mysql&gt; select * from t1 left join t2 on t1.id = t2.id
    -&gt; union
    -&gt; select *
    -&gt; from t1 right join t2 on t1.id = t2.id;
+------+------+
| id   | id   |
+------+------+
|    1 | NULL |
|    2 |    2 |
|    3 |    3 |
| NULL |    4 |
+------+------+
4 rows in set (0.00 sec)
</code></pre>
<h3 id="142-并集union">14.2 并集(union)</h3>
<p>和<code>jon</code>的差异, 主要在于<code>join</code>是横向组合数据, 而<code>union</code>是纵向组合数据的.</p>
<figure data-type="image" tabindex="39"><a href="https://imgse.com/i/pSyg6eI"><img src="https://s1.ax1x.com/2023/02/04/pSyg6eI.png" alt="pSyg6eI.png" loading="lazy"></a></figure>
<pre><code class="language-mysql">CREATE TABLE t1 (
    id INT PRIMARY KEY
);

CREATE TABLE t2 (
    id INT PRIMARY KEY
);

INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (2),(3),(4);
</code></pre>
<pre><code class="language-bash"># union, 去重, 只保留一份数据
mysql&gt; SELECT id
    -&gt; FROM t1
ION
S    -&gt; UNION
    -&gt; SELECT id
    -&gt; FROM t2;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
+----+
4 rows in set (0.00 sec)

# union all, 交集部分不作去重
mysql&gt; SELECT id
    -&gt; FROM t1
    -&gt; UNION ALL
    -&gt; SELECT id
    -&gt; FROM t2;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
|  2 |
|  3 |
|  4 |
+----+
6 rows in set (0.01 sec)

</code></pre>
<h3 id="143-交集intersect">14.3 交集(intersect)</h3>
<ul>
<li>列数量相同</li>
<li>列数据类型相同</li>
</ul>
<pre><code class="language-bash">mysql&gt;  (SELECT id
    -&gt; FROM t1)
    -&gt; INTERSECT
    -&gt; (SELECT id
    -&gt; FROM t2);
+----+
| id |
+----+
|  2 |
|  3 |
+----+
2 rows in set (0.00 sec)

# 等价于inner join
mysql&gt; select t1.id from t1 join t2 on t1.id = t2.id;
+----+
| id |
+----+
|  2 |
|  3 |
+----+
2 rows in set (0.00 sec)
</code></pre>
<h3 id="144-笛卡尔乘积cross-join">14.4 笛卡尔乘积(cross join)</h3>
<p>笛卡尔乘积, 即穷举出所有的两个表的组合.</p>
<pre><code class="language-bash">mysql&gt; select * from t1 cross join t2;
+----+----+
| id | id |
+----+----+
|  3 |  2 |
|  2 |  2 |
|  1 |  2 |
|  3 |  3 |
|  2 |  3 |
|  1 |  3 |
|  3 |  4 |
|  2 |  4 |
|  1 |  4 |
+----+----+
9 rows in set (0.00 sec)

# cross
mysql&gt; select * from t1 join t2;
+------+------+
| id   | id   |
+------+------+
|    3 |    2 |
|    2 |    2 |
|    1 |    2 |
|    3 |    3 |
|    2 |    3 |
|    1 |    3 |
|    3 |    4 |
|    2 |    4 |
|    1 |    4 |
+------+------+
9 rows in set (0.00 sec)
</code></pre>
<h3 id="145-自连接self-join">14.5 自连接(self join)</h3>
<p>自连接, 即自我连接.</p>
<pre><code class="language-bash">mysql&gt; select employeeNumber, lastName, firstName, reportsTo from employees limit 5;
+----------------+-----------+-----------+-----------+
| employeeNumber | lastName  | firstName | reportsTo |
+----------------+-----------+-----------+-----------+
|           1002 | Murphy    | Diane     |      NULL |
|           1056 | Patterson | Mary      |      1002 |
|           1076 | Firrelli  | Jeff      |      1002 |
|           1088 | Patterson | William   |      1056 |
|           1102 | Bondur    | Gerard    |      1056 |
+----------------+-----------+-----------+-----------+
5 rows in set (0.00 sec)

mysql&gt; SELECT
    -&gt;     CONCAT(m.lastname, ', ', m.firstname) AS 'Manager',
    -&gt;     CONCAT(e.lastname, ', ', e.firstname) AS 'Direct report'
    -&gt; FROM
    -&gt;     employees e
  INN    -&gt;         INNER JOIN
    -&gt;     employees m ON m.employeeNumber = e.reportsto
    -&gt; ORDER BY manager;
+--------------------+--------------------+
| Manager            | Direct report      |
+--------------------+--------------------+
| Bondur, Gerard     | Bondur, Loui       |
| Bondur, Gerard     | Gerard, Martin     |
| Bondur, Gerard     | Jones, Barry       |
| Bondur, Gerard     | Bott, Larry        |
| Bondur, Gerard     | Castillo, Pamela   |
| Bondur, Gerard     | Hernandez, Gerard  |
| Bow, Anthony       | Thompson, Leslie   |
| Bow, Anthony       | Firrelli, Julie    |
| Bow, Anthony       | Patterson, Steve   |
| Bow, Anthony       | Tseng, Foon Yue    |
| Bow, Anthony       | Vanauf, George     |
| Bow, Anthony       | Jennings, Leslie   |
| Murphy, Diane      | Patterson, Mary    |
| Murphy, Diane      | Firrelli, Jeff     |
| Nishi, Mami        | Kato, Yoshimi      |
| Patterson, Mary    | Bow, Anthony       |
| Patterson, Mary    | Bondur, Gerard     |
| Patterson, Mary    | Patterson, William |
| Patterson, Mary    | Nishi, Mami        |
| Patterson, William | Fixter, Andy       |
| Patterson, William | Marsh, Peter       |
| Patterson, William | King, Tom          |
+--------------------+--------------------+
22 rows in set (0.00 sec)
</code></pre>
<h3 id="146-聚合查询">14.6 聚合查询</h3>
<p>以牛客网的测试题作为示例</p>
<ul>
<li><code>SQL156</code>, 各个视频的平均完播率</li>
</ul>
<pre><code class="language-mysql"># 相对麻烦的是多次计算
# if () 作为辅助计算
# having 使用的麻烦
with
t2 as (SELECT t3.video_id, if (( t1.end_time - t1.start_time - t3.duration )&gt;=0, 1, 0) as finish FROM tb_video_info t3 JOIN  tb_user_video_log t1 ON t1.video_id = t3.video_id)

select video_id, (sum(finish) / count(video_id)) as avg_rate from t2  GROUP BY video_id;

# 注意having的在多个temp table中的使用
</code></pre>
<ul>
<li>SQL180 某宝店铺的SPU数量</li>
</ul>
<pre><code class="language-bash">mysql&gt; select style_id, count(style_id) SPU_num from product_tb group by style_id order by SPU_num desc;
+----------+---------+
| style_id | SPU_num |
+----------+---------+
| B        |       4 |
| A        |       3 |
| C        |       2 |
+----------+---------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="147-窗口函数">14.7 窗口函数</h3>
<p>内容较多, 且重要, 单独拆分出来, 详细内容见<code>MySQL窗口函数详解</code>.</p>
<p><em>在窗口函数中, 注意对于聚合函数, 诸如<code>sum</code>, <code>count</code>等的使用, 很容易触发以下错误.</em></p>
<blockquote>
<p>SQL_ERROR_INFO: &quot;In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column 'base_table.user_id'; this is incompatible with sql_mode=only_full_group_by&quot;</p>
<p><em>注意各类函数之间大搭配使用, 如having, 就应该和group by进行一起使用. 在经过聚合处理的临时表, 引用聚合函数, sum等时, 注意聚合的字段和聚合的数据所在的字段.</em></p>
<p>关于这个问题, 详情见<code>MySQL翻译系列-MySQL Handling of GROUP BY</code></p>
</blockquote>
<figure data-type="image" tabindex="40"><img src="https://img-blog.csdnimg.cn/2019022312202720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTAxMDc3MA==,size_16,color_FFFFFF,t_70" alt="2019022312202720.png" loading="lazy"></figure>
<p>窗口函数即<code>OLAP</code>, <code>Online Anallytical Processing</code> 联机分析处理.</p>
<p>简而言之, 窗口函数强化了<code>MySQL</code>在数据分析的能力, 通过窗口函数可以实现较为复杂的常态化数据的直接输出, 例如经典的多层级的汇总, <code>topN</code>问题等.</p>
<p><em>注意: 这是<code>MySQL</code>专属函数, 不是标准的<code>SQL</code>语句, 需要8.x版本<code>MySQL</code>才支持(大部分的数据库都支持类似的功能, 如SQLite).</em></p>
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_cume-dist"><code>CUME_DIST()</code></a></td>
<td style="text-align:left">Cumulative distribution value, 累计分布</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank"><code>DENSE_RANK()</code></a></td>
<td style="text-align:left">Rank of current row within its partition, without gaps, 排名</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_first-value"><code>FIRST_VALUE()</code></a></td>
<td style="text-align:left">Value of argument from first row of window frame,取值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_lag"><code>LAG()</code></a></td>
<td style="text-align:left">Value of argument from row lagging current row within partition, 取值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_last-value"><code>LAST_VALUE()</code></a></td>
<td style="text-align:left">Value of argument from last row of window frame, 取值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_lead"><code>LEAD()</code></a></td>
<td style="text-align:left">Value of argument from row leading current row within partition, 取值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_nth-value"><code>NTH_VALUE()</code></a></td>
<td style="text-align:left">Value of argument from N-th row of window frame</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_ntile"><code>NTILE()</code></a></td>
<td style="text-align:left">Bucket number of current row within its partition. 分桶</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_percent-rank"><code>PERCENT_RANK()</code></a></td>
<td style="text-align:left">Percentage rank value, 排名占比</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank"><code>RANK()</code></a></td>
<td style="text-align:left">Rank of current row within its partition, with gaps, 排名</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number"><code>ROW_NUMBER()</code></a></td>
<td style="text-align:left">Number of current row within its partition, 行号</td>
</tr>
</tbody>
</table>
<p>一般语法结构</p>
<pre><code class="language-mysql">window_function_name (expression)
 OVER (
     [partition_defintion]
     [order_definition]
     [frame_definition]
 )
 SELECT fiscal_year, sales_employee, sale, SUM( sale ) OVER ( PARTITION BY fiscal_year ) as total_sales FROM sales;
</code></pre>
<pre><code class="language-mysql">-- 创建表格
CREATE TABLE sales(
    sales_employee VARCHAR(50) NOT NULL,
    fiscal_year INT NOT NULL,
    sale DECIMAL(14,2) NOT NULL,
    PRIMARY KEY(sales_employee,fiscal_year)
);
-- 插入数据
INSERT INTO sales(sales_employee,fiscal_year,sale)
VALUES('Bob',2016,100),
      ('Bob',2017,150),
      ('Bob',2018,200),
      ('Alice',2016,150),
      ('Alice',2017,100),
      ('Alice',2018,200),
       ('John',2016,200),
      ('John',2017,150),
      ('John',2018,250);
</code></pre>
<pre><code class="language-bash"># 查看
mysql&gt; select * from sales;
+----------------+-------------+--------+
| sales_employee | fiscal_year | sale   |
+----------------+-------------+--------+
| Alice          |        2016 | 150.00 |
| Alice          |        2017 | 100.00 |
| Alice          |        2018 | 200.00 |
| Bob            |        2016 | 100.00 |
| Bob            |        2017 | 150.00 |
| Bob            |        2018 | 200.00 |
| John           |        2016 | 200.00 |
| John           |        2017 | 150.00 |
| John           |        2018 | 250.00 |
+----------------+-------------+--------+
</code></pre>
<h4 id="1471-分组函数">14.7.1 分组函数</h4>
<pre><code class="language-bash"># 常见的汇总
# 筛选出每个sale_employee的总销售额
mysql&gt; select sales_employee, sum(sale) as total from sales group by sales_employee;
+----------------+--------+
| sales_employee | total  |
+----------------+--------+
| Alice          | 450.00 |
| Bob            | 450.00 |
| John           | 600.00 |
+----------------+--------+
3 rows in set (0.00 sec)

# 计算出每一年的销售总额, 以及每个sale的占比
mysql&gt; SELECT *, concat ( left (temp.sale / temp.total_sales * 100, 5),'%') as ratio
    -&gt; FROM
    -&gt; ( SELECT fiscal_year, sales_employee, sale, SUM( sale ) OVER ( PARTITION BY fiscal_year ) as total_sales FROM sales ) as temp;
+-------------+----------------+--------+-------------+--------+
| fiscal_year | sales_employee | sale   | total_sales | ratio  |
+-------------+----------------+--------+-------------+--------+
|        2016 | Alice          | 150.00 |      450.00 | 33.33% |
|        2016 | Bob            | 100.00 |      450.00 | 22.22% |
|        2016 | John           | 200.00 |      450.00 | 44.44% |
|        2017 | Alice          | 100.00 |      400.00 | 25.00% |
|        2017 | Bob            | 150.00 |      400.00 | 37.50% |
|        2017 | John           | 150.00 |      400.00 | 37.50% |
|        2018 | Alice          | 200.00 |      650.00 | 30.76% |
|        2018 | Bob            | 200.00 |      650.00 | 30.76% |
|        2018 | John           | 250.00 |      650.00 | 38.46% |
+-------------+----------------+--------+-------------+--------+
9 rows in set (0.00 sec)
</code></pre>
<ul>
<li>
<p><code>partition</code>, 分组函数, 但是和常规的<code>group by</code>有所区别的是, <code>partition</code>不会将数据进行合并压缩, 而是保留数据, 将计算的结果全部逐行放置.</p>
<p>在<code>pandas</code>中有对应的函数, 即<code>transform</code>函数, 同样也有同名的<code>group by</code>函数.</p>
<pre><code class="language-python">import pandas as pd

dfx = pd.DataFrame(data=[['a', 1,2], ['b', 2,3], ['a', 1,9], ['b', 3,4]], columns=['aa', 'bb', 'cc'])

dfx.groupby(by=['aa']).transform(sum)

	bb	cc
0	2	11
1	5	7
2	2	11
3	5	7
</code></pre>
<p>该函数用于解决, 数据处理后, 源数据丢失的问题.</p>
</li>
</ul>
<h4 id="1472-排名函数">14.7.2 排名函数</h4>
<pre><code class="language-bash"># 筛选出每个年度最高的sales_employee, topN
mysql&gt; SELECT * from
    -&gt;
    -&gt; (select *, DENSE_RANK() over (partition by fiscal_year order by sale desc) as r from sales) as temp where temp.r = 1;
+----------------+-------------+--------+---+
| sales_employee | fiscal_year | sale   | r |
+----------------+-------------+--------+---+
| John           |        2016 | 200.00 | 1 |
| Bob            |        2017 | 150.00 | 1 |
| John           |        2017 | 150.00 | 1 |
| John           |        2018 | 250.00 | 1 |
+----------------+-------------+--------+---+
4 rows in set (0.00 sec)

# 如果不需要相同的数值, 选用row_number
mysql&gt; SELECT * from
    -&gt;
    -&gt; (select *, ROW_NUMBER() over (partition by fiscal_year order by sale desc) as r from sales) as temp where temp.r = 1;
+----------------+-------------+--------+---+
| sales_employee | fiscal_year | sale   | r |
+----------------+-------------+--------+---+
| John           |        2016 | 200.00 | 1 |
| Bob            |        2017 | 150.00 | 1 |
| John           |        2018 | 250.00 | 1 |
+----------------+-------------+--------+---+
3 rows in set (0.00 sec)

mysql&gt; select *, RANK() over (partition by fiscal_year order by sale desc) as r from sales;
+----------------+-------------+--------+---+
| sales_employee | fiscal_year | sale   | r |
+----------------+-------------+--------+---+
| John           |        2016 | 200.00 | 1 |
| Alice          |        2016 | 150.00 | 2 |
| Bob            |        2016 | 100.00 | 3 |
| Bob            |        2017 | 150.00 | 1 |
| John           |        2017 | 150.00 | 1 |
| Alice          |        2017 | 100.00 | 3 | # 注意
| John           |        2018 | 250.00 | 1 |
| Alice          |        2018 | 200.00 | 2 |
| Bob            |        2018 | 200.00 | 2 |
+----------------+-------------+--------+---+
9 rows in set (0.00 sec)

mysql&gt; select *, dense_rank() over (partition by fiscal_year order by sale desc) as r from sales;
+----------------+-------------+--------+---+
| sales_employee | fiscal_year | sale   | r |
+----------------+-------------+--------+---+
| John           |        2016 | 200.00 | 1 |
| Alice          |        2016 | 150.00 | 2 |
| Bob            |        2016 | 100.00 | 3 |
| Bob            |        2017 | 150.00 | 1 |
| John           |        2017 | 150.00 | 1 |
| Alice          |        2017 | 100.00 | 2 | # 注意
| John           |        2018 | 250.00 | 1 |
| Alice          |        2018 | 200.00 | 2 |
| Bob            |        2018 | 200.00 | 2 |
+----------------+-------------+--------+---+

mysql&gt; select *, row_number() over (partition by fiscal_year order by sale desc) as r from sales;
+----------------+-------------+--------+---+
| sales_employee | fiscal_year | sale   | r |
+----------------+-------------+--------+---+
| John           |        2016 | 200.00 | 1 |
| Alice          |        2016 | 150.00 | 2 |
| Bob            |        2016 | 100.00 | 3 |
| Bob            |        2017 | 150.00 | 1 |
| John           |        2017 | 150.00 | 2 |
| Alice          |        2017 | 100.00 | 3 |
| John           |        2018 | 250.00 | 1 |
| Alice          |        2018 | 200.00 | 2 |
| Bob            |        2018 | 200.00 | 3 |
+----------------+-------------+--------+---+
9 rows in set (0.00 sec)
</code></pre>
<ul>
<li>
<p><code>dense_rank</code>, 1,1,2, 这里的排序当, 出现重复项.</p>
</li>
<li>
<p><code>rank</code>, 1, 1, 3, 这里的排序当, 出现重复项.</p>
</li>
<li>
<p><code>row_number</code>,1, 2, 3, 排序, 给出的是行号, 并不是排名.</p>
</li>
<li>
<p><code>pandas</code>中相关的方法为.</p>
<pre><code class="language-python"># 基于年份, 取出总营收前三的项目
df.sort_values(by=['营业总收入'], ascending=False).groupby(by=['year']).head(3)
</code></pre>
</li>
</ul>
<h4 id="1473-分桶函数">14.7.3 分桶函数</h4>
<pre><code class="language-bash"># 内置数据库
mysql&gt; SELECT *, NTILE(2) over (partition by CountryCode order by Population) as nt from city limit 10;
+-----+----------------+-------------+----------+------------+----+
| ID  | Name           | CountryCode | District | Population | nt |
+-----+----------------+-------------+----------+------------+----+
| 129 | Oranjestad     | ABW         | –       |      29034 |  1 |
|   4 | Mazar-e-Sharif | AFG         | Balkh    |     127800 |  1 |
|   3 | Herat          | AFG         | Herat    |     186800 |  1 |
|   2 | Qandahar       | AFG         | Qandahar |     237500 |  2 |
|   1 | Kabul          | AFG         | Kabol    |    1780000 |  2 |
|  60 | Namibe         | AGO         | Namibe   |     118200 |  1 |
|  59 | Benguela       | AGO         | Benguela |     128300 |  1 |
|  58 | Lobito         | AGO         | Benguela |     130000 |  1 |
|  57 | Huambo         | AGO         | Huambo   |     163100 |  2 |
|  56 | Luanda         | AGO         | Luanda   |    2022000 |  2 |
+-----+----------------+-------------+----------+------------+----+
10 rows in set (0.01 sec)
</code></pre>
<pre><code class="language-mysql"># 计算占比
# 2020年支付金额排名前30%的用户, 以及该用户支付的金额占当年的总额的百分比
# 局部, 和全局同时计算的问题
# 1. 找出2020年的用户
# 2. 按照用户名计算出各个用户之间的金额
# 3. 找出前30%
# 4. 计算单个用户支出占整体的金额
WITH a AS ( SELECT * FROM test_c WHERE YEAR ( pay_time ) = 2020 ),
b AS ( SELECT user_name, sum( pay_amount ) AS user_total FROM a GROUP BY user_name ),
c AS (
	SELECT
		user_name,
		sum( user_total ) over ( PARTITION BY NULL ) AS total,
		NTILE( 10 ) over ( ORDER BY user_total DESC ) AS part
	FROM
		b
	) SELECT
	b.user_name,
	round( b.user_total, 2 ) AS user_pay_total,
	concat( round( user_total / total * 100, 2 ), '%' ) AS percent
FROM
	b
	left JOIN c ON b.user_name = c.user_name
WHERE
	c.part &lt; 4;
</code></pre>
<pre><code class="language-mysql"># 优化版本
WITH a AS ( SELECT user_name, sum( pay_amount ) AS total FROM test_c WHERE YEAR ( pay_time ) = 2020 GROUP BY user_name ),
b AS (
	SELECT
		user_name,
		total,
		sum( total ) over ( PARTITION BY NULL ) AS all_total,
		ntile( 10 ) over ( ORDER BY total DESC ) AS s_part
	FROM
		a
	) SELECT
	user_name,
	round( total, 2 ) AS user_pay_total,
	concat( round( total / all_total * 100, 2 ), '%' ) AS user_percent
FROM
	b
WHERE
	s_part &lt; 4;
</code></pre>
<pre><code class="language-bash">+-----------+----------------+--------------+
| user_name | user_pay_total | user_percent |
+-----------+----------------+--------------+
| Moore     |         686598 | 8.1%         |
| KAREN     |         626604 | 7.39%        |
| Marshall  |       586654.2 | 6.92%        |
| Frank     |         579942 | 6.84%        |
| Emma      |         564388 | 6.66%        |
| King      |         553344 | 6.53%        |
| Keith     |       493580.9 | 5.82%        |
| JUNE      |         379962 | 4.48%        |
| Amanda    |         359964 | 4.24%        |
| Morris    |         318814 | 3.76%        |
| Bonnie    |         310746 | 3.66%        |
| Francis   |       236731.2 | 2.79%        |
| Carroll   |         228866 | 2.7%         |
| Christy   |       218186.4 | 2.57%        |
| Ethan     |         208736 | 2.46%        |
| Ray       |         202202 | 2.38%        |
| Regan     |         195536 | 2.31%        |
| Knight    |         193314 | 2.28%        |
| DAISY     |         188870 | 2.23%        |
| Ailsa     |         151096 | 1.78%        |
| Iris      |         139986 | 1.65%        |
+-----------+----------------+--------------+
21 rows in set (0.01 sec)
</code></pre>
<ul>
<li><code>ntile</code>, 分桶/分箱.</li>
<li><code>pandas</code>中对应的函数, <code>cut/qcut</code>.</li>
</ul>
<h4 id="1474-滑动函数">14.7.4 滑动函数</h4>
<pre><code class="language-bash"># 连续问题, 例如网站的登录, 哪些用户连续 N天 登录
select *, dense_rank() over (partition by user_id order by login_date) as r from SQL_8;

+---------+------------+---+
| user_id | login_date | r |
+---------+------------+---+
| A       | 2022-09-02 | 1 |
| A       | 2022-09-03 | 2 |
| A       | 2022-09-03 | 2 |
| A       | 2022-09-04 | 3 |
| A       | 2022-10-03 | 4 |
| B       | 2021-11-25 | 1 |
| B       | 2021-12-31 | 2 |
| B       | 2022-01-04 | 3 |
| B       | 2022-01-05 | 4 |
| B       | 2022-11-16 | 5 |
| B       | 2022-11-17 | 6 |
| C       | 2022-01-01 | 1 |
| C       | 2022-04-04 | 2 |
| C       | 2022-09-03 | 3 |
| C       | 2022-09-04 | 4 |
| C       | 2022-09-05 | 5 |
| D       | 2022-10-20 | 1 |
| D       | 2022-10-21 | 2 |
| D       | 2022-10-22 | 3 |
| D       | 2022-10-23 | 4 |
+---------+------------+---+
20 rows in set (0.00 sec)

# 过滤掉日期, 用户id相同的项
mysql&gt; select distinct user_id, login_date from SQL_8;
+---------+------------+
| user_id | login_date |
+---------+------------+
| A       | 2022-09-02 |
| A       | 2022-09-03 |
| A       | 2022-09-04 |
| B       | 2021-11-25 |
| B       | 2021-12-31 |
| C       | 2022-01-01 |
| C       | 2022-04-04 |
| C       | 2022-09-03 |
| C       | 2022-09-05 |
| C       | 2022-09-04 |
| D       | 2022-10-20 |
| D       | 2022-10-21 |
| A       | 2022-10-03 |
| D       | 2022-10-22 |
| D       | 2022-10-23 |
| B       | 2022-01-04 |
| B       | 2022-01-05 |
| B       | 2022-11-16 |
| B       | 2022-11-17 |
+---------+------------+
19 rows in set (0.00 sec)

# 对数据的预处理
# 连续, 则意味着, 登录的实践间隔为1

# 将上述两个语句串联起来
mysql&gt; with tmp as (select distinct user_id, login_date from SQL_8)
    -&gt;
    -&gt; select *, dense_rank() over (partition by user_id order by login_date) as r from tmp;
+---------+------------+---+
| user_id | login_date | r |
+---------+------------+---+
| A       | 2022-09-02 | 1 |
| A       | 2022-09-03 | 2 |
| A       | 2022-09-04 | 3 |
| A       | 2022-10-03 | 4 |
| B       | 2021-11-25 | 1 |
| B       | 2021-12-31 | 2 |
| B       | 2022-01-04 | 3 |
| B       | 2022-01-05 | 4 |
| B       | 2022-11-16 | 5 |
| B       | 2022-11-17 | 6 |
| C       | 2022-01-01 | 1 |
| C       | 2022-04-04 | 2 |
| C       | 2022-09-03 | 3 |
| C       | 2022-09-04 | 4 |
| C       | 2022-09-05 | 5 |
| D       | 2022-10-20 | 1 |
| D       | 2022-10-21 | 2 |
| D       | 2022-10-22 | 3 |
| D       | 2022-10-23 | 4 |
+---------+------------+---+
19 rows in set (0.00 sec)

mysql&gt; with tmp as (select distinct user_id, login_date from SQL_8),
    -&gt;
    -&gt; tmp_a as (select *, dense_rank() over (partition by user_id order by login_date) as r from tmp)
    -&gt;
    -&gt; select *, DATE_SUB(login_date, interval r day) as sub from tmp_a;
+---------+------------+---+------------+
| user_id | login_date | r | sub        |
+---------+------------+---+------------+
| A       | 2022-09-02 | 1 | 2022-09-01 |
| A       | 2022-09-03 | 2 | 2022-09-01 |
| A       | 2022-09-04 | 3 | 2022-09-01 |
| A       | 2022-10-03 | 4 | 2022-09-29 |
| B       | 2021-11-25 | 1 | 2021-11-24 |
| B       | 2021-12-31 | 2 | 2021-12-29 |
| B       | 2022-01-04 | 3 | 2022-01-01 |
| B       | 2022-01-05 | 4 | 2022-01-01 |
| B       | 2022-11-16 | 5 | 2022-11-11 |
| B       | 2022-11-17 | 6 | 2022-11-11 |
| C       | 2022-01-01 | 1 | 2021-12-31 |
| C       | 2022-04-04 | 2 | 2022-04-02 |
| C       | 2022-09-03 | 3 | 2022-08-31 |
| C       | 2022-09-04 | 4 | 2022-08-31 |
| C       | 2022-09-05 | 5 | 2022-08-31 |
| D       | 2022-10-20 | 1 | 2022-10-19 |
| D       | 2022-10-21 | 2 | 2022-10-19 |
| D       | 2022-10-22 | 3 | 2022-10-19 |
| D       | 2022-10-23 | 4 | 2022-10-19 |
+---------+------------+---+------------+
19 rows in set (0.00 sec)
# 假如连续间隔, 在剪掉排名对应的顺序, 时, 则得到的日期将是相同的

mysql&gt; with
    -&gt; tmp as (select distinct user_id, login_date from SQL_8),
    -&gt;
    -&gt; tmp_a as (select *, dense_rank() over (partition by user_id order by login_date) as r from tmp),
    -&gt;
    -&gt; tmp_b as (select *, DATE_SUB(login_date, interval r day) as sub from tmp_a)

select     -&gt;
    -&gt; select tmp_b.user_id, count(*) as c from tmp_b group by tmp_b.user_id, tmp_b.sub having c &gt; 2;
+---------+---+
| user_id | c |
+---------+---+
| A       | 3 |
| C       | 3 |
| D       | 4 |
+---------+---+
3 rows in set (0.00 sec)

# 更为强大的滑动窗口函数
mysql&gt; with
    -&gt; tmp as (select distinct user_id, login_date from SQL_8),
        temp as (selec    -&gt; temp as (select *, count(user_id) over (partition by user_id order by login_date range between interval '3' day preceding and current row) as ic from tmp)
    -&gt;
    -&gt; select temp.user_id, temp.ic from temp where temp.ic &gt; 2;
+---------+----+
| user_id | ic |
+---------+----+
| A       |  3 |
| C       |  3 |
| D       |  3 |
| D       |  4 |
+---------+----+

# 注意最后的一句语句的写法
select tmp_b.user_id, count(tmp_b.sub) as c from tmp_b group by tmp_b.sub;
ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'tmp_b.user_id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

# https://huaweicloud.csdn.net/633550cfd3efff3090b54121.html
# https://stackoverflow.com/questions/51856270/error-code-1055-expression-1-of-select-list-is-not-in-group-by-clause-and-con
</code></pre>
<ul>
<li>
<p><code>with</code>关键词</p>
<pre><code class="language-bash">mysql&gt; with
    -&gt; tmp as (select distinct user_id, login_date from SQL_8),
    -&gt;
    -&gt; tmp_a as (select *, dense_rank() over (partition by user_id order by login_date) as r from tmp),
    -&gt;
    -&gt; tmp_b as (select *, DATE_SUB(login_date, interval r day) as sub from tmp_a);

# 解决使用多个临时表过于混乱的问题
</code></pre>
</li>
<li>
<p><code>date_sub</code>函数, 从日期减去指定的时间间隔.</p>
<h3 id="语法">语法</h3>
<blockquote>
<p>DATE_SUB(date,INTERVAL expr type)</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>date</code> 参数是合法的日期表达式,<code>expr</code> 参数是您希望添加的时间间隔.</p>
<p>间隔时间支持见下面时间处理</p>
</blockquote>
<figure data-type="image" tabindex="41"><a href="https://imgse.com/i/pSDEAb9"><img src="https://s1.ax1x.com/2023/02/01/pSDEAb9.png" alt="pSDEAb9.png" loading="lazy"></a></figure>
<blockquote>
<p>[<ROWS or RANGE clause> BETWEEN <Start expr> AND <End expr>]</p>
</blockquote>
<ul>
<li><code>rows</code>: 表示按照行的范围进行定义框架 根据<code>order by</code>子句排序后 取的前N行及后N行的数据计算( 与当前行的值无关 只与排序后的行号相关) . 常用: <code>rows n perceding</code>表示从当前行到前n行( 一共<code>n+1</code>行)</li>
<li><code>range</code>: 表示按照值的范围进行定义框架 根据<code>order by</code>子句排序后 指定当前行对应值的范围取值 行数不固定 只要行值在范围内 对应行都包含在内. 适用于对日期 时间 数值排序分组</li>
</ul>
<table>
<thead>
<tr>
<th>边界可取值( Start expr &amp; End expr)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Current Row</td>
<td>当前行</td>
</tr>
<tr>
<td>N preceding</td>
<td>前 n 行 n 为数字  比如 2 Preceding 表示前2行</td>
</tr>
<tr>
<td>unbounded preceding</td>
<td>开头</td>
</tr>
<tr>
<td>N following</td>
<td>后N行 n 为数字  比如 2 following 表示后2行</td>
</tr>
<tr>
<td>unbounded following</td>
<td>结尾</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>range取特定日期区间</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>range interval 7-1 day preceding</td>
<td>最近7天的值</td>
</tr>
<tr>
<td>range between interval 1 day preceding and interval 1 day following</td>
<td>前后一天和当天的值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>rows between 1 preceding and 1 following 窗口范围是分区中的当前行 前一行 后一行一共三<br>
行记录.</p>
<p>rows between 1 preceding and current row 窗口范围是分区中的前一行 当前行一共两行记录.</p>
<p>rows between current row and 1 following 窗口范围是分区中的当前行 后一行一共两行记录.</p>
<p>rows unbounded preceding 窗口范围是分区中的第一行到当前行.</p>
<p>rows between unbounded preceding and current row 窗口范围是分区中的第一行到当前行.</p>
<p>rows between current row and unbounded following 窗口范围是分区中的当前行到最后一行.</p>
<p>rows between unbounded preceding and unbounded following 窗口范围是当前分区中所有行.</p>
</blockquote>
<h4 id="1475-累积分布">14.7.5 累积分布</h4>
<pre><code class="language-mysql">CUME_DIST() OVER (
 PARTITION BY expr, ...
 ORDER BY expr [ASC | DESC], ...
)
</code></pre>
<ul>
<li><code>CUME_DIST()</code></li>
</ul>
<pre><code class="language-bash"># 累积分布
mysql&gt; SELECT
    -&gt;  name,
    -&gt;     score,
    -&gt;     ROW_NUMBER() OVER (ORDER BY score) row_num,
    -&gt;     CUME_DIST() OVER (ORDER BY score) cume_dist_val
    -&gt; FROM
    -&gt;  scores;
+----------+-------+---------+---------------+
| name     | score | row_num | cume_dist_val |
+----------+-------+---------+---------------+
| Jones    |    55 |       1 |           0.2 |
| Williams |    55 |       2 |           0.2 |
| Brown    |    62 |       3 |           0.4 |
| Taylor   |    62 |       4 |           0.4 |
| Thomas   |    72 |       5 |           0.6 |
| Wilson   |    72 |       6 |           0.6 |
| Smith    |    81 |       7 |           0.7 |
| Davies   |    84 |       8 |           0.8 |
| Evans    |    87 |       9 |           0.9 |
| Johnson  |   100 |      10 |             1 |
+----------+-------+---------+---------------+
10 rows in set (0.00 sec)
</code></pre>
<h2 id="十五-备份和还原">十五. 备份和还原</h2>
<h3 id="151-备份">15.1 备份</h3>
<blockquote>
<p>需要注意的是<code>windows</code>下<code>Powershell</code>导出的内容格式默认是<code>UTF-16</code>, 会导致异常.</p>
</blockquote>
<p>逻辑/物理的差异</p>
<ul>
<li>
<p>逻辑备份: 利用<code>mysqldump</code>命令或其他方法, 将数据以数据库中的文件提取到文件中(就是一个大型的sql语句的文件/或者<code>db</code>格式的文件), 在恢复数据时, 就执行该<code>SQL</code>语句即可, 这里就会遇到导出的数据量太大时, 将数据恢复所花费的时间.</p>
</li>
<li>
<p>物理备份: 故名思议, 将数据整体复制一份备份(将整个数据库关联的), 恢复时, 直接恢复, 而不需要执行<code>SQL</code>的重新建立数据库, 重新放入数据的这花费时间的过程.</p>
</li>
</ul>
<pre><code class="language-bash"># mysqldump命令
# --all-databases, 备份所有的数据库
# --databases + 数据库名称, 备份指定的数据库
# 符号注意'\', 需要转为&quot;/&quot;
mysqldump -uroot -p --databases test_db &gt; /all_test.sql
# 两种文件没什么区别
mysqldump -uroot -p --all-databases &gt; /backup/mysqldump/all.db
</code></pre>
<table>
<thead>
<tr>
<th>参数名</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--host</td>
<td>-h</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>--port</td>
<td>-P</td>
<td>服务器端口号</td>
</tr>
<tr>
<td>--user</td>
<td>-u</td>
<td>MySQL 用户名</td>
</tr>
<tr>
<td>--pasword</td>
<td>-p</td>
<td>MySQL 密码</td>
</tr>
<tr>
<td>--databases</td>
<td></td>
<td>指定要备份的数据库</td>
</tr>
<tr>
<td>--all-databases</td>
<td></td>
<td>备份mysql服务器上的所有数据库</td>
</tr>
<tr>
<td>--compact</td>
<td></td>
<td>压缩模式 产生更少的输出</td>
</tr>
<tr>
<td>--comments</td>
<td></td>
<td>添加注释信息</td>
</tr>
<tr>
<td>--complete-insert</td>
<td></td>
<td>输出完成的插入语句</td>
</tr>
<tr>
<td>--lock-tables</td>
<td></td>
<td>备份前 锁定所有数据库表</td>
</tr>
<tr>
<td>--no-create-db/--no-create-info</td>
<td></td>
<td>禁止生成创建数据库语句</td>
</tr>
<tr>
<td>--force</td>
<td></td>
<td>当出现错误时仍然继续备份操作</td>
</tr>
<tr>
<td>--default-character-set</td>
<td></td>
<td>指定默认字符集</td>
</tr>
<tr>
<td>--add-locks</td>
<td></td>
<td>备份数据库表时锁定数据库表</td>
</tr>
</tbody>
</table>
<p>常见的备份方式对比:</p>
<table>
<thead>
<tr>
<th>备份方法</th>
<th>备份速度</th>
<th>恢复速度</th>
<th>便捷性</th>
<th>功能</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接物理复制</td>
<td>快</td>
<td>快</td>
<td>一般, 灵活性低</td>
<td>弱</td>
<td>少量数据备份</td>
</tr>
<tr>
<td><code>mysqldump</code></td>
<td>慢</td>
<td>慢</td>
<td>一般, 可无视存储引擎的差异</td>
<td>一般</td>
<td>中小型数据量的备份</td>
</tr>
<tr>
<td><code>xtrabackup</code></td>
<td>较快</td>
<td>较快</td>
<td>实现<code>innodb</code>热备 对存储引擎有要求</td>
<td>强大</td>
<td>较大规模的备份</td>
</tr>
</tbody>
</table>
<h3 id="152-还原">15.2 还原</h3>
<pre><code class="language-bash">mysqladmin -uroot -p create db_name

# 假如sql语句中包含自动创建db, 就不需要指定db
# 直接登录MySQL, 加载sql语句
mysql -uroot -p  db_name &lt; /backup/mysqldump/db_name.db

# 注: 在导入备份数据库前 db_name如果没有 是需要创建的;  而且与db_name.db中数据库名是一样的才可以导入. 
</code></pre>
<p><code>mysql source</code>命令主要用来倒入超大的<code>sql</code>文件</p>
<pre><code class="language-java">mysql &gt; use db_name
mysql &gt; source /backup/mysqldump/db_name.db
</code></pre>
<pre><code class="language-mysql">-- 执行SQL, 输入执行的结果到执行的文件中
mysql&gt;source c:/test.sql &gt; output.log
</code></pre>
<p><em>注意输入的路径符号使用的是反斜杠.</em></p>
<h2 id="十六-日期处理">十六. 日期处理</h2>
<p>时间的处理是一个相对麻烦而不讨好的事情.</p>
<ul>
<li>跨时区</li>
<li>多种不同格式(不同时间的表示方式和时间戳)</li>
<li>间隔</li>
<li>细分时间段</li>
<li>星期天/节假日</li>
</ul>
<h3 id="161-获取时间">16.1 获取时间</h3>
<pre><code class="language-sql"># 获取当前日期时间
select NOW(); # 2021-04-02 09:25:29
# 获取当前日期
SELECT CURDATE(); # 2021-04-02
# 获取当前时间
SELECT CURTIME();  # 09:26:10

# 对于时间2021-04-02 09:25:29 分别获取其年 月 日 时 分 秒
SELECT EXTRACT(YEAR FROM NOW()); # 2021
SELECT EXTRACT(MONTH FROM NOW()); # 4
SELECT EXTRACT(DAY FROM NOW()); # 2
SELECT EXTRACT(HOUR FROM NOW()); # 9
SELECT EXTRACT(MINUTE FROM NOW()); # 25
SELECT EXTRACT(SECOND FROM NOW()); # 29

# 或者从日期格式字符串中获取
SELECT EXTRACT(SECOND FROM '2021-04-02 10:37:14.123456');  # 14
</code></pre>
<hr>
<h3 id="162-日期增加-减少">16.2 日期增加 减少</h3>
<pre><code class="language-sql"># 注意 INTERVAL
# 时间减少1小时( 前一小时) 
select date_sub(now(), INTERVAL 1 hour);
# 日期增加1天
select date_add(now(), INTERVAL 1 day);
</code></pre>
<p>支持时间间隔参数:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type 值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MICROSECOND, 毫秒</td>
</tr>
<tr>
<td style="text-align:left">SECOND, 秒</td>
</tr>
<tr>
<td style="text-align:left">MINUTE, 分</td>
</tr>
<tr>
<td style="text-align:left">HOUR, 小时</td>
</tr>
<tr>
<td style="text-align:left">DAY, 天</td>
</tr>
<tr>
<td style="text-align:left">WEEK, 周</td>
</tr>
<tr>
<td style="text-align:left">MONTH, 月</td>
</tr>
<tr>
<td style="text-align:left">QUARTER, 季度</td>
</tr>
<tr>
<td style="text-align:left">YEAR, 年</td>
</tr>
<tr>
<td style="text-align:left">SECOND_MICROSECOND</td>
</tr>
<tr>
<td style="text-align:left">MINUTE_MICROSECOND</td>
</tr>
<tr>
<td style="text-align:left">MINUTE_SECOND</td>
</tr>
<tr>
<td style="text-align:left">HOUR_MICROSECOND</td>
</tr>
<tr>
<td style="text-align:left">HOUR_SECOND</td>
</tr>
<tr>
<td style="text-align:left">HOUR_MINUTE</td>
</tr>
<tr>
<td style="text-align:left">DAY_MICROSECOND</td>
</tr>
<tr>
<td style="text-align:left">DAY_SECOND</td>
</tr>
<tr>
<td style="text-align:left">DAY_MINUTE</td>
</tr>
<tr>
<td style="text-align:left">DAY_HOUR</td>
</tr>
<tr>
<td style="text-align:left">YEAR_MONTH</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="163-日期格式化-字符串转日期">16.3 日期格式化 字符串转日期</h3>
<pre><code class="language-sql"># 格式化参考: 
select DATE_FORMAT(now(),'%Y-%m-%d %H:%i:%s');
# 只需要保留小时部分
select DATE_FORMAT(now(),'%Y-%m-%d %H:00:00');
#字符串转日期
select str_to_date('2021-04-02 10:37:14', '%Y-%m-%d %H:%i:%s'); # 2021-04-02 10:37:14
</code></pre>
<hr>
<h3 id="164-其他参考函数">16.4 其他参考函数</h3>
<p>以下较全的MySQL日期函数可做参考( 原文链接: https://blog.csdn.net/qinshijangshan/article/details/72874667)</p>
<pre><code class="language-sql">-- MySQL日期时间处理函数
-- 当前日期: 2017-05-12( 突然发现今天512 是不是会拉防空警报) 
SELECT NOW() FROM DUAL;-- 当前日期时间: 2017-05-12 11:41:47
-- 在MySQL里也存在和Oracle里类似的dual虚拟表: 官方声明纯粹是为了满足select ... from...这一习惯问题 mysql会忽略对该表的引用. 
-- 那么MySQL中就不用DUAL了吧. 
SELECT NOW();-- 当前日期时间: 2017-05-12 11:41:55
-- 除了 now() 函数能获得当前的日期时间外 MySQL 中还有下面的函数: 
SELECT CURRENT_TIMESTAMP();-- 2017-05-15 10:19:31
SELECT CURRENT_TIMESTAMP;-- 2017-05-15 10:19:51
SELECT LOCALTIME();-- 2017-05-15 10:20:00
SELECT LOCALTIME;-- 2017-05-15 10:20:10
SELECT LOCALTIMESTAMP();-- 2017-05-15 10:20:21(v4.0.6)
SELECT LOCALTIMESTAMP;-- 2017-05-15 10:20:30(v4.0.6)
-- 这些日期时间函数 都等同于 now(). 鉴于 now() 函数简短易记 建议总是使用 now()来替代上面列出的函数. 

SELECT SYSDATE();-- 当前日期时间: 2017-05-12 11:42:03
-- sysdate() 日期时间函数跟 now() 类似 
-- 不同之处在于: now() 在执行开始时值就得到了;sysdate() 在函数执行时动态得到值. 
-- 看下面的例子就明白了: 
SELECT NOW(), SLEEP(3), NOW();
SELECT SYSDATE(), SLEEP(3), SYSDATE();

SELECT CURDATE();-- 当前日期: 2017-05-12
SELECT CURRENT_DATE();-- 当前日期: 等同于 CURDATE()
SELECT CURRENT_DATE;-- 当前日期: 等同于 CURDATE()

SELECT CURTIME();-- 当前时间: 11:42:47
SELECT CURRENT_TIME();-- 当前时间: 等同于 CURTIME()
SELECT CURRENT_TIME;-- 当前时间: 等同于 CURTIME()

-- 获得当前 UTC 日期时间函数
SELECT UTC_TIMESTAMP(), UTC_DATE(), UTC_TIME()
-- MySQL 获得当前时间戳函数: current_timestamp, current_timestamp()
SELECT CURRENT_TIMESTAMP, CURRENT_TIMESTAMP();-- 2017-05-15 10:32:21 | 2017-05-15 10:32:21

-- MySQL 日期时间 Extract( 选取)  函数
SET @dt = '2017-05-15 10:37:14.123456';
SELECT DATE(@dt);-- 获取日期: 2017-05-15
SELECT TIME('2017-05-15 10:37:14.123456');-- 获取时间: 10:37:14.123456
SELECT YEAR('2017-05-15 10:37:14.123456');-- 获取年份
SELECT MONTH('2017-05-15 10:37:14.123456');-- 获取月份
SELECT DAY('2017-05-15 10:37:14.123456');-- 获取日
SELECT HOUR('2017-05-15 10:37:14.123456');-- 获取时
SELECT MINUTE('2017-05-15 10:37:14.123456');-- 获取分
SELECT SECOND('2017-05-15 10:37:14.123456');-- 获取秒
SELECT MICROSECOND('2017-05-15 10:37:14.123456');-- 获取毫秒
SELECT QUARTER('2017-05-15 10:37:14.123456');-- 获取季度
SELECT WEEK('2017-05-15 10:37:14.123456');-- 20 (获取周)
SELECT WEEK('2017-05-15 10:37:14.123456', 7);-- ****** 测试此函数在MySQL5.6下无效
SELECT WEEKOFYEAR('2017-05-15 10:37:14.123456');-- 同week()
SELECT DAYOFYEAR('2017-05-15 10:37:14.123456');-- 135 (日期在年度中第几天)
SELECT DAYOFMONTH('2017-05-15 10:37:14.123456');-- 5 (日期在月度中第几天)
SELECT DAYOFWEEK('2017-05-15 10:37:14.123456');-- 2 (日期在周中第几天; 周日为第一天)
SELECT WEEKDAY('2017-05-15 10:37:14.123456');-- 0
SELECT WEEKDAY('2017-05-21 10:37:14.123456');-- 6(与dayofweek()都表示日期在周的第几天 只是参考标准不同 weekday()周一为第0天 周日为第6天)
SELECT YEARWEEK('2017-05-15 10:37:14.123456');-- 201720(年和周)
# 201720
SELECT EXTRACT(YEAR FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(MONTH FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(DAY FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(HOUR FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(MINUTE FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(SECOND FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(MICROSECOND FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(QUARTER FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(WEEK FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(YEAR_MONTH FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(DAY_HOUR FROM '2017-05-15 10:37:14.123456');
SELECT EXTRACT(DAY_MINUTE FROM '2017-05-15 10:37:14.123456');-- 151037(日时分)
SELECT EXTRACT(DAY_SECOND FROM '2017-05-15 10:37:14.123456');-- 15103714(日时分秒)
SELECT EXTRACT(DAY_MICROSECOND FROM '2017-05-15 10:37:14.123456');-- 15103714123456(日时分秒毫秒)
SELECT EXTRACT(HOUR_MINUTE FROM '2017-05-15 10:37:14.123456');-- 1037(时分)
SELECT EXTRACT(HOUR_SECOND FROM '2017-05-15 10:37:14.123456');-- 103714(时分秒)
SELECT EXTRACT(HOUR_MICROSECOND FROM '2017-05-15 10:37:14.123456');-- 103714123456(日时分秒毫秒)
SELECT EXTRACT(MINUTE_SECOND FROM '2017-05-15 10:37:14.123456');-- 3714(分秒)
SELECT EXTRACT(MINUTE_MICROSECOND FROM '2017-05-15 10:37:14.123456');-- 3714123456(分秒毫秒)
SELECT EXTRACT(SECOND_MICROSECOND FROM '2017-05-15 10:37:14.123456');-- 14123456(秒毫秒)
-- MySQL Extract() 函数除了没有date(),time() 的功能外 其他功能一应具全. 
-- 并且还具有选取‘day_microsecond' 等功能. 
-- 注意这里不是只选取 day 和 microsecond 而是从日期的 day 部分一直选取到 microsecond 部分. 

SELECT DAYNAME('2017-05-15 10:37:14.123456');-- Monday(返回英文星期)
SELECT MONTHNAME('2017-05-15 10:37:14.123456');-- May(返回英文月份)
SELECT LAST_DAY('2016-02-01');-- 2016-02-29 (返回月份中最后一天)
SELECT LAST_DAY('2016-05-01');-- 2016-05-31

-- DATE_ADD(date,INTERVAL expr type) 从日期加上指定的时间间隔
-- type参数可参考: http://www.w3school.com.cn/sql/func_date_sub.asp
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 YEAR);-- 表示: 2018-05-15 10:37:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 QUARTER);-- 表示: 2017-08-15 10:37:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 MONTH);-- 表示: 2017-06-15 10:37:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 WEEK);-- 表示: 2017-05-22 10:37:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 DAY);-- 表示: 2017-05-16 10:37:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 HOUR);-- 表示: 2017-05-15 11:37:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 MINUTE);-- 表示: 2017-05-15 10:38:14.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 SECOND);-- 表示: 2017-05-15 10:37:15.123456
SELECT DATE_ADD('2017-05-15 10:37:14.123456',INTERVAL 1 MICROSECOND);-- 表示: 2017-05-15 10:37:14.123457

-- DATE_SUB(date,INTERVAL expr type) 从日期减去指定的时间间隔
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 YEAR);-- 表示: 2016-05-15 10:37:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 QUARTER);-- 表示: 2017-02-15 10:37:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 MONTH);-- 表示: 2017-04-15 10:37:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 WEEK);-- 表示: 2017-05-08 10:37:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 DAY);-- 表示: 2017-05-14 10:37:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 HOUR);-- 表示: 2017-05-15 09:37:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 MINUTE);-- 表示: 2017-05-15 10:36:14.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 SECOND);-- 表示: 2017-05-15 10:37:13.123456
SELECT DATE_SUB('2017-05-15 10:37:14.123456',INTERVAL 1 MICROSECOND);-- 表示: 2017-05-15 10:37:14.123455

-- 经特殊日期测试 DATE_SUB(date,INTERVAL expr type)可放心使用
SELECT DATE_SUB(CURDATE(),INTERVAL 1 DAY);-- 前一天: 2017-05-11
SELECT DATE_SUB(CURDATE(),INTERVAL -1 DAY);-- 后一天: 2017-05-13
SELECT DATE_SUB(CURDATE(),INTERVAL 1 MONTH);-- 一个月前日期: 2017-04-12
SELECT DATE_SUB(CURDATE(),INTERVAL -1 MONTH);-- 一个月后日期: 2017-06-12
SELECT DATE_SUB(CURDATE(),INTERVAL 1 YEAR);-- 一年前日期: 2016-05-12
SELECT DATE_SUB(CURDATE(),INTERVAL -1 YEAR);-- 一年后日期: 20178-06-12
-- MySQL date_sub() 日期时间函数 和 date_add() 用法一致 并且可以用INTERNAL -1 xxx的形式互换使用; 
-- 另外 MySQL 中还有两个函数 subdate(), subtime() 建议 用 date_sub() 来替代. 

-- MySQL 另类日期函数: period_add(P,N), period_diff(P1,P2)
-- 函数参数&quot; P&quot;  的格式为&quot; YYYYMM&quot;  或者 &quot; YYMM&quot;  第二个参数&quot; N&quot;  表示增加或减去 N month( 月) . 
-- MySQL period_add(P,N): 日期加/减去N月. 
SELECT PERIOD_ADD(201705,2), PERIOD_ADD(201705,-2);-- 201707  20170503
-- period_diff(P1,P2): 日期 P1-P2 返回 N 个月. 
SELECT PERIOD_DIFF(201706, 201703);--
-- datediff(date1,date2): 两个日期相减 date1 - date2 返回天数
SELECT DATEDIFF('2017-06-05','2017-05-29');-- 7
-- TIMEDIFF(time1,time2): 两个日期相减 time1 - time2 返回 TIME 差值
SELECT TIMEDIFF('2017-06-05 19:28:37', '2017-06-05 17:00:00');-- 02:28:37

-- MySQL日期转换函数
SELECT TIME_TO_SEC('01:00:05'); -- 3605
SELECT SEC_TO_TIME(3605);-- 01:00:05

-- MySQL ( 日期 天数) 转换函数: to_days(date), from_days(days)
SELECT TO_DAYS('0000-00-00'); -- NULL
SELECT TO_DAYS('2017-06-05'); -- 736850
SELECT FROM_DAYS(0);           -- '0000-00-00'
SELECT FROM_DAYS(736850);      -- '2017-06-05'

-- MySQL Str to Date ( 字符串转换为日期) 函数: str_to_date(str, format)
SELECT STR_TO_DATE('06.05.2017 19:40:30', '%m.%d.%Y %H:%i:%s');-- 2017-06-05 19:40:30
SELECT STR_TO_DATE('06/05/2017', '%m/%d/%Y');                  -- 2017-06-05
SELECT STR_TO_DATE('2017/12/3','%Y/%m/%d')		       -- 2017-12-03
SELECT STR_TO_DATE('20:09:30', '%h:%i:%s')		       -- NULL(超过12时的小时用小写h 得到的结果为NULL)

-- 日期时间格式化
SELECT DATE_FORMAT('2017-05-12 17:03:51', '%Y年%m月%d日 %H时%i分%s秒');-- 2017年05月12日 17时03分51秒(具体需要什么格式的数据根据实际情况来;小写h为12小时制;)
SELECT TIME_FORMAT('2017-05-12 17:03:51', '%Y年%m月%d日 %H时%i分%s秒');-- 0000年00月00日 17时03分51秒(time_format()只能用于时间的格式化)
-- STR_TO_DATE()和DATE_FORMATE()为互逆操作
-- MySQL 获得国家地区时间格式函数: get_format()
-- MySQL get_format() 语法: get_format(date|time|datetime, 'eur'|'usa'|'jis'|'iso'|'internal'
-- MySQL get_format() 用法的全部示例: 
SELECT GET_FORMAT(DATE,'usa');   	-- '%m.%d.%Y'
SELECT GET_FORMAT(DATE,'jis');   	-- '%Y-%m-%d'
SELECT GET_FORMAT(DATE,'iso');   	-- '%Y-%m-%d'
SELECT GET_FORMAT(DATE,'eur');   	-- '%d.%m.%Y'
SELECT GET_FORMAT(DATE,'internal');   	-- '%Y%m%d'
SELECT GET_FORMAT(DATETIME,'usa');   	-- '%Y-%m-%d %H.%i.%s'
SELECT GET_FORMAT(DATETIME,'jis');   	-- '%Y-%m-%d %H:%i:%s'
SELECT GET_FORMAT(DATETIME,'iso');   	-- '%Y-%m-%d %H:%i:%s'
SELECT GET_FORMAT(DATETIME,'eur');   	-- '%Y-%m-%d %H.%i.%s'
SELECT GET_FORMAT(DATETIME,'internal'); -- '%Y%m%d%H%i%s'
SELECT GET_FORMAT(TIME,'usa');   	-- '%h:%i:%s %p'
SELECT GET_FORMAT(TIME,'jis');   	-- '%H:%i:%s'
SELECT GET_FORMAT(TIME,'iso');   	-- '%H:%i:%s'
SELECT GET_FORMAT(TIME,'eur');   	-- '%H.%i.%s'
SELECT GET_FORMAT(TIME,'internal');     -- '%H%i%s'

-- MySQL 拼凑日期 时间函数: makdedate(year,dayofyear), maketime(hour,minute,second)
SELECT MAKEDATE(2017,31);   -- '2017-01-31'
SELECT MAKEDATE(2017,32);   -- '2017-02-01'
SELECT MAKETIME(19,52,35);  -- '19:52:35'
-- MySQL 时区( timezone) 转换函数: convert_tz(dt,from_tz,to_tz)
SELECT CONVERT_TZ('2017-06-05 19:54:12', '+08:00', '+00:00'); -- 2017-06-05 11:54:12

-- MySQL ( Unix 时间戳 日期) 转换函数
-- unix_timestamp(), unix_timestamp(date), from_unixtime(unix_timestamp), from_unixtime(unix_timestamp,format)
-- 将具体时间时间转为timestamp
SELECT UNIX_TIMESTAMP();-- 当前时间的时间戳: 1494815779
SELECT UNIX_TIMESTAMP('2017-05-15');-- 指定日期的时间戳: 1494777600
SELECT UNIX_TIMESTAMP('2017-05-15 10:37:14');-- 指定日期时间的时间戳: 1494815834

-- 将时间戳转为具体时间
SELECT FROM_UNIXTIME(1494815834);-- 2017-05-15 10:37:14
SELECT FROM_UNIXTIME(1494815834, '%Y年%m月%d日 %h时%分:%s秒');-- 获取时间戳对应的格式化日期时间

-- MySQL 时间戳( timestamp) 转换 增 减函数
SELECT TIMESTAMP('2017-05-15');-- 2017-05-15 00:00:00
SELECT TIMESTAMP('2017-05-15 08:12:25', '01:01:01');-- 2017-05-15 09:13:26
SELECT DATE_ADD('2017-05-15 08:12:25', INTERVAL 1 DAY);-- 2017-05-16 08:12:25
SELECT TIMESTAMPADD(DAY, 1, '2017-05-15 08:12:25');-- 2017-05-16 08:12:25; MySQL timestampadd() 函数类似于 date_add(). 

SELECT TIMESTAMPDIFF(YEAR, '2017-06-01', '2016-05-15');-- -1
SELECT TIMESTAMPDIFF(MONTH, '2017-06-01', '2016-06-15');-- -11
SELECT TIMESTAMPDIFF(DAY, '2017-06-01', '2016-06-15');-- -351
SELECT TIMESTAMPDIFF(HOUR, '2017-06-01 08:12:25', '2016-06-15 00:00:00');-- -8432
SELECT TIMESTAMPDIFF(MINUTE, '2017-06-01 08:12:25', '2016-06-15 00:00:00');-- -505932
SELECT TIMESTAMPDIFF(SECOND, '2017-06-01 08:12:25', '2016-06-15 00:00:00');-- -30355945
</code></pre>
<h2 id="十七-外部交互">十七. 外部交互</h2>
<h3 id="171-python">17.1 Python</h3>
<pre><code class="language-bash"># 假如没有安装
# 安装python/connector
pip install mysql-connector-python
</code></pre>
<pre><code class="language-python">import mysql_connector as conn

# 数据库的连接配置
configs = {
    &quot;user&quot;: &quot;your_id&quot;,
    &quot;host&quot;: &quot;localhost&quot;,
    &quot;passwd&quot;: &quot;your_pw&quot;,
    &quot;port&quot;: 3306,
    &quot;database&quot;: &quot;your_db&quot;
}

my_sql = conn.connect(**configs)

# 通过pandas读取数据
my_data = pd.read_sql(&quot;select * from table limit 10;&quot;, my_sql)

# 游标的方式
cursor = my_sql.cursor()

# 读取内容
cursor.execute(&quot;select * from table limit 10;&quot;)

# 读取内容后, 记得清空游标的数据
cursor.fetchall()
my_sql.free_result()

# 退出mysql
cursor.close()
my_sql.cmd_quit()
</code></pre>
<h3 id="172-powerbi">17.2 PowerBI</h3>
<p><a href="https://learn.microsoft.com/en-us/power-bi/connect-data/power-bi-data-sources">Power BI data sources</a></p>
<blockquote>
<p>Power BI can connect to data by using existing connectors and generic data sources, like ODBC, OData, OLE DB, Web, CSV, XML, and JSON. Or, developers can enable new data sources with custom data extensions called <em>custom connectors</em>. Some custom connectors are certified and distributed by Microsoft as <em>certified connectors</em>.</p>
</blockquote>
<p><code>mysql</code>和<code>power bi</code>之间的连接需要<code>.net</code>版本的<code>connector</code>支持, 可以通过<code>mysql installer</code>管理器, 增加这个组件.</p>
<figure data-type="image" tabindex="42"><img src="https://p0.meituan.net/csc/3dd61fc840191b4c3cab9e78cfa701c139468.png" alt="connector" loading="lazy"></figure>
<p>数据可以直接在<code>powerbi</code>上预览, 也可以在连接时, 直接从<code>SQL</code>语句中返回结果.</p>
<figure data-type="image" tabindex="43"><img src="https://p0.meituan.net/csc/62dea66845c9d1ee4e88d260a5d1641c25990.png" alt="sql" loading="lazy"></figure>
<p>另一种方式就是通过传统的<code>ODBC</code>进行连接</p>
<figure data-type="image" tabindex="44"><img src="https://p0.meituan.net/csc/76279875647601a2eb26cb297510c06813587.png" alt="odbc" loading="lazy"></figure>
<p>相关配置见下面的<code>VBA</code>部分</p>
<h3 id="173-vba">17.3 VBA</h3>
<h4 id="1731-环境">17.3.1 环境</h4>
<ol>
<li><code>Office 2016, 32bit</code>(注意这里的版本问题)</li>
<li><code>MySQL 8.x</code></li>
</ol>
<p>安装教程略过, 但是在安装驱动时需要注意安装对应的驱动和安装的<code>office</code>版本相对应, <code>32</code>位的<code>office</code>安装<code>32</code>为, <code>64</code>位<code>office</code>安装<code>64</code>位.</p>
<p>(注: 建议使用<code>MySQL installer</code>来安装和管理<code>MySQL</code>, 方便配置和调整.)</p>
<figure data-type="image" tabindex="45"><img src="https://p0.meituan.net/dpplatform/b9fc192e64f0721be2132f1d0df4f2b335356.png" alt="odbc" loading="lazy"></figure>
<h4 id="1732-vba和mysql的连接主要依赖组件">17.3.2 VBA和MySQL的连接主要依赖组件</h4>
<p><code>VBA</code>端: 依赖于<code>Microsoft ActiveX Data Object</code></p>
<p><em>(注: 或者可以补充勾选Microsoft ActiveX Data Objects Recordset 2.8 Library)</em></p>
<figure data-type="image" tabindex="46"><img src="https://p0.meituan.net/dpplatform/975f61a2aa60f4da4d6a12d72c32416410979.png" alt="ado" loading="lazy"></figure>
<p>中间件: <code>ODBC(Open Database Connectivity)</code></p>
<h4 id="1733-配置连接">17.3.3 配置连接</h4>
<p>在<code>Windows</code>中需要配置</p>
<figure data-type="image" tabindex="47"><img src="https://p1.meituan.net/dpplatform/20a9b6a4cca4b90093ac53f59a0add36166724.png" alt="ODBC" loading="lazy"></figure>
<p>注意配置需要区分开<code>32</code>位和<code>64</code>位和安装的<code>office</code>, <code>ODBC</code>一致)</p>
<p>打开后添加驱动</p>
<figure data-type="image" tabindex="48"><img src="https://p0.meituan.net/dpplatform/adfe89756c7edfa791a0818eef316a7338019.png" alt="driver" loading="lazy"></figure>
<p>选择<code>unicode</code>即可</p>
<p>配置数据库的连接</p>
<figure data-type="image" tabindex="49"><img src="https://p0.meituan.net/dpplatform/8c6c040926a6835b8177422ee7564a7a41985.png" alt="cofigs" loading="lazy"></figure>
<p>填写完参数, 务必测试连接是否可用.</p>
<p><code>VBA</code>连接测试</p>
<pre><code class="language-vbscript">Option Explicit

Sub test()
    Dim con As New ADODB.Connection

    con.ConnectionString = &quot;Driver={MySQL ODBC 8.0 Unicode Driver};Server=localhost;DB=test_db;UID=root;PWD=123456;OPTION=3;&quot;
    con.Open
    MsgBox (&quot;connect&quot; &amp; vbCrLf &amp; &quot;mysql&quot; &amp; con.State &amp; vbCrLf &amp; &quot;mysql version&quot; &amp; con.Version)
    con.Close
    Set con = Nothing
End Sub
</code></pre>
<p>参数解析</p>
<blockquote>
<p>&quot;Driver={MySQL ODBC 8.0 Unicode Driver};Server=localhost;DB=test_db;UID=root;PWD=123456;OPTION=3;&quot;</p>
</blockquote>
<p><code>Driver</code>: 驱动名称</p>
<p><code>Serve</code>r: 数据库地址</p>
<p><code>DB</code>: 需要连接的数据库具体名称</p>
<p><code>UID</code>: 用户名称</p>
<p><code>PWD</code>: 登录密码</p>
<p><code>OPTION</code>: 取自<a href="https://dev.mysql.com/doc/connector-odbc/en/connector-odbc-configuration-connection-without-dsn.html">官方文档</a>, 和驱动的工作方式有关, 但是这个参数=3没有查到具体的含义, 在<a href="https://dev.mysql.com/doc/connector-odbc/en/connector-odbc-configuration-connection-parameters.html">文档</a>中没有提及3的含义</p>
<h4 id="1734-在局域网中访问">17.3.4 在局域网中访问</h4>
<ol>
<li>确保Windows防火墙(假如处于开启状态)的进站规则当中包含MySQL的端口处于开放的状态(默认端口<code>3306</code>/<code>33060</code>), 使用前可以先ping对应的主机是否可用.</li>
<li><a href="https://www.cnblogs.com/chig/p/11907047.html">配置数据库的权限</a>, 允许局域网访问.</li>
</ol>
<h3 id="174-文本数据交互">17.4 文本数据交互</h3>
<p>相关的参数, 同样适用诸在<code>python pandas</code>的文本内容的读取上.</p>
<h4 id="1741-导入">17.4.1 导入</h4>
<pre><code class="language-mysql"># csv / txt / 或者其他制表符的变种文件
# 需要注意的细节
# 字符编码
# 错误处理
# 重复数据处理
# 字符的转义
# 字符的连带符号, 例如逗号分隔符下的&quot;,&quot;逗号需要保留下来
LOAD DATA
    [LOW_PRIORITY | CONCURRENT] [LOCAL] | 锁的影响, low, 在其他线程执行完, 在执行, con, 同时执行;
    INFILE 'file_name' | 文件
    [REPLACE | IGNORE] | 处理冲突数据;
    INTO TABLE tbl_name | 插入的数据表
    [PARTITION (partition_name [, partition_name] ...)] | 分区相关(假如表采用了分区)
    [CHARACTER SET charset_name] | 编码类型
    [{FIELDS | COLUMNS} | 字段相关, 任意指定一个参数即可, 等价的
        [TERMINATED BY 'string'] | 分隔符
        [[OPTIONALLY] ENCLOSED BY 'char'] | 字段值由什么符号包围, 例如 需要表示 &quot;abc&quot;, 包含符号在内
        [ESCAPED BY 'char'] | 转义字符
    ]
    [LINES | 行相关
        [STARTING BY 'string'] |
        [TERMINATED BY 'string'] | 分割符号, 即每一行是使用什么换行符
    ]
    [IGNORE number {LINES | ROWS}] | 跳过前几行, 从1开始(一般为表头, 就跳过1)
    [(col_name_or_user_var | 字段名称
        [, col_name_or_user_var] ...)]
    [SET col_name={expr | DEFAULT} | 设置字段名称
        [, col_name={expr | DEFAULT}] ...]
</code></pre>
<pre><code class="language-bash">create table test_c (
	user_name varchar(16) not null,
	piece smallint unsigned,
	price float,
	pay_amount float,
	goods_category varchar(16),
	pay_time timestamp
);

mysql&gt; load data infile 'C:/Users/Lian/Desktop/user_trade.csv'
    -&gt; into table test_c
    -&gt; fields terminated by ','
    -&gt; lines terminated by '\n'
    -&gt; ignore 1 lines
    -&gt; (`user_name`,`piece`,`price`, `pay_amount`, `goods_category`, `pay_time`);
ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement
</code></pre>
<pre><code class="language-bash"># 这个参数能临时允许数据导入? 没测试
mysql&gt; show global variables like 'local_infile';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| local_infile  | OFF   |
+---------------+-------+
1 row in set (0.00 sec)

mysql&gt; show variables like '%secure%';
+--------------------------+-----------------------+
| Variable_name            | Value                 |
+--------------------------+-----------------------+
| require_secure_transport | OFF                   |
| secure_file_priv         | /var/lib/mysql-files/ |
+--------------------------+-----------------------+
2 rows in set (0.00 sec)
</code></pre>
<pre><code class="language-bash">## secure_file_priv  是个只读变量, 修改必须在配置文件
# 指定可以从特定的路径,导入数据
# linux, cnf
# windows, ini
# 这里是在linux

# 先暂停服务
sudo service mysql stop

# 进入配置文件
sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf

# 由于文件是存放在主机上的, linux在wsl上
# 在配置文件上, 添加一个路径
# secure_file_priv=/mnt/c/Users/Lian/Desktop/
# 假如设置为secure_file_priv = '', 理论上这是表示任意路径下的文件的导入
# 访问时会加上 /var/lib/mysql-files/ + 传入的路径

# 重启服务
sudo service mysql start

# 添加数据即可, 注意文件的编码类型, 这里表默认utf-8, 文件也需要时utf-8
load data infile '/mnt/c/Users/Lian/Desktop/user_trade.csv'
into table test_c
fields terminated by ','
lines terminated by '\n'
ignore 1 lines
(`user_name`, `piece`, `price`, `pay_amount`, `goods_category`, `pay_time`);
# 注意时间
# 2020-01-01
# excel会将时间转为如下, 在转为csv文件时
# 1/1/2020
# 手动复制时间重新覆盖csv文件上的数据即可.
# 导入速度非常快
mysql&gt; select * from test_c limit 10;
+-----------+-------+-------+------------+----------------+---------------------+
| user_name | piece | price | pay_amount | goods_category | pay_time            |
+-----------+-------+-------+------------+----------------+---------------------+
| Allison   |     4 | 688.8 |     2755.2 | shoes          | 2018-01-07 00:00:00 |
| Francis   |    83 |   1.1 |       91.3 | food           | 2018-01-07 00:00:00 |
| DEMI      |    26 |  2222 |      57772 | electronics    | 2018-01-12 00:00:00 |
| DEMI      |    39 |   200 |       7800 | clothes        | 2018-01-12 00:00:00 |
| Enid      |    15 |  6666 |      99990 | computer       | 2018-01-12 00:00:00 |
| Heidi     |    93 | 688.8 |    64058.4 | shoes          | 2018-01-12 00:00:00 |
| Jackson   |    43 |   200 |       8600 | clothes        | 2018-01-12 00:00:00 |
| Carroll   |     1 | 688.8 |      688.8 | shoes          | 2018-01-22 00:00:00 |
| Carlos    |    52 |   8.9 |      462.8 | book           | 2018-02-05 00:00:00 |
| Aviva     |    74 |  2222 |     164428 | electronics    | 2018-02-05 00:00:00 |
+-----------+-------+-------+------------+----------------+---------------------+
10 rows in set (0.00 sec)
</code></pre>
<h4 id="1742-导出">17.4.2 导出</h4>
<pre><code class="language-mysql"># 参数设置和导入一样
# 只是数据的导入导出差异
# 安全设置也一样
# 默认导出数据不包含表头
with tmp as (select 'id', 'name' union select id, name from test_e)
SELECT * FROM tmp
INTO OUTFILE &quot;/mnt/c/Users/Lian/Desktop/abc.csv&quot;
FIELDS TERMINATED BY &quot;,&quot; ENCLOSED BY '&quot;' lines terminated by '\n';
</code></pre>
<pre><code class="language-bash"># with tmp as (select 'id', 'name' union select id, name from test_e)
# 设置表头
mysql&gt; select 'id', 'name' union select id, name from test_e;
+----+------+
| id | name |
+----+------+
| id | name |
| 1  | tom  |
| 2  | xx   |
| 3  | jimi |
| 4  | tome |
| 5  | al   |
| 6  | jamy |
+----+------+
7 rows in set (0.00 sec)
</code></pre>
<h2 id="十八-使用与实践">十八. 使用与实践</h2>
<h3 id="181-数据库设计范式">18.1 数据库设计范式</h3>
<p>设计范式只是理想状态下的要求, 未必是最佳实践(如: 表字段拆分过细, 对于多表的关联查询或者是数据的获取是否造成不必要的麻烦? 数据的更新, 插入新数据等是否存在问题等).</p>
<ul>
<li>第一范式: 原子性, 每个字段的值不能再分.</li>
<li>第二范式: 唯一性, 表内每行数据必须描述同一业务属性的数据.</li>
<li>第三范式: 独立性, 表中每个非主键字段之间不能存在依赖性.</li>
<li>巴斯范式(<code>BCNF</code>): 主键字段独立性, 联合主键字段之间不能存在依赖性.</li>
<li>第四范式: 表中字段不能存在多值依赖关系.</li>
<li>第五范式: 表中字段的数据之间不能存在连接依赖关系.</li>
<li>域键范式: 试图研究出一个库表设计时的终极完美范式.</li>
</ul>
<p>以下介绍前三大范式:</p>
<h4 id="1811-1nf">18.1.1 1NF</h4>
<p><em>无比需要实现的一个规范</em>.</p>
<p>相对容易理解, 作为关系型数据库的<strong>基础</strong>要求规范. 看似简单, 但是也最为核心的一环, 没有这一环, 后续的其他的设计范式皆是空中楼阁, 镜中花水中月.</p>
<ul>
<li>每个列必须有一个唯一的名称.</li>
<li>行和列的次序无关紧要.</li>
<li>不允许包含相同值的两行.</li>
<li>每一列都必须包含一个单值 (一个列不能保存多个数据值).</li>
<li>列不能包含重复的组.</li>
</ul>
<p>简而言之, 其中的关键在于数据的拆分.</p>
<p>例如:</p>
<table>
<thead>
<tr>
<th>id</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A省B市C区D街道E路F楼G号房</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>id</th>
<th>province</th>
<th>city</th>
<th>district</th>
<th>street</th>
<th>detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A省</td>
<td>B市</td>
<td>C区</td>
<td>D街道</td>
<td>E路F楼G号房</td>
</tr>
</tbody>
</table>
<p>数据被拆分到<code>原子</code>层级, <code>不可再分</code>为止, 这样做的好处是显而易见的.</p>
<p>以数据检索为例: 将可以轻松定位不同层级的数据. 将字符串转换为对应的区域编码, 使用整数作为字符串, 形成一一对应的关系, 数据的检索将变得更快.</p>
<h4 id="1812-2nf">18.1.2 2NF</h4>
<p>符合<code>1NF</code>的前提下, 满足以下要求:</p>
<ul>
<li>表中必须存在业务<code>主键</code>, 并且非主键<code>全部</code>依赖于业务主键</li>
</ul>
<table>
<thead>
<tr>
<th>name</th>
<th>id</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>alex</td>
<td>1</td>
<td>us</td>
</tr>
<tr>
<td>alex</td>
<td>2</td>
<td>china</td>
</tr>
</tbody>
</table>
<p><code>name</code>显然无法作为主键, 因为<code>name</code>可能存在重复值.</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>country_name</th>
<th>country_code</th>
<th>college</th>
<th>course</th>
<th>grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>alex</td>
<td>us</td>
<td>1001</td>
<td>cs</td>
<td>math</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>alex</td>
<td>us</td>
<td>1001</td>
<td>cs</td>
<td>enconomy</td>
<td>c</td>
</tr>
<tr>
<td>2</td>
<td>tom</td>
<td>cn</td>
<td>1002</td>
<td>pr</td>
<td>english</td>
<td>a</td>
</tr>
<tr>
<td>3</td>
<td>alex</td>
<td>en</td>
<td>1003</td>
<td>cs</td>
<td>math</td>
<td>a</td>
</tr>
</tbody>
</table>
<p>每个<code>id</code>不同的<code>course</code>的情况下, 就出现数据需要重复, 造成数据<code>冗余</code>的问题.</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>country_name</th>
<th>country_code</th>
<th>college</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>alex</td>
<td>us</td>
<td>1001</td>
<td>cs</td>
</tr>
<tr>
<td>2</td>
<td>tom</td>
<td>cn</td>
<td>1002</td>
<td>pr</td>
</tr>
<tr>
<td>3</td>
<td>alex</td>
<td>en</td>
<td>1003</td>
<td>cs</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>id</th>
<th>course</th>
<th>grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>math</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>enconomy</td>
<td>c</td>
</tr>
<tr>
<td>2</td>
<td>english</td>
<td>a</td>
</tr>
<tr>
<td>3</td>
<td>math</td>
<td>a</td>
</tr>
</tbody>
</table>
<p>简而言之, 主键, 和每张表尽量实现自身的独立性.</p>
<h4 id="1813-3nf">18.1.3 3NF</h4>
<p>满足<code>2NF</code>要求的前提下, 满足以下要求</p>
<ul>
<li>不包含传递相关性, 即, 一个非键值字段的值依赖于另一个非键值字段的值, 不含冗余数据.</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>country_code</th>
<th>college</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>alex</td>
<td>1001</td>
<td>cs</td>
</tr>
<tr>
<td>2</td>
<td>tom</td>
<td>1002</td>
<td>pr</td>
</tr>
<tr>
<td>3</td>
<td>alex</td>
<td>1003</td>
<td>cs</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>id</th>
<th>course</th>
<th>grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>math</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>enconomy</td>
<td>c</td>
</tr>
<tr>
<td>2</td>
<td>english</td>
<td>a</td>
</tr>
<tr>
<td>3</td>
<td>math</td>
<td>a</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>country_code</th>
<th>country_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>us</td>
</tr>
<tr>
<td>1002</td>
<td>cn</td>
</tr>
<tr>
<td>1003</td>
<td>en</td>
</tr>
</tbody>
</table>
<p>简而言之, 就决定某字段值的必须是主键.</p>
<ul>
<li><a href="https://www.zhihu.com/question/24696366/answer/29189700">参考连接</a></li>
</ul>
<h3 id="182-业务实践">18.2 业务实践</h3>
<ul>
<li>浮点数的处理: <code>A</code>方案: 为了保持精度使用<code>decimal</code>类型来保存; <code>B</code>方案: 在前端将数据转为整数后, 例如乘以<code>1000/10000</code>, 相对于<code>double</code>类型的, 整数型字段占用的空间更小.</li>
<li>前后端操作的分离: 如<code>排序</code>结果输出(排序是典型的<code>CPU</code>密集型的操作), 完全可以放在前端执行, 而不一定需要在服务端执行完后才输出结果, 考虑到数据库所处的服务器端(后端)的<code>CPU</code>资源相对宝贵.</li>
<li>对于需要对表格结果和内容发生较大改变的操作, 如<code>alter</code>语句, 需要控制特定时间段的执行, 减少数据库操作对业务层的影响.</li>
<li>尽量保持个字段非<code>null</code>约束(<code>null</code>的存在存在很多隐形问题, 如索引失效, 窗口函数排序等).</li>
<li><code>join</code>表格的数据, 尽量少于<code>3</code>个(阿里巴巴<code>Java</code>手册<code>1.6</code>提及的要求).</li>
<li>应该禁止<code>跨数据库</code>的<code>join</code>.</li>
<li>核心表需要有<code>时间戳</code>字段用于<code>追踪</code>数据的变化, 方便问题出现的<code>回溯</code>.</li>
<li>建表时的字段需要<code>comment</code>, 以便于快速确定字段的含义.</li>
<li>有效控制字段的数据类型, 例如人的<code>年龄</code>, 很显然<code>tinyint unsigned</code> (0 - 255)完全满足需求, 就不必要直接使用<code>int</code>, 减少资源的占用.</li>
<li>减少非索引的SQL语句的使用, 如<code>like </code>等可能导致的索引失效, 对于执行效率底下的<code>SQL</code>语句, 应当<code>explain</code>检查执行的细节.</li>
<li>数据是否需要执行真实的删除操作, 还是使用删除标记即可(增加一个字段标注当前的行的使用状态)(减少数据可能误删的情况).(或者是在数据库处于非服务状态集中进行删除和表的优化)</li>
<li>数据库再服务状态避免进行表结构的变化的操作.</li>
</ul>
<h3 id="183-小表驱动大表">18.3 小表驱动大表?</h3>
<p>前提, 小表, 大表, 即在数据检索中, 涉及到多个表, 表之间的数据差异较大.</p>
<p>所谓大小表驱动大表, 主要环节在于减少循环的次数.</p>
<pre><code class="language-python">for a in range(100):
    ... # do something
    # 将长耗时放置在外层的循环
    for b in range(100000000):
        # 假设某个耗时的操作在这个循环执行, 显然是很慢的
        ... # do something
</code></pre>
<p>主要涉及 <code>exists</code>, <code>in</code>以及<code>join</code>.</p>
<pre><code class="language-mysql">delimiter $$
CREATE PROCEDURE rand_test_a_data (in i_many int)
BEGIN
	DECLARE ic int DEFAULT 0;

	truncate table test_a;

	START TRANSACTION;
	REPEAT
		insert into test_a (id, col) VALUES (floor(rand() * 100000), LEFT ( concat(rand() * 10000000000, 'ajkshxm' ), 18 ));
		set ic = ic + 1;
	UNTIL
		ic = i_many
	END REPEAT;

	COMMIT;

end $$
delimiter ;
</code></pre>
<p>使用上述的两个存储过程, <code>test_tbale </code>表(大表), 写入<code>1,000,000</code>行的随机数据, 分别测试在<code>test_a</code>,<code> 10, 100, 1,000, 50,000</code>函数的数据, 按照查找到的资料基本介绍进行测试.</p>
<pre><code class="language-mysql">explain analyze select * from test_table where col in (select col from test_a);

explain analyze select * from test_table where exists (select 1 from test_a where test_a.col = test_table.col);
</code></pre>
<p>上述两条语句, 基本没有测试出任何的差别(可以显著看到时间差异的水平).</p>
<p><code>join</code>中的差异</p>
<p>创建<code>test_a</code>, 随机插入<code>1000000</code>万行的数据</p>
<p>创建<code>test_b</code>, 随机插入<code>10000</code>行的数据</p>
<pre><code class="language-bash">mysql&gt; select a.* from test_b b join test_a a on a.idx = b.idx;

90 rows in set (0.45 sec)(多次测试)
</code></pre>
<pre><code class="language-bash">mysql&gt; select a.* from test_a a join test_b b on a.idx = b.idx;
90 rows in set (0.47 sec) (多次测试)
</code></pre>
<p>还是相对明显的, 速度的差异, 作为驱动表的是小表, 那么在速度上是优于大表作为驱动.</p>
<h3 id="184-术语">18.4 术语</h3>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html">MySQL Glossary</a></p>
<h4 id="1841-回表">18.4.1 回表</h4>
<p><em>相关内容见另一篇文章.</em></p>
<p><em>查询到信息对这个词的介绍相当混乱, 各种文章都是相互抄袭, 不管对错.</em></p>
<p>主要涉及</p>
<ul>
<li>索引的类型, 聚簇索引(<code>Clustered Index</code>), 二级索引(<code>Secondary Index</code>)(辅助索引), 具体见上述的索引章节.</li>
<li><code>B Tree+</code></li>
<li>联合索引</li>
</ul>
<p>所谓的回表, 是否可以简单理解, 查询获取的数据不是执行一次, 即检索到A然后在基础查找B?</p>
<p><code>explain select id from test_d where id =3;</code>这个语句相对明确, 数据的获取是不需要从表获取的, 因为索引即数据, 返回找到的索引即可.</p>
<pre><code class="language-bash"># 不同情况下, Extra展示的信息
mysql&gt; desc test_d;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| id      | int         | NO   | PRI | NULL    |       |
| name    | char(4)     | YES  | MUL | NULL    |       |
| address | varchar(10) | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

mysql&gt; insert into test_d values (1, 'tom', 'abc'), (2, 'alex', 'abc'), (3, 'tom', 'bb'), (4, 'jam','csa');
Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; select * from test_d;
+----+------+---------+
| id | name | address |
+----+------+---------+
|  1 | tom  | abc     |
|  2 | alex | abc     |
|  3 | tom  | bb      |
|  4 | jam  | csa     |
+----+------+---------+
4 rows in set (0.00 sec)

# 这种情况?
mysql&gt; explain select * from test_d where id = 3;
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test_d | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

# 这里和下面的语句的差异?
mysql&gt; explain select id, name from test_d where id = 3;
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test_d | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

# 注意和上面的语句的差异
mysql&gt; explain select id, name from test_d where name = 'tom';
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+--------------------------+
| id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | test_d | NULL       | ref  | index_name    | index_name | 17      | const |    2 |   100.00 | Using where; Using index |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select id from test_d where name = 'tom';
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+--------------------------+
| id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | test_d | NULL       | ref  | index_name    | index_name | 17      | const |    2 |   100.00 | Using where; Using index |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select id from test_d where id =3;
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | test_d | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql&gt; explain select id, name, address from test_d where id =3;
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test_d | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

# 使用distinct
mysql&gt; explain select distinct name from test_d;
+----+-------------+--------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_d | NULL       | index | index_name    | index_name | 17      | NULL |    4 |   100.00 | Using index |
+----+-------------+--------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

# 在非索引的列执行
mysql&gt; explain select distinct address from test_d;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra
        |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | SIMPLE      | test_d | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | Using temporary |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-----------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<ul>
<li>using index</li>
<li>using where</li>
<li>using temporary</li>
<li>null</li>
<li>...</li>
</ul>
<p>针对上述信息的<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra">官方文档解析</a>.</p>
<p>由于内容较多, 这里不一一详述, 这里着重注意<code>using index</code>的情形</p>
<blockquote>
<p>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.</p>
<p>可以认为显示为using index时, 数据的获取不需要再表中查找, 而是直接返回索引上的信息?</p>
<p>For <code>InnoDB</code> tables that have a user-defined clustered index, that index can be used even when <code>Using index</code> is absent from the <code>Extra</code> column. This is the case if <code>type</code> is <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index"><code>index</code></a> and <code>key</code> is <code>PRIMARY</code>.</p>
<p>对于具有用户定义的聚集索引的<code>InnoDB</code>表, 即使在Extra列中没有<code>Using</code>索引时, 也可以使用该索引. 如果<code>type</code>是<code>index</code>而key是<code>PRIMARY</code> 就会出现这种情况.</p>
<p>Information about any covering indexes used is shown for <code>EXPLAIN FORMAT=TRADITIONAL</code> and <code>EXPLAIN FORMAT=JSON</code>. Beginning with MySQL 8.0.27, it is also shown for <code>EXPLAIN FORMAT=TREE</code>.</p>
</blockquote>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Lian
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://Kyouichirou.github.io/post/mysql-shi-yong-zhi-nan/" title="MySQL使用指南">https://Kyouichirou.github.io/post/mysql-shi-yong-zhi-nan/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://Kyouichirou.github.io/tag/7svOER7Ka/"># priority</a>
    
      <a href="https://Kyouichirou.github.io/tag/53itHjBFa/"># mysql</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Python进阶之道" href="https://Kyouichirou.github.io/post/python-jin-jie-zhi-dao/">Python进阶之道</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Python进阶之道" href="https://Kyouichirou.github.io/post/python-jin-jie-zhi-dao/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="MySQL生成测试数据" href="https://Kyouichirou.github.io/post/mysql-sheng-cheng-ce-shi-shu-ju/">MySQL生成测试数据</a>
        <a class="nav-mobile-next" title="MySQL生成测试数据" href="https://Kyouichirou.github.io/post/mysql-sheng-cheng-ce-shi-shu-ju/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/Kyouichirou" target="_blank">Kyouichirou</a>
    </div>
  </footer>
  
    
      <div class="drawer-box left" id="drawer_box">
        <span class="muse-line muse-line-first"></span>
        <span class="muse-line muse-line-middle"></span>
        <span class="muse-line muse-line-last"></span>
      </div>
      
        <div class="mist back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
        
          
            
              <div class="bg-img">
                <img src="https://s1.ax1x.com/2023/03/24/ppBNvm6.jpg" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn && rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = 'en';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.staticfile.org/smooth-scroll/16.1.3/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






  <div class="snow-container"></div>
  <script src="/media/js/bg/snow.js"></script>

</html>